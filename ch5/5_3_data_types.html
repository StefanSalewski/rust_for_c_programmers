<!DOCTYPE HTML>
<html lang="en" class="dark" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data types - Rust for C-Programmers</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('dark')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../ch1/chapter_1_rust_for_c_programmers.html"><strong aria-hidden="true">1.</strong> Rust for C programmers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch1/1_1_why_rust.html"><strong aria-hidden="true">1.1.</strong> Why Rust</a></li><li class="chapter-item expanded "><a href="../ch1/1_2_what_makes_rust_special.html"><strong aria-hidden="true">1.2.</strong> What makes Rust special</a></li><li class="chapter-item expanded "><a href="../ch1/1_3_about_the_book.html"><strong aria-hidden="true">1.3.</strong> About the book</a></li><li class="chapter-item expanded "><a href="../ch1/1_4_about_the_authors.html"><strong aria-hidden="true">1.4.</strong> About the authors</a></li></ol></li><li class="chapter-item expanded "><a href="../ch2/chapter_2_the_basic_structure_of_a_rust_program.html"><strong aria-hidden="true">2.</strong> The basic tructure of a Rust program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch2/2_1_compiled_language_and_build_system.html"><strong aria-hidden="true">2.1.</strong> The build system</a></li><li class="chapter-item expanded "><a href="../ch2/2_2_the_main_function_entry_point_of_execution.html"><strong aria-hidden="true">2.2.</strong> The main function</a></li><li class="chapter-item expanded "><a href="../ch2/2_3_variables_and_mutability.html"><strong aria-hidden="true">2.3.</strong> Variables and mutability</a></li><li class="chapter-item expanded "><a href="../ch2/2_4_data_types_and_type_annotations.html"><strong aria-hidden="true">2.4.</strong> Data types</a></li><li class="chapter-item expanded "><a href="../ch2/2_5_constants_and_statics.html"><strong aria-hidden="true">2.5.</strong> Constants and statics</a></li><li class="chapter-item expanded "><a href="../ch2/2_6_functions_and_control_flow.html"><strong aria-hidden="true">2.6.</strong> Functions and control flow</a></li><li class="chapter-item expanded "><a href="../ch2/2_7_modules_and_crates.html"><strong aria-hidden="true">2.7.</strong> Modules and crates</a></li><li class="chapter-item expanded "><a href="../ch2/2_8_use_statements_and_namespacing.html"><strong aria-hidden="true">2.8.</strong> Use statements and namespacing</a></li><li class="chapter-item expanded "><a href="../ch2/2_9_traits_and_implementations.html"><strong aria-hidden="true">2.9.</strong> Traits and implementations</a></li><li class="chapter-item expanded "><a href="../ch2/2_10_macros.html"><strong aria-hidden="true">2.10.</strong> Macros</a></li><li class="chapter-item expanded "><a href="../ch2/2_11_error_handling.html"><strong aria-hidden="true">2.11.</strong> Error handling</a></li><li class="chapter-item expanded "><a href="../ch2/2_12_memory_safety_and_ownership.html"><strong aria-hidden="true">2.12.</strong> Memory safety and ownership</a></li><li class="chapter-item expanded "><a href="../ch2/2_13_syntax_structures_expressions_and_statements.html"><strong aria-hidden="true">2.13.</strong> Expressions_and_Statements</a></li><li class="chapter-item expanded "><a href="../ch2/2_14_code_conventions_and_style.html"><strong aria-hidden="true">2.14.</strong> Code conventions and style</a></li><li class="chapter-item expanded "><a href="../ch2/2_15_comments_and_documentation.html"><strong aria-hidden="true">2.15.</strong> Comments and documentation</a></li><li class="chapter-item expanded "><a href="../ch2/2_16_additional_topics.html"><strong aria-hidden="true">2.16.</strong> Additional topics</a></li><li class="chapter-item expanded "><a href="../ch2/2_17_summary.html"><strong aria-hidden="true">2.17.</strong> Summary</a></li><li class="chapter-item expanded "><a href="../ch2/2_18_closing_thoughts.html"><strong aria-hidden="true">2.18.</strong> Closing thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="../ch3/chapter_3_installing_rust.html"><strong aria-hidden="true">3.</strong> Installing Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch3/3_1_linux_users.html"><strong aria-hidden="true">3.1.</strong> For Linux users</a></li><li class="chapter-item expanded "><a href="../ch3/3_2_experimenting_with_rust_in_the_playground.html"><strong aria-hidden="true">3.2.</strong> Experimenting in the playground</a></li></ol></li><li class="chapter-item expanded "><a href="../ch4/chapter_4_rustc_and_cargo.html"><strong aria-hidden="true">4.</strong> Rustc and Cargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch4/4_1_compiling_with_rustc.html"><strong aria-hidden="true">4.1.</strong> Compiling with Rustc</a></li><li class="chapter-item expanded "><a href="../ch4/4_2_introduction_to_cargo.html"><strong aria-hidden="true">4.2.</strong> Introduction to Cargo</a></li><li class="chapter-item expanded "><a href="../ch4/4_3_further_resources.html"><strong aria-hidden="true">4.3.</strong> Further resources</a></li></ol></li><li class="chapter-item expanded "><a href="../ch5/chapter_5_common_programming_concepts.html"><strong aria-hidden="true">5.</strong> common_programming_concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch5/5_1_keywords.html"><strong aria-hidden="true">5.1.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="../ch5/5_2_expressions_and_statements.html"><strong aria-hidden="true">5.2.</strong> Expressions and statements</a></li><li class="chapter-item expanded "><a href="../ch5/5_3_data_types.html" class="active"><strong aria-hidden="true">5.3.</strong> Data types</a></li><li class="chapter-item expanded "><a href="../ch5/5_4_variables_and_mutability.html"><strong aria-hidden="true">5.4.</strong> Variables and mutability</a></li><li class="chapter-item expanded "><a href="../ch5/5_5_operators.html"><strong aria-hidden="true">5.5.</strong> Operators</a></li><li class="chapter-item expanded "><a href="../ch5/5_6_numeric_literals_and_their_default_type.html"><strong aria-hidden="true">5.6.</strong> Numeric literals and their type</a></li><li class="chapter-item expanded "><a href="../ch5/5_7_overflow_for_arithmetic_operations.html"><strong aria-hidden="true">5.7.</strong> Overflow for arithmetic operations</a></li><li class="chapter-item expanded "><a href="../ch5/5_8_performance_considerations_for_numeric_types.html"><strong aria-hidden="true">5.8.</strong> Performance for numeric types</a></li><li class="chapter-item expanded "><a href="../ch5/5_9_comments_in_rust.html"><strong aria-hidden="true">5.9.</strong> Comments in Rust</a></li><li class="chapter-item expanded "><a href="../ch5/5_10_summary.html"><strong aria-hidden="true">5.10.</strong> Summary</a></li><li class="chapter-item expanded "><a href="../ch5/5_11_closing_thoughts.html"><strong aria-hidden="true">5.11.</strong> Closing thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="../ch6/chapter_6_ownership_and_memory_management_in_rust.html"><strong aria-hidden="true">6.</strong> Ownership and memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch6/6_1_overview_of_ownership.html"><strong aria-hidden="true">6.1.</strong> Overview of ownership</a></li><li class="chapter-item expanded "><a href="../ch6/6_2_move_semantics_cloning_and_copying.html"><strong aria-hidden="true">6.2.</strong> Moves, cloning, and copying</a></li><li class="chapter-item expanded "><a href="../ch6/6_3_borrowing_and_references.html"><strong aria-hidden="true">6.3.</strong> Borrowing and references</a></li><li class="chapter-item expanded "><a href="../ch6/6_4_the_string_type_and_memory_allocation.html"><strong aria-hidden="true">6.4.</strong> The string type</a></li><li class="chapter-item expanded "><a href="../ch6/6_5_slices_borrowing_portions_of_data.html"><strong aria-hidden="true">6.5.</strong> Slices -- borrowing subranges</a></li><li class="chapter-item expanded "><a href="../ch6/6_6_lifetimes_ensuring_valid_references.html"><strong aria-hidden="true">6.6.</strong> Lifetimes of references</a></li><li class="chapter-item expanded "><a href="../ch6/6_7_smart_pointers_and_heap_allocation.html"><strong aria-hidden="true">6.7.</strong> Smart pointers</a></li><li class="chapter-item expanded "><a href="../ch6/6_8_unsafe_rust_and_interoperability_with_c.html"><strong aria-hidden="true">6.8.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="../ch6/6_9_comparison_with_c_memory_management.html"><strong aria-hidden="true">6.9.</strong> Comparison with C</a></li><li class="chapter-item expanded "><a href="../ch6/6_10_summary.html"><strong aria-hidden="true">6.10.</strong> Summary</a></li><li class="chapter-item expanded "><a href="../ch6/6_11_closing_thoughts.html"><strong aria-hidden="true">6.11.</strong> Closing thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="../ch7/chapter_7_control_flow_in_rust.html"><strong aria-hidden="true">7.</strong> Control flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch7/7_1_conditional_statements.html"><strong aria-hidden="true">7.1.</strong> Conditional statements</a></li><li class="chapter-item expanded "><a href="../ch7/7_2_loops.html"><strong aria-hidden="true">7.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="../ch7/7_3_key_differences_between_rust_and_c_control_flow.html"><strong aria-hidden="true">7.3.</strong> Control flow in Rust and C</a></li><li class="chapter-item expanded "><a href="../ch7/7_4_summary.html"><strong aria-hidden="true">7.4.</strong> Summary</a></li><li class="chapter-item expanded "><a href="../ch7/7_5_closing_thoughts.html"><strong aria-hidden="true">7.5.</strong> Closing_thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="../ch8/chapter_8_functions_in_rust.html"><strong aria-hidden="true">8.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch8/8_1_defining_and_calling_functions.html"><strong aria-hidden="true">8.1.</strong> Defining and calling functions</a></li><li class="chapter-item expanded "><a href="../ch8/8_2_the_main_function.html"><strong aria-hidden="true">8.2.</strong> The main function</a></li><li class="chapter-item expanded "><a href="../ch8/8_3_parameters_and_return_types.html"><strong aria-hidden="true">8.3.</strong> Parameters and return types</a></li><li class="chapter-item expanded "><a href="../ch8/8_4_default_parameter_values_and_named_arguments.html"><strong aria-hidden="true">8.4.</strong> Default and named arguments</a></li><li class="chapter-item expanded "><a href="../ch8/8_5_slices_as_parameters_and_return_types.html"><strong aria-hidden="true">8.5.</strong> Slices as parameters</a></li><li class="chapter-item expanded "><a href="../ch8/8_6_tuples_as_parameters_and_return_types.html"><strong aria-hidden="true">8.6.</strong> Tuples as parameters</a></li><li class="chapter-item expanded "><a href="../ch8/8_7_function_pointers_and_higher_order_functions.html"><strong aria-hidden="true">8.7.</strong> Function pointers</a></li><li class="chapter-item expanded "><a href="../ch8/8_8_nested_functions_and_scope.html"><strong aria-hidden="true">8.8.</strong> Nested functions and scope</a></li><li class="chapter-item expanded "><a href="../ch8/8_9_generics_in_functions.html"><strong aria-hidden="true">8.9.</strong> Generics in functions</a></li><li class="chapter-item expanded "><a href="../ch8/8_10_tail_call_optimization_and_recursion.html"><strong aria-hidden="true">8.10.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="../ch8/8_11_inlining_functions.html"><strong aria-hidden="true">8.11.</strong> Inlining functions</a></li><li class="chapter-item expanded "><a href="../ch8/8_12_method_syntax_and_associated_functions.html"><strong aria-hidden="true">8.12.</strong> Method call syntax</a></li><li class="chapter-item expanded "><a href="../ch8/8_13_function_overloading.html"><strong aria-hidden="true">8.13.</strong> Function overloading</a></li><li class="chapter-item expanded "><a href="../ch8/8_14_type_inference_for_function_return_types.html"><strong aria-hidden="true">8.14.</strong> Type inference for return types</a></li><li class="chapter-item expanded "><a href="../ch8/8_15_variadic_functions_and_macros.html"><strong aria-hidden="true">8.15.</strong> Variadic functions and macros</a></li><li class="chapter-item expanded "><a href="../ch8/8_16_summary.html"><strong aria-hidden="true">8.16.</strong> Summary</a></li><li class="chapter-item expanded "><a href="../ch8/8_17_exercises.html"><strong aria-hidden="true">8.17.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../ch8/8_18_closing_thoughts.html"><strong aria-hidden="true">8.18.</strong> Closing thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="../ch9/chapter_9_structs_in_rust.html"><strong aria-hidden="true">9.</strong> Structs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../ch9/9_1_defining_structs.html"><strong aria-hidden="true">9.1.</strong> Defining structs</a></li><li class="chapter-item expanded "><a href="../ch9/9_2_instantiating_and_using_structs.html"><strong aria-hidden="true">9.2.</strong> Instantiating structs</a></li><li class="chapter-item expanded "><a href="../ch9/9_3_updating_struct_instances.html"><strong aria-hidden="true">9.3.</strong> Updating struct instances</a></li><li class="chapter-item expanded "><a href="../ch9/9_4_tuple_structs.html"><strong aria-hidden="true">9.4.</strong> Tuple structs</a></li><li class="chapter-item expanded "><a href="../ch9/9_5_unit_like_structs.html"><strong aria-hidden="true">9.5.</strong> Unit like structs</a></li><li class="chapter-item expanded "><a href="../ch9/9_6_methods_and_associated_functions.html"><strong aria-hidden="true">9.6.</strong> Methods, associated functions</a></li><li class="chapter-item expanded "><a href="../ch9/9_7_the_self_parameter.html"><strong aria-hidden="true">9.7.</strong> The self parameter</a></li><li class="chapter-item expanded "><a href="../ch9/9_8_getters_and_setters.html"><strong aria-hidden="true">9.8.</strong> Getters and setters</a></li><li class="chapter-item expanded "><a href="../ch9/9_9_structs_and_ownership.html"><strong aria-hidden="true">9.9.</strong> Structs and ownership</a></li><li class="chapter-item expanded "><a href="../ch9/9_10_structs_with_references_and_lifetimes.html"><strong aria-hidden="true">9.10.</strong> References and lifetimes</a></li><li class="chapter-item expanded "><a href="../ch9/9_11_generic_structs.html"><strong aria-hidden="true">9.11.</strong> Generic structs</a></li><li class="chapter-item expanded "><a href="../ch9/9_12_comparing_rust_structs_with_oop_concepts.html"><strong aria-hidden="true">9.12.</strong> Rust structs  versus classes</a></li><li class="chapter-item expanded "><a href="../ch9/9_13_derived_traits.html"><strong aria-hidden="true">9.13.</strong> Derived traits</a></li><li class="chapter-item expanded "><a href="../ch9/9_14_additional_topics.html"><strong aria-hidden="true">9.14.</strong> Additional topics</a></li><li class="chapter-item expanded "><a href="../ch9/9_15_exercises.html"><strong aria-hidden="true">9.15.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="../ch9/9_16_.html"><strong aria-hidden="true">9.16.</strong> Summary</a></li><li class="chapter-item expanded "><a href="../ch9/9_17_closing_thoughts.html"><strong aria-hidden="true">9.17.</strong> Closing thoughts</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for C-Programmers</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="53-data-types"><a class="header" href="#53-data-types">5.3 Data Types</a></h2>
<p>Rust is a <strong>statically</strong> and <strong>strongly typed</strong> language, meaning that the type of each variable is known at compile time and cannot change. This ensures both <strong>performance</strong> and <strong>safety</strong>. In statically typed languages like Rust, many errors are caught early at compile time, reducing runtime errors that might otherwise occur in <strong>dynamically typed</strong> languages. Additionally, strong typing enforces that operations on data are well-defined, avoiding unexpected behavior from implicit type conversions common in <strong>weakly typed</strong> languages. These characteristics allow Rust to produce highly efficient machine code, with direct support for many of its types in primitive CPU instructions, leading to predictable performance, especially in systems programming.</p>
<h3 id="531-scalar-types"><a class="header" href="#531-scalar-types">5.3.1 Scalar Types</a></h3>
<p>Rust's <strong>scalar types</strong> are the simplest types, representing single values. They are analogous to the basic types in C, with some notable differences. Rust’s scalar types are categorized as integers, floating-point numbers, booleans, and characters. Here’s how they compare to C types:</p>
<h4 id="integers"><a class="header" href="#integers">Integers</a></h4>
<p>Rust offers a wide range of integer types, both signed and unsigned, similar to C but with stricter definitions of behavior. In C, integer sizes can sometimes be platform-dependent, whereas Rust defines its types clearly, ensuring predictable size and behavior across platforms.</p>
<p>For fixed-size integer types, Rust uses type names that specify both the size and whether the type is signed or unsigned. Signed types begin with <code>i</code>, while unsigned types begin with <code>u</code>, followed by the number of bits they occupy. The available integer types are:</p>
<ul>
<li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, and <code>i128</code> for signed integers (ranging from 8-bit to 128-bit).</li>
<li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, and <code>u128</code> for unsigned integers.</li>
</ul>
<p>By default, Rust uses the 32-bit signed integer type <code>i32</code> for integer literals if no specific type is annotated. This default strikes a balance between memory usage and performance for most use cases.</p>
<p><strong><code>usize</code> and <code>isize</code></strong>: Rust introduces two integer types that are specifically tied to the <strong>architecture</strong> of the machine. The <code>usize</code> type is an unsigned integer, and the <code>isize</code> type is a signed integer. These types are used in situations where the size of memory addresses is important, such as array indexing and pointer arithmetic. On a 64-bit system, <code>usize</code> and <code>isize</code> are 64 bits wide, while on a 32-bit system, they are 32 bits wide. The actual size is determined by the target architecture of the compiled program. These types are particularly useful in systems programming for tasks that involve memory management or when dealing with collections where the index size is architecture-dependent. Notably, <code>usize</code> is the default type for indexing arrays and other collections in Rust, and you cannot use other integer types like <code>i32</code> for indexing without an explicit cast.</p>
<h4 id="floating-point-numbers"><a class="header" href="#floating-point-numbers">Floating-Point Numbers</a></h4>
<p>Rust follows the IEEE 754 standard for floating-point types, similar to C, but ensures stricter error handling and precision guarantees. Rust also uses clear type names for its floating-point types, which specify the bit size:</p>
<ul>
<li><code>f32</code> for a 32-bit floating-point number.</li>
<li><code>f64</code> for a 64-bit floating-point number (the default).</li>
</ul>
<p>Rust defaults to <code>f64</code> (64-bit) for floating-point numbers, as it provides better precision and is generally optimized for performance on modern processors. The explicit naming of floating-point types helps avoid confusion and ensures consistent behavior across platforms.</p>
<h4 id="booleans-and-characters"><a class="header" href="#booleans-and-characters">Booleans and Characters</a></h4>
<ul>
<li>
<p><strong>Boolean (<code>bool</code>)</strong>: Rust’s boolean type (<code>bool</code>) is always 1 byte in size, even though it represents a value of <code>true</code> or <code>false</code>. While it might seem more efficient to represent a boolean as a single bit, modern CPUs generally operate more efficiently with byte-aligned memory. Using a full byte for a boolean simplifies memory access and allows for faster processing, particularly in situations where the boolean is stored in arrays or structs.</p>
</li>
<li>
<p><strong>Character (<code>char</code>)</strong>: The character type (<code>char</code>) in Rust represents a Unicode scalar value, differing from C’s <code>char</code>, which holds a single byte (ASCII or UTF-8). Rust’s <code>char</code> is 4 bytes, allowing for full Unicode support. This means it can represent characters from virtually any language, including emoji.</p>
</li>
</ul>
<h4 id="scalar-types-table"><a class="header" href="#scalar-types-table">Scalar Types Table</a></h4>
<div class="table-wrapper"><table><thead><tr><th><strong>Rust Type</strong></th><th><strong>Size</strong></th><th><strong>Range</strong></th><th><strong>Equivalent C Type</strong></th><th><strong>Comment</strong></th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>8 bits</td><td>-128 to 127</td><td><code>int8_t</code></td><td>Signed 8-bit integer</td></tr>
<tr><td><code>u8</code></td><td>8 bits</td><td>0 to 255</td><td><code>uint8_t</code></td><td>Unsigned 8-bit integer</td></tr>
<tr><td><code>i16</code></td><td>16 bits</td><td>-32,768 to 32,767</td><td><code>int16_t</code></td><td>Signed 16-bit integer</td></tr>
<tr><td><code>u16</code></td><td>16 bits</td><td>0 to 65,535</td><td><code>uint16_t</code></td><td>Unsigned 16-bit integer</td></tr>
<tr><td><code>i32</code></td><td>32 bits</td><td>-2,147,483,648 to 2,147,483,647</td><td><code>int32_t</code></td><td>Signed 32-bit integer (default integer type)</td></tr>
<tr><td><code>u32</code></td><td>32 bits</td><td>0 to 4,294,967,295</td><td><code>uint32_t</code></td><td>Unsigned 32-bit integer</td></tr>
<tr><td><code>i64</code></td><td>64 bits</td><td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td><td><code>int64_t</code></td><td>Signed 64-bit integer</td></tr>
<tr><td><code>u64</code></td><td>64 bits</td><td>0 to 18,446,744,073,709,551,615</td><td><code>uint64_t</code></td><td>Unsigned 64-bit integer</td></tr>
<tr><td><code>isize</code></td><td>Platform Dependent</td><td>Varies based on architecture (32-bit or 64-bit)</td><td><code>intptr_t</code></td><td>Signed pointer-sized integer</td></tr>
<tr><td><code>usize</code></td><td>Platform Dependent</td><td>Varies based on architecture (32-bit or 64-bit)</td><td><code>uintptr_t</code></td><td>Unsigned pointer-sized integer</td></tr>
<tr><td><code>f32</code></td><td>32 bits</td><td>~1.4E-45 to ~3.4E+38</td><td><code>float</code></td><td>32-bit floating point, IEEE 754</td></tr>
<tr><td><code>f64</code></td><td>64 bits</td><td>~5E-324 to ~1.8E+308</td><td><code>double</code></td><td>64-bit floating point (default)</td></tr>
<tr><td><code>bool</code></td><td>1 byte</td><td><code>true</code> or <code>false</code></td><td><code>_Bool</code></td><td>Boolean type, always 1 byte</td></tr>
<tr><td><code>char</code></td><td>4 bytes</td><td>Unicode scalar value (0 to 0x10FFFF)</td><td>None (C’s <code>char</code> is 1 byte)</td><td>Represents a Unicode character</td></tr>
</tbody></table>
</div>
<h3 id="532-primitive-compound-types-tuple-and-array"><a class="header" href="#532-primitive-compound-types-tuple-and-array">5.3.2 Primitive Compound Types: Tuple and Array</a></h3>
<p>Rust also provides <strong>compound types</strong>, which allow you to group multiple values into a single type. The two most basic compound types are <strong>tuples</strong> and <strong>arrays</strong>.</p>
<p>Note that "tuple" and "array" are not Rust keywords, meaning they can be used as variable names.</p>
<h3 id="tuple"><a class="header" href="#tuple">Tuple</a></h3>
<p>A <strong>tuple</strong> is a fixed-size collection of values of various types. In Rust, tuples are often used when you want to return multiple values from a function without using a struct. Since tuples may be unfamiliar to those coming from C or other languages that lack this data type, we will explore them in more detail.</p>
<h4 id="tuple-type-syntax"><a class="header" href="#tuple-type-syntax">Tuple Type Syntax</a></h4>
<p>In Rust, a tuple's type is defined by listing the types of its elements within parentheses <code>()</code>, separated by commas. This defines the exact types and the number of elements the tuple will hold.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">(i32, f64, char)</code></pre>
<p>This tuple type consists of three elements:</p>
<ul>
<li>An <code>i32</code> (32-bit signed integer)</li>
<li>An <code>f64</code> (64-bit floating-point number)</li>
<li>A <code>char</code> (Unicode scalar value)</li>
</ul>
<h4 id="tuple-value-syntax"><a class="header" href="#tuple-value-syntax">Tuple Value Syntax</a></h4>
<p>To create a tuple value, you use the same parentheses <code>()</code> and provide the actual values, again separated by commas.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">(500, 6.4, 'x')</code></pre>
<p>This creates a tuple value with:</p>
<ul>
<li>The integer <code>500</code></li>
<li>The floating-point number <code>6.4</code></li>
<li>The character <code>'x'</code></li>
</ul>
<p><strong>Note on Single-Element Tuples and the Unit Type:</strong></p>
<ul>
<li>
<p><strong>Singleton Tuples:</strong> To define a tuple with a single element, include a trailing comma to differentiate it from a value in parentheses.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let single_element_tuple = (5,); // A tuple containing one element
let not_a_tuple = (5);           // Just the value 5 in parentheses
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Unit Type <code>()</code></strong>: The unit type is a special tuple with zero elements, represented by <code>()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unit: () = (); // The unit type
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Functions that don't return a value actually return the unit type <code>()</code>.</li>
</ul>
</li>
</ul>
<h4 id="combining-type-annotation-and-value-assignment"><a class="header" href="#combining-type-annotation-and-value-assignment">Combining Type Annotation and Value Assignment</a></h4>
<p>When declaring a tuple variable with an explicit type and initializing it with values, you write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tuple: (i32, f64, char) = (500, 6.4, 'x');
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>let tuple:</code></strong> Declares a new variable named <code>tuple</code>.</li>
<li><strong><code>(i32, f64, char)</code></strong> Specifies the tuple's type.</li>
<li><strong><code>=</code></strong> Assigns the value to the variable.</li>
<li><strong><code>(500, 6.4, 'x')</code></strong> Provides the tuple's initial values.</li>
</ul>
<p>This line tells Rust to create a variable <code>tuple</code> that holds a tuple of type <code>(i32, f64, char)</code> initialized with the values <code>(500, 6.4, 'x')</code>. In this example, the tuple is initialized with constant values, but it is more common to use values evaluated at runtime.</p>
<h4 id="accessing-tuple-elements"><a class="header" href="#accessing-tuple-elements">Accessing Tuple Elements</a></h4>
<p>Accessing individual elements of a tuple is done using dot notation followed by the index of the element, starting from zero. However, tuples can <strong>only</strong> be indexed using <strong>constants known at compile time</strong>. You cannot dynamically loop over a tuple’s components by index because each element may be of a different type.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let tuple: (i32, f64, char) = (500, 6.4, 'x');
</span>let first_element = tuple.0; // Accesses the first element (500)
let second_element = tuple.1; // Accesses the second element (6.4)
let third_element = tuple.2; // Accesses the third element ('x')
<span class="boring">}</span></code></pre></pre>
<h4 id="mutability-and-assignment-of-tuple-elements"><a class="header" href="#mutability-and-assignment-of-tuple-elements">Mutability and Assignment of Tuple Elements</a></h4>
<p>By default, variables in Rust are immutable. If you want to modify the elements of a tuple after its creation, you need to declare it as mutable using the <code>mut</code> keyword.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut tuple = (500, 6.4, 'x');
tuple.0 = 600; // Changes the first element to 600
<span class="boring">}</span></code></pre></pre>
<p><strong>Important Notes:</strong></p>
<ul>
<li>
<p><strong>Fixed Size and Types:</strong> Tuples have a fixed size, and their types are known at compile time. You cannot add or remove elements once the tuple is created.</p>
</li>
<li>
<p><strong>Assignment at Creation:</strong> You must provide all the values for the tuple when you create it. You cannot declare an empty tuple and fill in its elements later.</p>
<p><strong>This will NOT work:</strong></p>
<pre><code class="language-rust ignore">// Attempting to declare an uninitialized tuple (Not allowed)
let mut tuple: (i32, f64, char);
tuple.0 = 500; // Error: tuple is not initialized</code></pre>
</li>
<li>
<p><strong>Assignment Step by Step:</strong> Rust does not allow assigning to individual tuple elements to build up the tuple after declaration without initial values.</p>
</li>
</ul>
<h4 id="destructuring-tuples"><a class="header" href="#destructuring-tuples">Destructuring Tuples</a></h4>
<p>It’s not possible to loop through a tuple’s elements by index, but you can unpack or "destructure" a tuple into individual variables for easier access.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let tuple: (i32, f64, char) = (500, 6.4, 'x');
</span>let (x, y, z) = tuple;
println!("x = {}, y = {}, z = {}", x, y, z);
<span class="boring">}</span></code></pre></pre>
<p>This assigns:</p>
<ul>
<li><code>x</code> to <code>tuple.0</code> (500)</li>
<li><code>y</code> to <code>tuple.1</code> (6.4)</li>
<li><code>z</code> to <code>tuple.2</code> ('x')</li>
</ul>
<h4 id="memory-layout-of-tuples"><a class="header" href="#memory-layout-of-tuples">Memory Layout of Tuples</a></h4>
<ul>
<li>Contiguous Memory: Tuples in Rust are stored contiguously in memory, meaning that all the elements of the tuple are laid out sequentially in a single block of memory.</li>
<li>Element Order: The elements are stored in the order they are defined in the tuple.</li>
<li>Alignment and Padding: Due to differing sizes and alignment requirements of the elements, there may be padding bytes inserted between elements to satisfy alignment constraints. This can lead to the tuple occupying more memory than the simple sum of the sizes of its elements.</li>
</ul>
<h4 id="tuples-in-functions"><a class="header" href="#tuples-in-functions">Tuples in Functions</a></h4>
<p>Tuples are often used to return multiple values from a function.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate(x: i32, y: i32) -&gt; (i32, i32) {
    (x + y, x * y)
}

let (sum, product) = calculate(5, 10);
println!("Sum = {}, Product = {}", sum, product);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The <code>calculate</code> function returns a tuple containing the sum and product of two numbers.</li>
<li>Destructuring is used to unpack the returned tuple.</li>
</ul>
<p>Functions will be covered in full detail in a later chapter.</p>
<h4 id="comparison-to-c"><a class="header" href="#comparison-to-c">Comparison to C</a></h4>
<p>In C, you might use <code>structs</code> to group different types together. However, structs in C require you to define a new type with named fields, whereas Rust's tuples are anonymous and access their elements by position.</p>
<p><strong>C Struct Example:</strong></p>
<pre><code class="language-c">struct Tuple {
    int a;
    double b;
    char c;
};

struct Tuple tuple = {500, 6.4, 'x'};
</code></pre>
<p>In C, you can assign to the fields individually after declaration because the struct has named fields.</p>
<p><strong>Rust Equivalent with Structs:</strong></p>
<p>If you need similar functionality in Rust (e.g., assigning values to fields individually), you might define a struct.</p>
<p><strong>Rust Struct Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TupleStruct {
    a: i32,
    b: f64,
    c: char,
}

let mut tuple = TupleStruct { a: 0, b: 0.0, c: '\0' };
tuple.a = 500;
tuple.b = 6.4;
tuple.c = 'x';
<span class="boring">}</span></code></pre></pre>
<p>We will cover the Rust struct type in greater detail in a later chapter.</p>
<h4 id="when-to-use-tuples-vs-structs"><a class="header" href="#when-to-use-tuples-vs-structs">When to Use Tuples vs. Structs</a></h4>
<ul>
<li>
<p><strong>Tuples:</strong> Best when you have a small, fixed set of elements with different types and you don't need to refer to the elements by name.</p>
</li>
<li>
<p><strong>Structs:</strong> Preferable when you need to:</p>
<ul>
<li>Assign or modify fields individually after creation.</li>
<li>Access elements by names for clarity.</li>
<li>Have more complex data structures.</li>
</ul>
</li>
</ul>
<h4 id="traits-implemented-by-tuples"><a class="header" href="#traits-implemented-by-tuples">Traits Implemented by Tuples</a></h4>
<p>Tuples implement several traits if their component types implement them. For example, if all elements implement the <code>Copy</code> trait, the tuple will also implement <code>Copy</code>.
This is useful when you need to copy tuples without moving ownership.</p>
<p>The next chapter will cover ownership, references, borrowing, and move semantics, while Rust's traits will be discussed later.</p>
<h4 id="summary"><a class="header" href="#summary">Summary</a></h4>
<ul>
<li>
<p><strong>Tuple Type Syntax:</strong> <code>(Type1, Type2, Type3)</code></p>
</li>
<li>
<p><strong>Tuple Value Syntax:</strong> <code>(value1, value2, value3)</code></p>
</li>
<li>
<p><strong>Declaration and Initialization:</strong> Must provide all elements at creation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tuple: (i32, f64, char) = (500, 6.4, 'x');
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Mutability:</strong> Use <code>mut</code> to make the tuple mutable if you need to modify its elements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut tuple = (500, 6.4, 'x');
tuple.0 = 600;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Accessing Elements:</strong> Use dot notation with the index.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut tuple = (500, 6.4, 'x');
</span>let value = tuple.1; // Accesses the second element
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Destructuring:</strong> Unpack the tuple into variables.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut tuple = (500, 6.4, 'x');
</span>let (a, b, c) = tuple;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Fixed Size and Types:</strong> Cannot change the size or types of a tuple after creation.</p>
</li>
</ul>
<h4 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h4>
<p>In Rust, tuples are a simple way to group a few values with different types.</p>
<h3 id="array"><a class="header" href="#array">Array</a></h3>
<p>An <strong>array</strong> in Rust is a fixed-size collection of elements of the same type, much like an array in C. Arrays are stored on the stack and are ideal when you know the size at compile time. Rust arrays are more strict than C arrays, enforcing bounds checking at runtime, which prevents out-of-bounds memory access, a common source of bugs in C.</p>
<h4 id="array-type-and-initialization-syntax"><a class="header" href="#array-type-and-initialization-syntax">Array Type and Initialization Syntax</a></h4>
<p>In Rust, you declare an array's type using square brackets <code>[]</code>, specifying the element type and the array's length.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-rust ignore">let array: [Type; Length] = [value1, value2, value3, ...];</code></pre>
<ul>
<li><strong><code>[Type; Length]</code></strong>: Specifies an array of elements of <code>Type</code> with a fixed <code>Length</code>.</li>
<li><strong><code>[value1, value2, value3, ...]</code></strong>: Provides the initial values for the array elements.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [i32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>[i32; 3]</code></strong>: An array of <code>i32</code> integers with 3 elements.</li>
<li><strong><code>[1, 2, 3]</code></strong>: Initializes the array with values <code>1</code>, <code>2</code>, and <code>3</code>.</li>
</ul>
<h4 id="arrays-with-arbitrary-values"><a class="header" href="#arrays-with-arbitrary-values">Arrays with Arbitrary Values</a></h4>
<p>In Rust, arrays can be initialized with values that are the result of expressions, not just literals or constants.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x * 2;
let array: [i32; 3] = [x, y, x + y];
<span class="boring">}</span></code></pre></pre>
<p>This demonstrates that you can use any valid expression to initialize the elements of an array, providing flexibility in how you construct arrays.</p>
<h4 id="initializing-arrays-with-default-values"><a class="header" href="#initializing-arrays-with-default-values">Initializing Arrays with Default Values</a></h4>
<p>You can initialize an array where all elements have the same value using the following syntax:</p>
<pre><code class="language-rust ignore">let array = [initial_value; array_length];</code></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let zeros = [0; 5]; // Creates an array [0, 0, 0, 0, 0]
<span class="boring">}</span></code></pre></pre>
<p>This is particularly useful when you need an array filled with a default value.</p>
<h4 id="type-inference-and-initialization"><a class="header" href="#type-inference-and-initialization">Type Inference and Initialization</a></h4>
<p>Rust often allows you to omit the type annotation if it can infer the type from the context.</p>
<p><strong>Example with Type Inference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Rust infers that <code>array</code> is of type <code>[i32; 3]</code> because all elements are <code>i32</code> literals and there are three of them.</li>
</ul>
<p>Alternatively, you could use type inference in combination with an explicit type for one of the elements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1u8, 2, 3];
<span class="boring">}</span></code></pre></pre>
<h4 id="accessing-array-elements"><a class="header" href="#accessing-array-elements">Accessing Array Elements</a></h4>
<p>To access elements of an array, you use indexing using square brackets <code>[]</code> with the index of the element, starting from zero. Arrays can be indexed by either <strong>compile-time constants</strong> or <strong>runtime-evaluated values</strong>, as long as the index is of type <code>usize</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [i32; 3] = [1, 2, 3];
let index = 1;
let second = array[index];
println!("Second element is {}", second);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Indexing starts at <code>0</code>, as in C.</li>
<li>Indices must be of type <code>usize</code>.</li>
</ul>
<h4 id="bounds-checking"><a class="header" href="#bounds-checking">Bounds Checking</a></h4>
<p>Unlike C, Rust performs <strong>runtime bounds checking</strong> on array accesses. If you attempt to access an index outside the array's bounds, Rust will panic and safely abort the program, preventing undefined behavior.</p>
<p><strong>Example of Out-of-Bounds Access:</strong></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
let i = 3; // Content of variable i is evaluated at runtime
let invalid = array[i]; // Panics at runtime: index out of bounds
<span class="boring">}</span></code></pre></pre>
<p>To safely handle potential out-of-bounds access, you can use the <code>get</code> method, which returns an <code>Option&lt;&amp;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(value) = array.get(3) {
    println!("Value: {}", value);
} else {
    println!("Index out of bounds");
}
<span class="boring">}</span></code></pre></pre>
<h4 id="iterating-over-arrays"><a class="header" href="#iterating-over-arrays">Iterating Over Arrays</a></h4>
<p>You can iterate over arrays using loops.</p>
<p><strong>Using a <code>for</code> Loop:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];

for element in array.iter() {
    println!("Element: {}", element);
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>array.iter()</code></strong>: Returns an iterator over the array's elements.</li>
</ul>
<p><strong>Using Indices:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let array = [1, 2, 3];
</span>for i in 0..array.len() {
    println!("Element {}: {}", i, array[i]);
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>0..array.len()</code></strong>: Creates a range from <code>0</code> up to (but not including) <code>array.len()</code>.</li>
<li><strong><code>array.len()</code></strong>: Returns the number of elements in the array.</li>
</ul>
<h4 id="memory-layout-of-arrays"><a class="header" href="#memory-layout-of-arrays">Memory Layout of Arrays</a></h4>
<ul>
<li>Homogeneous Elements: Arrays contain elements of the same type, size, and alignment.</li>
<li>Contiguous Memory: Stored in a single contiguous block without padding between elements (since all elements have the same alignment).</li>
<li>Predictable Layout: Memory layout is straightforward because each element follows the previous one without any padding.</li>
</ul>
<h4 id="arrays-in-functions"><a class="header" href="#arrays-in-functions">Arrays in Functions</a></h4>
<p>Arrays can be passed to functions, but since the size is part of the array's type, it's often more flexible to use slices.</p>
<p><strong>Example Using a Slice:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum(array: &amp;[i32]) -&gt; i32 {
    array.iter().sum()
}

let array = [1, 2, 3];
let total = sum(&amp;array);
println!("Total sum is {}", total);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Slices allow functions to accept arrays of any size, as long as the element type matches.</li>
</ul>
<h4 id="slices"><a class="header" href="#slices">Slices</a></h4>
<p>A <strong>slice</strong> is a view into a block of memory represented as a pointer and a length. Slices can be used to reference a portion of an array or vector.</p>
<p><strong>Example of Creating a Slice from an Array:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3, 4, 5];
let slice = &amp;array[1..4]; // Slice containing elements [2, 3, 4]
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Slices are similar to pointers in C but include length information, enhancing safety.</li>
</ul>
<p>Slices and the use of the ampersand (<code>&amp;</code>) to denote references will be explored in greater detail in the next chapter of the book.</p>
<h4 id="mutable-arrays"><a class="header" href="#mutable-arrays">Mutable Arrays</a></h4>
<p>By default, variables in Rust are immutable. To modify the contents of an array, declare it as mutable using the <code>mut</code> keyword.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut array = [1, 2, 3];
array[0] = 10; // Now array is [10, 2, 3]
<span class="boring">}</span></code></pre></pre>
<h4 id="arrays-with-const-length"><a class="header" href="#arrays-with-const-length">Arrays with <code>const</code> Length</a></h4>
<p>The length of an array in Rust must be a constant value known at compile time.</p>
<p><strong>Example with Constant Length:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SIZE: usize = 3;
let array: [i32; SIZE] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<h4 id="multidimensional-arrays"><a class="header" href="#multidimensional-arrays">Multidimensional Arrays</a></h4>
<p>Rust supports multidimensional arrays by nesting arrays within arrays.</p>
<p><strong>Example of a 2D Array:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let matrix: [[i32; 3]; 2] = [
    [1, 2, 3],
    [4, 5, 6],
];
<span class="boring">}</span></code></pre></pre>
<ul>
<li>This creates a 2x3 matrix (2 rows, 3 columns).</li>
</ul>
<h4 id="traits-implemented-by-arrays"><a class="header" href="#traits-implemented-by-arrays">Traits Implemented by Arrays</a></h4>
<p>Arrays implement several traits if their element types implement them. For example, if the elements implement <code>Copy</code>, the array will also implement <code>Copy</code>.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn duplicate(array: [i32; 3]) -&gt; [i32; 3] {
    array // Copies the array because i32 implements Copy
}
<span class="boring">}</span></code></pre></pre>
<p>This allows arrays to be copied by value, similar to how structs can derive the <code>Copy</code> trait.</p>
<h4 id="comparing-rust-and-c-arrays"><a class="header" href="#comparing-rust-and-c-arrays">Comparing Rust and C Arrays</a></h4>
<ul>
<li><strong>Fixed Size:</strong> Both Rust and C arrays have a fixed size known at compile time.</li>
<li><strong>Type Safety:</strong> Rust arrays are type-safe; all elements must be of the same type.</li>
<li><strong>Bounds Checking:</strong> Rust performs bounds checking at runtime, preventing out-of-bounds memory access—a common issue in C.</li>
<li><strong>Memory Location:</strong> Rust arrays are stored on the stack by default.</li>
<li><strong>Slices:</strong> Rust introduces slices for safe and flexible array access, which is not directly available in C.</li>
</ul>
<h4 id="other-initialization-methods"><a class="header" href="#other-initialization-methods">Other Initialization Methods</a></h4>
<p><strong>Initializing Arrays Without Specifying All Elements:</strong></p>
<p>In Rust, you must initialize all elements of an array. Unlike in C, where uninitialized elements might be set to zero or garbage values, Rust requires explicit initialization.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [i32; 5] = [1, 2, 3, 0, 0];
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Manually specify default values for unspecified elements.</li>
</ul>
<h4 id="summary-1"><a class="header" href="#summary-1">Summary</a></h4>
<ul>
<li><strong>Declaration Syntax:</strong> <code>let array: [Type; Length] = [values];</code></li>
<li><strong>Type Inference:</strong> Rust can infer the type and length based on the values provided.</li>
<li><strong>Initialization with Default Values:</strong> <code>let array = [initial_value; array_length];</code></li>
<li><strong>Accessing Elements:</strong> Use <code>array[index]</code>, where <code>index</code> is of type <code>usize</code>.</li>
<li><strong>Mutability:</strong> Declare with <code>mut</code> if you need to modify elements after creation.</li>
<li><strong>Bounds Checking:</strong> Rust checks array bounds at runtime to prevent invalid access.</li>
<li><strong>Iteration:</strong> Use loops to iterate over elements or indices.</li>
<li><strong>Slices:</strong> Use slices for flexible and safe access to arrays.</li>
</ul>
<h4 id="when-to-use-tuples-arrays-and-vectors"><a class="header" href="#when-to-use-tuples-arrays-and-vectors">When to Use Tuples, Arrays, and Vectors</a></h4>
<p>Rust provides <strong>tuples</strong>, <strong>arrays</strong>, and <strong>vectors</strong> to group multiple values, each serving distinct purposes:</p>
<ul>
<li>
<p><strong>Tuples</strong>: Fixed-size collections that can hold elements of different types. Ideal for grouping a small, fixed number of related values where each position has a specific meaning.</p>
</li>
<li>
<p><strong>Arrays</strong>: Fixed-size collections of elements of the same type. Suitable for handling a known number of homogeneous items, allowing efficient indexed access and iteration.</p>
</li>
<li>
<p><strong>Vectors (<code>Vec&lt;T&gt;</code>)</strong>: Growable arrays stored on the heap. Use when you need a collection of elements of the same type, but the size can change at runtime.</p>
</li>
</ul>
<p><strong>Key Differences:</strong></p>
<ul>
<li>
<p><strong>Homogeneity</strong>:</p>
<ul>
<li><em>Tuples</em>: Heterogeneous elements (different types).</li>
<li><em>Arrays and Vectors</em>: Homogeneous elements (same type).</li>
</ul>
</li>
<li>
<p><strong>Size</strong>:</p>
<ul>
<li><em>Tuples and Arrays</em>: Fixed size known at compile time.</li>
<li><em>Vectors</em>: Dynamic size that can grow or shrink at runtime.</li>
</ul>
</li>
<li>
<p><strong>Usage Scenarios</strong>:</p>
<ul>
<li><em>Tuples</em>: Grouping related values with different types or meanings, like coordinates <code>(x, y)</code>.</li>
<li><em>Arrays</em>: Collections of fixed-size homogeneous data, like days in a week.</li>
<li><em>Vectors</em>: Collections where the number of elements isn't known at compile time or can change, like lines read from a file.</li>
</ul>
</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li>
<p><strong>Tuple</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point = (10.0, 20.0); // x and y coordinates
let (x, y) = point;       // Destructure into variables
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Array</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let weekdays = ["Mon", "Tue", "Wed", "Thu", "Fri"];
for day in weekdays.iter() {
    println!("{}", day);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Vector</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = vec![1, 2, 3];
numbers.push(4); // Now numbers is [1, 2, 3, 4]
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p><strong>Choosing the Right Type:</strong></p>
<ul>
<li>Use <strong>tuples</strong> when you have a small, fixed set of values with possibly different types or meanings.</li>
<li>Use <strong>arrays</strong> when you have a fixed-size collection of the same type and need efficient access or iteration.</li>
<li>Use <strong>vectors</strong> when dealing with a collection that can change in size.</li>
</ul>
<h4 id="tuples-or-arrays-as-function-return-types"><a class="header" href="#tuples-or-arrays-as-function-return-types">Tuples or Arrays as Function Return Types</a></h4>
<p>When a function needs to return multiple values, the choice between tuples and arrays depends on the nature of the data:</p>
<ul>
<li>
<p><strong>Tuples</strong> are preferable when:</p>
<ul>
<li>Returning a fixed number of values with distinct meanings.</li>
<li>Each value may represent a different concept, even if they're the same type.</li>
<li>You want to leverage destructuring for clarity.</li>
</ul>
<p><strong>Example: Returning Coordinates</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_coordinates() -&gt; (f64, f64) {
    (10.0, 20.0)
}

let (x, y) = get_coordinates();
println!("x = {}, y = {}", x, y);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Arrays</strong> are suitable when:</p>
<ul>
<li>Returning a fixed-size collection of homogeneous values.</li>
<li>The elements represent the same kind of data.</li>
<li>You might need to iterate over the elements.</li>
</ul>
<p><strong>Example: Returning a Row of Data</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_row() -&gt; [i32; 3] {
    [1, 2, 3]
}

let row = get_row();
for value in row.iter() {
    println!("{}", value);
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p><strong>Why Choose Tuples for Coordinates:</strong></p>
<ul>
<li><strong>Semantic Clarity</strong>: Destructuring tuples into variables like <code>x</code> and <code>y</code> makes the code more readable and self-explanatory.</li>
<li><strong>Distinct Meanings</strong>: Even if <code>x</code> and <code>y</code> are the same type, they represent different dimensions.</li>
</ul>
<p><strong>Alternative with Structs:</strong></p>
<p>For enhanced clarity and scalability, especially with more complex data, consider using a <code>struct</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Coordinates {
    x: f64,
    y: f64,
}

fn get_coordinates() -&gt; Coordinates {
    Coordinates { x: 10.0, y: 20.0 }
}

let coords = get_coordinates();
println!("x = {}, y = {}", coords.x, coords.y);
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Advantages</strong>:
<ul>
<li><strong>Named Fields</strong>: Clearly indicate what each value represents.</li>
<li><strong>Extensibility</strong>: Easy to add more fields (e.g., <code>z</code> for 3D coordinates).</li>
<li><strong>Methods</strong>: Ability to implement associated functions or methods.</li>
</ul>
</li>
</ul>
<p><strong>Summary:</strong></p>
<ul>
<li><strong>Use Tuples</strong> when returning multiple values with different meanings or when you want to unpack values into variables with meaningful names.</li>
<li><strong>Use Arrays</strong> when returning a collection of similar items that might be processed collectively.</li>
<li><strong>Use Structs</strong> for even greater clarity and when you might need to expand functionality.</li>
</ul>
<p><strong>Final Recommendation:</strong></p>
<ul>
<li>For returning pairs like coordinates, <strong>tuples</strong> offer a good balance between simplicity and clarity.</li>
<li>For collections of homogeneous data where iteration is needed, <strong>arrays</strong> (or <strong>vectors</strong> if the size is dynamic) are more appropriate.</li>
</ul>
<p>By choosing the most suitable data structure, you enhance code readability, maintainability, and safety, aligning with Rust's emphasis on clarity and reliability.</p>
<blockquote>
<p><strong>Note:</strong> Using very large arrays can cause a stack overflow, as the default stack size is usually limited to a few megabytes and varies depending on the operating system. For large collections, consider using a vector (<code>Vec&lt;T&gt;</code>) instead.</p>
</blockquote>
<h3 id="stack-vs-heap-allocation"><a class="header" href="#stack-vs-heap-allocation">Stack vs. Heap Allocation</a></h3>
<p>Rust's primitive types—scalars, tuples, and arrays—are typically <strong>stack-allocated</strong>, providing fast access due to their predictability and locality. Rust takes advantage of <strong>direct CPU support</strong> for many of these primitive types, optimizing them for performance.</p>
<p>On the other hand, <strong>dynamic types</strong> like vectors (<code>Vec&lt;T&gt;</code>) and dynamically sized strings (<code>String</code>) use <strong>heap allocation</strong> to store their data, allowing for flexible and dynamic resizing at runtime. This heap allocation introduces overhead but is necessary for handling collections of unknown size at compile time.</p>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../ch5/5_2_expressions_and_statements.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../ch5/5_4_variables_and_mutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../ch5/5_2_expressions_and_statements.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../ch5/5_4_variables_and_mutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
