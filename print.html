<!DOCTYPE HTML>
<html lang="en" class="dark" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust for C-Programmers</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('dark')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ch1/chapter_1_rust_for_c_programmers.html"><strong aria-hidden="true">1.</strong> Rust for C programmers</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1/1_1_why_rust.html"><strong aria-hidden="true">1.1.</strong> Why Rust</a></li><li class="chapter-item expanded "><a href="ch1/1_2_what_makes_rust_special.html"><strong aria-hidden="true">1.2.</strong> What makes Rust special</a></li><li class="chapter-item expanded "><a href="ch1/1_3_about_the_book.html"><strong aria-hidden="true">1.3.</strong> About the book</a></li><li class="chapter-item expanded "><a href="ch1/1_4_about_the_authors.html"><strong aria-hidden="true">1.4.</strong> About the authors</a></li></ol></li><li class="chapter-item expanded "><a href="ch2/chapter_2_the_basic_structure_of_a_rust_program.html"><strong aria-hidden="true">2.</strong> The basic tructure of a Rust program</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2/2_1_compiled_language_and_build_system.html"><strong aria-hidden="true">2.1.</strong> The build system</a></li><li class="chapter-item expanded "><a href="ch2/2_2_the_main_function_entry_point_of_execution.html"><strong aria-hidden="true">2.2.</strong> The main function</a></li><li class="chapter-item expanded "><a href="ch2/2_3_variables_and_mutability.html"><strong aria-hidden="true">2.3.</strong> Variables and mutability</a></li><li class="chapter-item expanded "><a href="ch2/2_4_data_types_and_type_annotations.html"><strong aria-hidden="true">2.4.</strong> Data types</a></li><li class="chapter-item expanded "><a href="ch2/2_5_constants_and_statics.html"><strong aria-hidden="true">2.5.</strong> Constants and statics</a></li><li class="chapter-item expanded "><a href="ch2/2_6_functions_and_control_flow.html"><strong aria-hidden="true">2.6.</strong> Functions and control flow</a></li><li class="chapter-item expanded "><a href="ch2/2_7_modules_and_crates.html"><strong aria-hidden="true">2.7.</strong> Modules and crates</a></li><li class="chapter-item expanded "><a href="ch2/2_8_use_statements_and_namespacing.html"><strong aria-hidden="true">2.8.</strong> Use statements and namespacing</a></li><li class="chapter-item expanded "><a href="ch2/2_9_traits_and_implementations.html"><strong aria-hidden="true">2.9.</strong> Traits and implementations</a></li><li class="chapter-item expanded "><a href="ch2/2_10_macros.html"><strong aria-hidden="true">2.10.</strong> Macros</a></li><li class="chapter-item expanded "><a href="ch2/2_11_error_handling.html"><strong aria-hidden="true">2.11.</strong> Error handling</a></li><li class="chapter-item expanded "><a href="ch2/2_12_memory_safety_and_ownership.html"><strong aria-hidden="true">2.12.</strong> Memory safety and ownership</a></li><li class="chapter-item expanded "><a href="ch2/2_13_syntax_structures_expressions_and_statements.html"><strong aria-hidden="true">2.13.</strong> Expressions_and_Statements</a></li><li class="chapter-item expanded "><a href="ch2/2_14_code_conventions_and_style.html"><strong aria-hidden="true">2.14.</strong> Code conventions and style</a></li><li class="chapter-item expanded "><a href="ch2/2_15_comments_and_documentation.html"><strong aria-hidden="true">2.15.</strong> Comments and documentation</a></li><li class="chapter-item expanded "><a href="ch2/2_16_additional_topics.html"><strong aria-hidden="true">2.16.</strong> Additional topics</a></li><li class="chapter-item expanded "><a href="ch2/2_17_summary.html"><strong aria-hidden="true">2.17.</strong> Summary</a></li><li class="chapter-item expanded "><a href="ch2/2_18_closing_thoughts.html"><strong aria-hidden="true">2.18.</strong> Closing thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="ch3/chapter_3_installing_rust.html"><strong aria-hidden="true">3.</strong> Installing Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch3/3_1_linux_users.html"><strong aria-hidden="true">3.1.</strong> For Linux users</a></li><li class="chapter-item expanded "><a href="ch3/3_2_experimenting_with_rust_in_the_playground.html"><strong aria-hidden="true">3.2.</strong> Experimenting in the playground</a></li></ol></li><li class="chapter-item expanded "><a href="ch4/chapter_4_rustc_and_cargo.html"><strong aria-hidden="true">4.</strong> Rustc and Cargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch4/4_1_compiling_with_rustc.html"><strong aria-hidden="true">4.1.</strong> Compiling with Rustc</a></li><li class="chapter-item expanded "><a href="ch4/4_2_introduction_to_cargo.html"><strong aria-hidden="true">4.2.</strong> Introduction to Cargo</a></li><li class="chapter-item expanded "><a href="ch4/4_3_further_resources.html"><strong aria-hidden="true">4.3.</strong> Further resources</a></li></ol></li><li class="chapter-item expanded "><a href="ch5/chapter_5_common_programming_concepts.html"><strong aria-hidden="true">5.</strong> common_programming_concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch5/5_1_keywords.html"><strong aria-hidden="true">5.1.</strong> Keywords</a></li><li class="chapter-item expanded "><a href="ch5/5_2_expressions_and_statements.html"><strong aria-hidden="true">5.2.</strong> Expressions and statements</a></li><li class="chapter-item expanded "><a href="ch5/5_3_data_types.html"><strong aria-hidden="true">5.3.</strong> Data types</a></li><li class="chapter-item expanded "><a href="ch5/5_4_variables_and_mutability.html"><strong aria-hidden="true">5.4.</strong> Variables and mutability</a></li><li class="chapter-item expanded "><a href="ch5/5_5_operators.html"><strong aria-hidden="true">5.5.</strong> Operators</a></li><li class="chapter-item expanded "><a href="ch5/5_6_numeric_literals_and_their_default_type.html"><strong aria-hidden="true">5.6.</strong> Numeric literals and their type</a></li><li class="chapter-item expanded "><a href="ch5/5_7_overflow_for_arithmetic_operations.html"><strong aria-hidden="true">5.7.</strong> Overflow for arithmetic operations</a></li><li class="chapter-item expanded "><a href="ch5/5_8_performance_considerations_for_numeric_types.html"><strong aria-hidden="true">5.8.</strong> Performance for numeric types</a></li><li class="chapter-item expanded "><a href="ch5/5_9_comments_in_rust.html"><strong aria-hidden="true">5.9.</strong> Comments in Rust</a></li><li class="chapter-item expanded "><a href="ch5/5_10_summary.html"><strong aria-hidden="true">5.10.</strong> Summary</a></li><li class="chapter-item expanded "><a href="ch5/5_11_closing_thoughts.html"><strong aria-hidden="true">5.11.</strong> Closing thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="ch6/chapter_6_ownership_and_memory_management_in_rust.html"><strong aria-hidden="true">6.</strong> Ownership and memory management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch6/6_1_overview_of_ownership.html"><strong aria-hidden="true">6.1.</strong> Overview of ownership</a></li><li class="chapter-item expanded "><a href="ch6/6_2_move_semantics_cloning_and_copying.html"><strong aria-hidden="true">6.2.</strong> Moves, cloning, and copying</a></li><li class="chapter-item expanded "><a href="ch6/6_3_borrowing_and_references.html"><strong aria-hidden="true">6.3.</strong> Borrowing and references</a></li><li class="chapter-item expanded "><a href="ch6/6_4_the_string_type_and_memory_allocation.html"><strong aria-hidden="true">6.4.</strong> The string type</a></li><li class="chapter-item expanded "><a href="ch6/6_5_slices_borrowing_portions_of_data.html"><strong aria-hidden="true">6.5.</strong> Slices -- borrowing subranges</a></li><li class="chapter-item expanded "><a href="ch6/6_6_lifetimes_ensuring_valid_references.html"><strong aria-hidden="true">6.6.</strong> Lifetimes of references</a></li><li class="chapter-item expanded "><a href="ch6/6_7_smart_pointers_and_heap_allocation.html"><strong aria-hidden="true">6.7.</strong> Smart pointers</a></li><li class="chapter-item expanded "><a href="ch6/6_8_unsafe_rust_and_interoperability_with_c.html"><strong aria-hidden="true">6.8.</strong> Unsafe Rust</a></li><li class="chapter-item expanded "><a href="ch6/6_9_comparison_with_c_memory_management.html"><strong aria-hidden="true">6.9.</strong> Comparison with C</a></li><li class="chapter-item expanded "><a href="ch6/6_10_summary.html"><strong aria-hidden="true">6.10.</strong> Summary</a></li><li class="chapter-item expanded "><a href="ch6/6_11_closing_thoughts.html"><strong aria-hidden="true">6.11.</strong> Closing thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="ch7/chapter_7_control_flow_in_rust.html"><strong aria-hidden="true">7.</strong> Control flow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch7/7_1_conditional_statements.html"><strong aria-hidden="true">7.1.</strong> Conditional statements</a></li><li class="chapter-item expanded "><a href="ch7/7_2_loops.html"><strong aria-hidden="true">7.2.</strong> Loops</a></li><li class="chapter-item expanded "><a href="ch7/7_3_key_differences_between_rust_and_c_control_flow.html"><strong aria-hidden="true">7.3.</strong> Control flow in Rust and C</a></li><li class="chapter-item expanded "><a href="ch7/7_4_summary.html"><strong aria-hidden="true">7.4.</strong> Summary</a></li><li class="chapter-item expanded "><a href="ch7/7_5_closing_thoughts.html"><strong aria-hidden="true">7.5.</strong> Closing_thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="ch8/chapter_8_functions_in_rust.html"><strong aria-hidden="true">8.</strong> Functions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch8/8_1_defining_and_calling_functions.html"><strong aria-hidden="true">8.1.</strong> Defining and calling functions</a></li><li class="chapter-item expanded "><a href="ch8/8_2_the_main_function.html"><strong aria-hidden="true">8.2.</strong> The main function</a></li><li class="chapter-item expanded "><a href="ch8/8_3_parameters_and_return_types.html"><strong aria-hidden="true">8.3.</strong> Parameters and return types</a></li><li class="chapter-item expanded "><a href="ch8/8_4_default_parameter_values_and_named_arguments.html"><strong aria-hidden="true">8.4.</strong> Default and named arguments</a></li><li class="chapter-item expanded "><a href="ch8/8_5_slices_as_parameters_and_return_types.html"><strong aria-hidden="true">8.5.</strong> Slices as parameters</a></li><li class="chapter-item expanded "><a href="ch8/8_6_tuples_as_parameters_and_return_types.html"><strong aria-hidden="true">8.6.</strong> Tuples as parameters</a></li><li class="chapter-item expanded "><a href="ch8/8_7_function_pointers_and_higher_order_functions.html"><strong aria-hidden="true">8.7.</strong> Function pointers</a></li><li class="chapter-item expanded "><a href="ch8/8_8_nested_functions_and_scope.html"><strong aria-hidden="true">8.8.</strong> Nested functions and scope</a></li><li class="chapter-item expanded "><a href="ch8/8_9_generics_in_functions.html"><strong aria-hidden="true">8.9.</strong> Generics in functions</a></li><li class="chapter-item expanded "><a href="ch8/8_10_tail_call_optimization_and_recursion.html"><strong aria-hidden="true">8.10.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch8/8_11_inlining_functions.html"><strong aria-hidden="true">8.11.</strong> Inlining functions</a></li><li class="chapter-item expanded "><a href="ch8/8_12_method_syntax_and_associated_functions.html"><strong aria-hidden="true">8.12.</strong> Method call syntax</a></li><li class="chapter-item expanded "><a href="ch8/8_13_function_overloading.html"><strong aria-hidden="true">8.13.</strong> Function overloading</a></li><li class="chapter-item expanded "><a href="ch8/8_14_type_inference_for_function_return_types.html"><strong aria-hidden="true">8.14.</strong> Type inference for return types</a></li><li class="chapter-item expanded "><a href="ch8/8_15_variadic_functions_and_macros.html"><strong aria-hidden="true">8.15.</strong> Variadic functions and macros</a></li><li class="chapter-item expanded "><a href="ch8/8_16_summary.html"><strong aria-hidden="true">8.16.</strong> Summary</a></li><li class="chapter-item expanded "><a href="ch8/8_17_exercises.html"><strong aria-hidden="true">8.17.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch8/8_18_closing_thoughts.html"><strong aria-hidden="true">8.18.</strong> Closing thoughts</a></li></ol></li><li class="chapter-item expanded "><a href="ch9/chapter_9_structs_in_rust.html"><strong aria-hidden="true">9.</strong> Structs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch9/9_1_defining_structs.html"><strong aria-hidden="true">9.1.</strong> Defining structs</a></li><li class="chapter-item expanded "><a href="ch9/9_2_instantiating_and_using_structs.html"><strong aria-hidden="true">9.2.</strong> Instantiating structs</a></li><li class="chapter-item expanded "><a href="ch9/9_3_updating_struct_instances.html"><strong aria-hidden="true">9.3.</strong> Updating struct instances</a></li><li class="chapter-item expanded "><a href="ch9/9_4_tuple_structs.html"><strong aria-hidden="true">9.4.</strong> Tuple structs</a></li><li class="chapter-item expanded "><a href="ch9/9_5_unit_like_structs.html"><strong aria-hidden="true">9.5.</strong> Unit like structs</a></li><li class="chapter-item expanded "><a href="ch9/9_6_methods_and_associated_functions.html"><strong aria-hidden="true">9.6.</strong> Methods, associated functions</a></li><li class="chapter-item expanded "><a href="ch9/9_7_the_self_parameter.html"><strong aria-hidden="true">9.7.</strong> The self parameter</a></li><li class="chapter-item expanded "><a href="ch9/9_8_getters_and_setters.html"><strong aria-hidden="true">9.8.</strong> Getters and setters</a></li><li class="chapter-item expanded "><a href="ch9/9_9_structs_and_ownership.html"><strong aria-hidden="true">9.9.</strong> Structs and ownership</a></li><li class="chapter-item expanded "><a href="ch9/9_10_structs_with_references_and_lifetimes.html"><strong aria-hidden="true">9.10.</strong> References and lifetimes</a></li><li class="chapter-item expanded "><a href="ch9/9_11_generic_structs.html"><strong aria-hidden="true">9.11.</strong> Generic structs</a></li><li class="chapter-item expanded "><a href="ch9/9_12_comparing_rust_structs_with_oop_concepts.html"><strong aria-hidden="true">9.12.</strong> Rust structs  versus classes</a></li><li class="chapter-item expanded "><a href="ch9/9_13_derived_traits.html"><strong aria-hidden="true">9.13.</strong> Derived traits</a></li><li class="chapter-item expanded "><a href="ch9/9_14_additional_topics.html"><strong aria-hidden="true">9.14.</strong> Additional topics</a></li><li class="chapter-item expanded "><a href="ch9/9_15_exercises.html"><strong aria-hidden="true">9.15.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch9/9_16_.html"><strong aria-hidden="true">9.16.</strong> Summary</a></li><li class="chapter-item expanded "><a href="ch9/9_17_closing_thoughts.html"><strong aria-hidden="true">9.17.</strong> Closing thoughts</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust for C-Programmers</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-for-c-programmers"><a class="header" href="#rust-for-c-programmers">Rust for C-Programmers</a></h1>
<h3 id="a-compact-introduction-to-the-rust-programming-language"><a class="header" href="#a-compact-introduction-to-the-rust-programming-language">A Compact Introduction to the Rust Programming Language</a></h3>
<p>Early preprint, created in 2024</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="11-why-rust"><a class="header" href="#11-why-rust">1.1 Why Rust?</a></h2>
<p>Rust is a modern programming language that uniquely combines high performance with safety. While its concepts like ownership and borrowing might initially seem challenging, they empower developers to write efficient and reliable code. Rust’s syntax may feel unconventional for those familiar with other languages, but it provides powerful abstractions that simplify the process of creating robust software.</p>
<p>So, why has Rust gained popularity despite its challenges?</p>
<p>Rust aims to balance the performance advantages of low-level systems programming languages with the safety, reliability, and ease of use found in high-level languages. Low-level languages such as C and C++ offer high performance with minimal resource consumption but are prone to errors that can affect reliability. On the other hand, high-level languages like Python, Kotlin, Julia, JavaScript, C#, and Java are easier to use but lack the low-level control needed for systems programming, often relying on garbage collection and large runtime environments.</p>
<p>Languages like Rust, Go, Swift, Zig, Nim, Crystal, and V aim to bridge this gap. Rust, in particular, has been the most successful in achieving this balance, as shown by its growing popularity.</p>
<p>As a systems programming language, Rust enforces memory safety through its ownership model and borrow checker, eliminating common issues like null pointer dereferencing, use-after-free, and buffer overflows—without needing a garbage collector. Rust avoids hidden, costly operations like implicit type conversions or unnecessary heap allocations, giving developers more control over performance. Copying large data structures is typically avoided by using references or move semantics, which transfer ownership of data. When copying is necessary, developers must explicitly request it using functions like <code>clone()</code>. Despite its performance-oriented constraints, Rust provides conveniences like iterators and closures, allowing for ease of use while maintaining high performance.</p>
<p>Rust’s ownership system not only guarantees memory safety but also enables <strong>fearless concurrency</strong> by preventing data races at compile time. This makes writing concurrent programs safer and more straightforward compared to languages where such errors are caught at runtime—or not at all.</p>
<p>Although Rust doesn’t follow the traditional class-based object-oriented programming (OOP) model, it adopts OOP principles through <strong>traits</strong> and <strong>structs</strong>, allowing for polymorphism and code reuse in a more flexible manner. Rust also avoids exceptions, opting for the <code>Result</code> and <code>Option</code> types for error handling. This approach encourages developers to handle errors explicitly, avoiding unexpected runtime failures.</p>
<p>Rust’s development began in 2006, initiated by Graydon Hoare with contributions from volunteers and later supported by Mozilla. The first stable version, Rust 1.0, was released in 2015, and by version 1.81, Rust has continued to evolve while maintaining backward compatibility. Today, Rust boasts a large, active developer community. After Mozilla’s involvement decreased, the Rust community established the <strong>Rust Foundation</strong>, supported by companies like AWS, Google, Microsoft, and Huawei, ensuring the long-term development and sustainability of Rust.</p>
<p>Rust’s development is driven by its community through an open process involving <strong>RFCs</strong> (Request for Comments), where new features and improvements are proposed and discussed. This collaborative and transparent process has fostered Rust’s rapid growth and the development of a large ecosystem of libraries and tools. The community’s commitment to quality and collaboration has transformed Rust into more than just a language—it’s a movement toward safer and more efficient programming.</p>
<p>Rust’s versatility has made it popular with companies like Facebook, Dropbox, Amazon, and Discord. For example, Dropbox uses Rust to optimize file storage systems, and Discord leverages it for high-performance networking. Rust is also widely used in <strong>system programming</strong>, <strong>embedded systems</strong>, <strong>WebAssembly</strong> for web development, and in building applications for <strong>PCs</strong> (Windows, Linux, macOS) and <strong>mobile platforms</strong>. Rust’s inclusion in Linux kernel development is a notable achievement, marking the first time another language has been added alongside C. Rust is also gaining traction in the <strong>blockchain</strong> industry.</p>
<p>Rust’s ecosystem is robust and mature, offering a powerful compiler, a modern build system with Cargo, and an extensive package repository, <strong>Crates.io</strong>, which hosts thousands of open-source libraries. Tools like <code>rustfmt</code> for formatting and <code>clippy</code> for linting ensure that Rust code remains clean and consistent. Rust also provides modern GUI frameworks such as <strong>EGUI</strong> and <strong>Xilem</strong>, game engines like <strong>Bevy</strong>, and even entire operating systems like <strong>Redox-OS</strong>.</p>
<p>Although Rust is a statically-typed, compiled language—often less suited for rapid prototyping compared to interpreted languages—tools like <strong>cargo-script</strong> and improved compile times have made Rust more accessible for quick development.</p>
<p>Since this book assumes familiarity with Rust’s basic merits, we will not delve further into the pros and cons here. Instead, we’ll highlight Rust’s core features and its well-established ecosystem. The LLVM-based compiler (<code>rustc</code>), the Cargo package manager, Crates.io, and the large, vibrant community are key factors in Rust’s growing prominence. Let’s now explore what makes Rust stand out.</p>
<p>Whether you come from a background in JavaScript, Python, or C++, this book will help bridge your existing knowledge to the Rust world.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="12-what-makes-rust-special"><a class="header" href="#12-what-makes-rust-special">1.2 What Makes Rust Special?</a></h2>
<p>Rust sets itself apart by offering <strong>automatic memory management without a garbage collector</strong>. This is achieved through strict rules around <strong>ownership</strong>, <strong>borrowing</strong>, <strong>move semantics</strong>, and by making <strong>immutability</strong> the default unless explicitly marked mutable using <code>mut</code>. Rust’s memory model ensures high performance while avoiding issues like invalid memory access or data races. Rust’s <strong>zero-cost abstractions</strong> enable high-level features without compromising performance. While this system may require more attention from developers, the long-term benefits—improved performance and fewer memory bugs—are significant, particularly for large projects.</p>
<p>Here are a few standout features that make Rust unique:</p>
<h3 id="121-error-handling-without-exceptions"><a class="header" href="#121-error-handling-without-exceptions">1.2.1 Error Handling Without Exceptions</a></h3>
<p>Rust does not rely on traditional exception handling (<code>try/catch</code>). Instead, it uses <strong><code>Result</code></strong> and <strong><code>Option</code></strong> types to handle errors, requiring explicit error management. This prevents errors from being silently ignored, as can happen with exceptions. While this can make Rust code more verbose, the <strong><code>?</code> operator</strong> simplifies error propagation, allowing errors to be handled concisely without sacrificing clarity. Rust’s error handling model promotes predictable, transparent code.</p>
<h3 id="122-a-different-approach-to-object-oriented-programming"><a class="header" href="#122-a-different-approach-to-object-oriented-programming">1.2.2 A Different Approach to Object-Oriented Programming</a></h3>
<p>Rust incorporates object-oriented principles like encapsulation and polymorphism but avoids classical inheritance. Instead, Rust emphasizes <strong>composition</strong> and uses <strong>traits</strong> to define shared behaviors and interfaces, offering flexible and reusable code structures. With <strong>trait objects</strong>, Rust supports dynamic dispatch, allowing for polymorphism similar to traditional OOP languages. This approach encourages clear, modular design while avoiding some of the complexities inherent in inheritance. For developers familiar with Java or C++, Rust’s traits offer a modern and efficient alternative to traditional interfaces and abstract classes.</p>
<h3 id="123-pattern-matching-and-enumerations"><a class="header" href="#123-pattern-matching-and-enumerations">1.2.3 Pattern Matching and Enumerations</a></h3>
<p>Rust’s <strong>enumerations</strong> (enums) are more advanced than those in many other languages. Rust’s enums are <strong>algebraic data types</strong>, capable of storing different types and amounts of data for each variant, making them ideal for modeling complex data structures. Coupled with <strong>pattern matching</strong>, Rust allows concise, expressive code to handle different cases in a clean and readable way. Although pattern matching may feel unfamiliar initially, it simplifies working with complex data and improves code readability.</p>
<h3 id="124-threading-and-parallel-processing"><a class="header" href="#124-threading-and-parallel-processing">1.2.4 Threading and Parallel Processing</a></h3>
<p>Rust excels in supporting <strong>safe concurrency</strong> and <strong>parallelism</strong>. Thanks to Rust’s ownership and borrowing rules, data races are eliminated at compile time, making it easier to write efficient, safe concurrent code. Rust’s concept of <strong>fearless concurrency</strong> allows developers to confidently write multithreaded applications, knowing the compiler will catch any data race or synchronization errors before the program is run. Libraries like <strong>Rayon</strong> offer simple, high-level APIs for parallel processing, making Rust especially suited for performance-critical applications that require safe concurrency across multiple threads.</p>
<h3 id="125-string-types-and-explicit-conversions"><a class="header" href="#125-string-types-and-explicit-conversions">1.2.5 String Types and Explicit Conversions</a></h3>
<p>Rust provides two primary string types: <strong><code>String</code></strong>, an owned, heap-allocated string, and <strong><code>&amp;str</code></strong>, a borrowed string slice. Although managing these different string types may initially be challenging, Rust’s strict typing ensures safe memory management. Converting between string types is explicit, facilitated by traits like <code>From</code>, <code>Into</code>, and <code>AsRef</code>. While this approach may add some verbosity, it ensures clarity and prevents common bugs associated with string handling.</p>
<p>Rust also requires explicit <strong>type conversions</strong> between numeric types. For instance, integers are not implicitly converted to floating-point numbers, and vice versa. This strict type system prevents bugs and avoids performance costs associated with implicit conversions.</p>
<h3 id="126-trade-offs-in-language-features"><a class="header" href="#126-trade-offs-in-language-features">1.2.6 Trade-offs in Language Features</a></h3>
<p>Rust lacks certain convenience features common in other languages, such as <strong>default parameters</strong>, <strong>named function parameters</strong>, and <strong>subrange types</strong>. Additionally, Rust does not have <strong>type or constant sections</strong> like Pascal, which can make the code more verbose. However, developers often use <strong>builder patterns</strong> or <strong>method chaining</strong> to simulate default and named parameters, promoting clear and maintainable code. The Rust community is also exploring the addition of features like named arguments in future versions of the language.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="13-about-the-book"><a class="header" href="#13-about-the-book">1.3 About the Book</a></h2>
<p>There are already several comprehensive books on Rust, including the official guide, <a href="https://doc.rust-lang.org/book/">The Book</a>, and more advanced resources such as <em>Programming Rust</em> by Jim Blandy, Jason Orendorff, and Leonora F. S. Tindall. For more in-depth learning, <em>Rust for Rustaceans</em> by Jon Gjengset and the online resource <a href="https://www.lurklurk.org/effective-rust/">Effective Rust</a> are excellent. Additional learning materials like <a href="https://doc.rust-lang.org/rust-by-example/">Rust by Example</a> and the <a href="https://rust-lang-nursery.github.io/rust-cookbook/">Rust Cookbook</a> are also available. Numerous video tutorials exist for those who prefer visual learning.</p>
<p>With such a wealth of resources already available, you might wonder if another Rust book is necessary. Writing a high-quality technical book demands deep expertise, excellent writing skills, and a significant time investment—often more than 1,000 hours. Professional editing and proofreading are also necessary to eliminate errors and ensure clarity.</p>
<p>However, modern AI tools like GPT-4 have changed the landscape of book creation. AI can generate high-quality content, provide answers to specific questions, and even check for errors. While AI-generated content isn’t flawless, it offers a powerful way to produce technical books and guides with fewer resources.</p>
<p>I began learning Rust in late 2023 and quickly noticed there wasn’t a concise Rust book specifically designed for programmers with a background in systems programming, particularly C. I wanted a book that was precise, up-to-date, and tailored for experienced developers. Many existing books spend significant time on basic concepts, which can make them overly verbose for those familiar with systems programming.</p>
<p>After exploring <em>The Book</em> and <em>Programming Rust</em>, I decided to use AI to create a more compact Rust guide. I frequently consulted GPT-4 for Rust-related issues and was impressed with its accuracy. Over time, I started organizing the content systematically, which led to the creation of <em>Rust for C-Programmers</em>.</p>
<p>The title <em>Rust for C-Programmers</em> reflects the book’s focus on providing a compact introduction to Rust for experienced developers, particularly those familiar with C. While the book is still in its early draft stages, it has the potential to become a valuable resource.</p>
<p>Even with AI assistance, writing a quality book requires careful proofreading and feedback from experienced Rust developers and native English speakers.</p>
<hr />
<p>When reading the online version of this book, generated by the <em>mdbook</em> tool, you can select different themes from a drop-down menu. The tool also features a powerful search function. If the system font appears too small, most web browsers allow you to increase the text size by pressing "CTRL +". Code examples with hidden lines can be fully revealed by clicking on them, and you can run the examples directly in Rust’s playground. You can also modify the examples before running them, or copy and paste them into the <a href="https://play.rust-lang.org">Rust Playground</a>.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="14-about-the-authors"><a class="header" href="#14-about-the-authors">1.4 About the Authors</a></h2>
<h3 id="main-authors"><a class="header" href="#main-authors">Main Authors</a></h3>
<ul>
<li>GPT-4o</li>
<li>GPT-4 o1 preview</li>
</ul>
<h3 id="co-authors"><a class="header" href="#co-authors">Co-Authors</a></h3>
<ul>
<li>Claude 3.5 Sonnet</li>
<li>Llama 3.1</li>
<li>Various other generative AI tools</li>
<li>S. Salewski</li>
</ul>
<h3 id="the-true-authors"><a class="header" href="#the-true-authors">The True Authors</a></h3>
<p>The content of this book is fundamentally built upon the wealth of information about Rust available across the internet, particularly the official Rust book, the language specification, and the API documentation. We acknowledge that many other public Rust resources created by the community have also greatly contributed to the quality of this book.</p>
<hr />
<p>Much of this book’s content was generated by GPT-4o based on simple prompts, with occasional requests for clarification or additional detail. The GPT-4 o1 preview model was sometimes used for initial drafts or revisions. Other tools, such as Claude 3.5 Sonnet and Llama 3.1, were also employed, but proved less reliable. As a result, we primarily relied on GPT-4 for its high-quality output.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2-the-basic-structure-of-a-rust-program"><a class="header" href="#chapter-2-the-basic-structure-of-a-rust-program">Chapter 2: The Basic Structure of a Rust Program</a></h1>
<p>As a C programmer venturing into Rust, you'll find many familiar concepts alongside new paradigms designed to enhance safety and concurrency. This chapter introduces the fundamental components of a Rust program, drawing direct comparisons to C to help you transition smoothly. We'll explore the syntax, structure, and conventions of Rust, highlighting similarities and differences with C, and provide practical examples to illustrate key points.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="21-compiled-language-and-build-system"><a class="header" href="#21-compiled-language-and-build-system">2.1 Compiled Language and Build System</a></h2>
<p>Like C, Rust is a <strong>compiled language</strong>, converting your human-readable source code into machine code that can be executed directly by the system. This compilation results in separate source code (text files) and binary executable files.</p>
<h3 id="211-cargo-rusts-build-system-and-package-manager"><a class="header" href="#211-cargo-rusts-build-system-and-package-manager">2.1.1 Cargo: Rust's Build System and Package Manager</a></h3>
<p>Rust uses <strong>Cargo</strong> as its build system and package manager, akin to <code>make</code> or <code>cmake</code> in the C world, but with more features integrated by default. Cargo simplifies tasks such as compiling code, managing dependencies, running tests, and building projects.</p>
<p><strong>Example of initializing a new Cargo project:</strong></p>
<pre><code class="language-bash">cargo new my_project
cd my_project
cargo build
</code></pre>
<p>This creates a new Rust project with a predefined directory structure, making it easier to manage larger codebases.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="22-the-main-function-entry-point-of-execution"><a class="header" href="#22-the-main-function-entry-point-of-execution">2.2 The <code>main</code> Function: Entry Point of Execution</a></h2>
<p>In both Rust and C, the <code>main</code> function serves as the entry point of the program.</p>
<h3 id="221-rust-example"><a class="header" href="#221-rust-example">2.2.1 Rust Example</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<ul>
<li><code>fn</code> declares a function.</li>
<li><code>main</code> is the name of the function.</li>
<li>The function body is enclosed in <code>{}</code>.</li>
<li><code>println!</code> is a macro that prints to the console (similar to <code>printf</code> in C).</li>
</ul>
<h3 id="222-comparison-with-c"><a class="header" href="#222-comparison-with-c">2.2.2 Comparison with C</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    printf("Hello, world!\n");
    return 0;
}
</code></pre>
<ul>
<li><code>#include &lt;stdio.h&gt;</code> includes the standard I/O library.</li>
<li><code>int main()</code> declares the main function returning an integer.</li>
<li><code>printf</code> prints to the console.</li>
<li><code>return 0;</code> indicates successful execution.</li>
</ul>
<p><strong>Note:</strong> In Rust, the <code>main</code> function returns <code>()</code> by default (the unit type), and you don't need to specify <code>return 0;</code>. However, you can have <code>main</code> return a <code>Result</code> for error handling.</p>
<h3 id="223-returning-a-result-from-main"><a class="header" href="#223-returning-a-result-from-main">2.2.3 Returning a Result from <code>main</code></a></h3>
<pre><pre class="playground"><code class="language-rust editable">use std::error::Error;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // Your code here
    Ok(())
}</code></pre></pre>
<p>This allows for robust error handling in your Rust programs.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="23-variables-and-mutability"><a class="header" href="#23-variables-and-mutability">2.3 Variables and Mutability</a></h2>
<h3 id="231-immutable-by-default"><a class="header" href="#231-immutable-by-default">2.3.1 Immutable by Default</a></h3>
<p>In Rust, variables are <strong>immutable by default</strong>, enhancing safety by preventing unintended changes.</p>
<p><strong>Rust Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5;
    // x = 6; // Error: cannot assign twice to immutable variable
}</code></pre></pre>
<p>To make a variable mutable, use the <code>mut</code> keyword.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 5;
    x = 6; // Allowed
    println!("The value of x is: {}", x);
}</code></pre></pre>
<h3 id="232-comparison-with-c"><a class="header" href="#232-comparison-with-c">2.3.2 Comparison with C</a></h3>
<p>In C, variables are mutable by default.</p>
<pre><code class="language-c">int x = 5;
x = 6; // Allowed
</code></pre>
<p>To make a variable constant in C, you use the <code>const</code> keyword.</p>
<pre><code class="language-c">const int x = 5;
// x = 6; // Error: assignment of read-only variable ‘x’
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="24-data-types-and-type-annotations"><a class="header" href="#24-data-types-and-type-annotations">2.4 Data Types and Type Annotations</a></h2>
<p>Rust requires that all variables have a well-defined type, which can often be inferred by the compiler.</p>
<h3 id="241-basic-data-types"><a class="header" href="#241-basic-data-types">2.4.1 Basic Data Types</a></h3>
<ul>
<li><strong>Integers</strong>: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code> (signed); <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code> (unsigned)</li>
<li><strong>Floating-Point Numbers</strong>: <code>f32</code>, <code>f64</code></li>
<li><strong>Booleans</strong>: <code>bool</code></li>
<li><strong>Characters</strong>: <code>char</code> (4 bytes, Unicode scalar values)</li>
</ul>
<h3 id="242-type-inference"><a class="header" href="#242-type-inference">2.4.2 Type Inference</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 42; // x: i32 inferred
    let y = 3.14; // y: f64 inferred
    println!("x = {}, y = {}", x, y);
}</code></pre></pre>
<h3 id="243-explicit-type-annotation"><a class="header" href="#243-explicit-type-annotation">2.4.3 Explicit Type Annotation</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: u8 = 255;
    println!("x = {}", x);
}</code></pre></pre>
<h3 id="244-comparison-with-c"><a class="header" href="#244-comparison-with-c">2.4.4 Comparison with C</a></h3>
<p>In C, you have similar basic types but with different sizes and naming conventions.</p>
<pre><code class="language-c">int x = 42;       // Typically 32 bits
float y = 3.14f;  // Single-precision floating point
char c = 'A';     // 1 byte
</code></pre>
<p><strong>Note:</strong> Rust's integer types have explicit sizes, reducing ambiguity.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="25-constants-and-statics"><a class="header" href="#25-constants-and-statics">2.5 Constants and Statics</a></h2>
<h3 id="251-constants"><a class="header" href="#251-constants">2.5.1 Constants</a></h3>
<p>Constants are immutable values that are set at compile time.</p>
<pre><pre class="playground"><code class="language-rust editable">const MAX_POINTS: u32 = 100_000;

fn main() {
    println!("The maximum points are: {}", MAX_POINTS);
}</code></pre></pre>
<ul>
<li>Must include type annotations.</li>
<li>Naming convention: <code>SCREAMING_SNAKE_CASE</code>.</li>
</ul>
<h3 id="252-statics"><a class="header" href="#252-statics">2.5.2 Statics</a></h3>
<p>Statics are similar to constants but represent a fixed location in memory.</p>
<pre><pre class="playground"><code class="language-rust editable">static GREETING: &amp;str = "Hello, world!";

fn main() {
    println!("{}", GREETING);
}</code></pre></pre>
<h3 id="253-comparison-with-c"><a class="header" href="#253-comparison-with-c">2.5.3 Comparison with C</a></h3>
<p>In C, you use <code>#define</code> or <code>const</code> for constants.</p>
<pre><code class="language-c">#define MAX_POINTS 100000
const int max_points = 100000;
</code></pre>
<ul>
<li><code>#define</code> is a preprocessor directive; no type safety.</li>
<li><code>const</code> variables can have type annotations.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="26-functions-and-control-flow"><a class="header" href="#26-functions-and-control-flow">2.6 Functions and Control Flow</a></h2>
<h3 id="261-function-declaration"><a class="header" href="#261-function-declaration">2.6.1 Function Declaration</a></h3>
<p>In Rust:</p>
<pre><pre class="playground"><code class="language-rust editable">fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn main() {
    let result = add(5, 3);
    println!("The sum is: {}", result);
}</code></pre></pre>
<ul>
<li>Functions start with <code>fn</code>.</li>
<li>Parameters include type annotations.</li>
<li>The return type is specified with <code>-&gt;</code>.</li>
</ul>
<h3 id="262-comparison-with-c"><a class="header" href="#262-comparison-with-c">2.6.2 Comparison with C</a></h3>
<pre><code class="language-c">int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(5, 3);
    printf("The sum is: %d\n", result);
    return 0;
}
</code></pre>
<h3 id="263-control-structures"><a class="header" href="#263-control-structures">2.6.3 Control Structures</a></h3>
<h4 id="if-statements"><a class="header" href="#if-statements">If Statements</a></h4>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5;
    if x &lt; 10 {
        println!("Less than 10");
    } else {
        println!("10 or more");
    }
}</code></pre></pre>
<ul>
<li>Conditions must be <code>bool</code>.</li>
<li>No parentheses required around the condition.</li>
</ul>
<p>C:</p>
<pre><code class="language-c">int x = 5;
if (x &lt; 10) {
    printf("Less than 10\n");
} else {
    printf("10 or more\n");
}
</code></pre>
<ul>
<li>Conditions can be any non-zero value (not necessarily <code>bool</code>).</li>
<li>Parentheses are required.</li>
</ul>
<h4 id="loops"><a class="header" href="#loops">Loops</a></h4>
<h5 id="while-loop"><a class="header" href="#while-loop"><code>while</code> Loop</a></h5>
<p>Rust:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut x = 0;
    while x &lt; 5 {
        println!("x is: {}", x);
        x += 1;
    }
}</code></pre></pre>
<p>C:</p>
<pre><code class="language-c">int x = 0;
while (x &lt; 5) {
    printf("x is: %d\n", x);
    x += 1;
}
</code></pre>
<h5 id="for-loop"><a class="header" href="#for-loop"><code>for</code> Loop</a></h5>
<p>Rust's <code>for</code> loop iterates over iterators:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    for i in 0..10 {
        println!("{}", i);
    }
}</code></pre></pre>
<ul>
<li><code>0..10</code> is a range from 0 to 9.</li>
<li>No classic C-style <code>for</code> loop.</li>
</ul>
<p>C:</p>
<pre><code class="language-c">for (int i = 0; i &lt; 10; i++) {
    printf("%d\n", i);
}
</code></pre>
<h5 id="loop"><a class="header" href="#loop"><code>loop</code></a></h5>
<p>Rust provides the <code>loop</code> keyword for infinite loops:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut count = 0;
    loop {
        println!("Count is: {}", count);
        count += 1;
        if count == 5 {
            break;
        }
    }
}</code></pre></pre>
<h4 id="assignments-in-conditions"><a class="header" href="#assignments-in-conditions">Assignments in Conditions</a></h4>
<p>Rust does not allow assignments in conditions:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut x = 5;
    // if x = 10 { } // Error: expected `bool`, found `()`
}</code></pre>
<p>You must use comparison operators:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5;
    if x == 10 {
        println!("x is 10");
    } else {
        println!("x is not 10");
    }
}</code></pre></pre>
<p>In C, assignments in conditions are allowed (but can be error-prone):</p>
<pre><code class="language-c">int x = 5;
if (x = 10) {
    // x is assigned 10, and the condition evaluates to true (non-zero)
    printf("x is assigned to 10 and condition is true\n");
}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="27-modules-and-crates"><a class="header" href="#27-modules-and-crates">2.7 Modules and Crates</a></h2>
<h3 id="271-modules"><a class="header" href="#271-modules">2.7.1 Modules</a></h3>
<p>Rust uses modules to organize code, replacing the header-file system in C.</p>
<h4 id="defining-modules"><a class="header" href="#defining-modules">Defining Modules</a></h4>
<pre><code class="language-rust ignore">mod my_module {
    pub fn my_function() {
        println!("This is my function");
    }
}</code></pre>
<ul>
<li>Use <code>mod</code> to define a module.</li>
<li>Use <code>pub</code> to make items public.</li>
</ul>
<h4 id="using-modules"><a class="header" href="#using-modules">Using Modules</a></h4>
<pre><pre class="playground"><code class="language-rust editable">mod my_module {
    pub fn my_function() {
        println!("This is my function");
    }
}

fn main() {
    my_module::my_function();
}</code></pre></pre>
<h3 id="272-splitting-modules-across-files"><a class="header" href="#272-splitting-modules-across-files">2.7.2 Splitting Modules Across Files</a></h3>
<ul>
<li>Create a file named <code>my_module.rs</code>.</li>
<li>In your main file, declare:</li>
</ul>
<pre><code class="language-rust ignore">mod my_module;</code></pre>
<p>Now, <code>my_module</code> is available in your code.</p>
<h3 id="273-crates"><a class="header" href="#273-crates">2.7.3 Crates</a></h3>
<ul>
<li>A <strong>crate</strong> is a compilation unit in Rust (like a library or executable).</li>
<li>Crates can be binary (with a <code>main</code> function) or library crates.</li>
</ul>
<h3 id="274-comparison-with-c"><a class="header" href="#274-comparison-with-c">2.7.4 Comparison with C</a></h3>
<ul>
<li>C uses header files (<code>.h</code>) and source files (<code>.c</code>).</li>
<li>Headers declare functions and variables; source files define them.</li>
</ul>
<pre><code class="language-c">// my_module.h
void my_function();

// my_module.c
#include "my_module.h"
#include &lt;stdio.h&gt;

void my_function() {
    printf("This is my function\n");
}

// main.c
#include "my_module.h"

int main() {
    my_function();
    return 0;
}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="28-use-statements-and-namespacing"><a class="header" href="#28-use-statements-and-namespacing">2.8 <code>use</code> Statements and Namespacing</a></h2>
<h3 id="281-bringing-names-into-scope"><a class="header" href="#281-bringing-names-into-scope">2.8.1 Bringing Names into Scope</a></h3>
<pre><pre class="playground"><code class="language-rust editable">use std::io;

fn main() {
    let mut input = String::new();
    io::stdin().read_line(&amp;mut input)
        .expect("Failed to read line");
    println!("You typed: {}", input);
}</code></pre></pre>
<ul>
<li><code>use</code> brings a path into scope, simplifying code.</li>
</ul>
<h3 id="282-comparison-with-c"><a class="header" href="#282-comparison-with-c">2.8.2 Comparison with C</a></h3>
<ul>
<li>C uses <code>#include</code> to include headers.</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    char input[100];
    fgets(input, 100, stdin);
    printf("You typed: %s", input);
    return 0;
}
</code></pre>
<ul>
<li><code>#include</code> copies the entire file content; Rust's <code>use</code> is more precise.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="29-traits-and-implementations"><a class="header" href="#29-traits-and-implementations">2.9 Traits and Implementations</a></h2>
<h3 id="291-traits"><a class="header" href="#291-traits">2.9.1 Traits</a></h3>
<p>Traits in Rust are similar to interfaces in other languages, defining shared behavior.</p>
<pre><code class="language-rust ignore">trait Drawable {
    fn draw(&amp;self);
}</code></pre>
<h3 id="292-implementing-traits"><a class="header" href="#292-implementing-traits">2.9.2 Implementing Traits</a></h3>
<pre><code class="language-rust ignore">struct Circle;

impl Drawable for Circle {
    fn draw(&amp;self) {
        println!("Drawing a circle");
    }
}</code></pre>
<h3 id="293-using-traits"><a class="header" href="#293-using-traits">2.9.3 Using Traits</a></h3>
<pre><pre class="playground"><code class="language-rust editable">trait Drawable {
    fn draw(&amp;self);
}

struct Circle;

impl Drawable for Circle {
    fn draw(&amp;self) {
        println!("Drawing a circle");
    }
}

fn main() {
    let c = Circle;
    c.draw();
}</code></pre></pre>
<h3 id="294-comparison-with-c"><a class="header" href="#294-comparison-with-c">2.9.4 Comparison with C</a></h3>
<p>C does not have traits or interfaces built into the language. Similar behavior is often achieved using function pointers or structs of function pointers (vtable pattern).</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="210-macros"><a class="header" href="#210-macros">2.10 Macros</a></h2>
<h3 id="2101-macros-in-rust"><a class="header" href="#2101-macros-in-rust">2.10.1 Macros in Rust</a></h3>
<p>Macros provide metaprogramming capabilities.</p>
<ul>
<li><strong>Declarative Macros</strong>: Use <code>macro_rules!</code> to define patterns.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! say_hello {
    () =&gt; {
        println!("Hello!");
    };
}

fn main() {
    say_hello!();
}</code></pre></pre>
<ul>
<li><strong>Procedural Macros</strong>: Allow you to generate code using Rust code (more advanced).</li>
</ul>
<h3 id="2102-the-println-macro"><a class="header" href="#2102-the-println-macro">2.10.2 The <code>println!</code> Macro</a></h3>
<ul>
<li><code>println!</code> is a macro because it can accept a variable number of arguments and perform formatting at compile time.</li>
</ul>
<h3 id="2103-comparison-with-c"><a class="header" href="#2103-comparison-with-c">2.10.3 Comparison with C</a></h3>
<ul>
<li>C has preprocessor macros using <code>#define</code>.</li>
</ul>
<pre><code class="language-c">#define SQUARE(x) ((x) * (x))

int main() {
    int result = SQUARE(5); // Expands to ((5) * (5))
    printf("%d\n", result);
    return 0;
}
</code></pre>
<ul>
<li>C macros are text substitution; Rust macros are more powerful and safer.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="211-error-handling"><a class="header" href="#211-error-handling">2.11 Error Handling</a></h2>
<h3 id="2111-result-and-option-types"><a class="header" href="#2111-result-and-option-types">2.11.1 <code>Result</code> and <code>Option</code> Types</a></h3>
<p>Rust does not use exceptions for error handling. Instead, it uses the <code>Result</code> and <code>Option</code> types.</p>
<pre><pre class="playground"><code class="language-rust editable">fn divide(a: f64, b: f64) -&gt; Result&lt;f64, String&gt; {
    if b == 0.0 {
        Err(String::from("Cannot divide by zero"))
    } else {
        Ok(a / b)
    }
}

fn main() {
    match divide(4.0, 2.0) {
        Ok(result) =&gt; println!("Result is {}", result),
        Err(e) =&gt; println!("Error: {}", e),
    }
}</code></pre></pre>
<h3 id="2112-comparison-with-c"><a class="header" href="#2112-comparison-with-c">2.11.2 Comparison with C</a></h3>
<p>C typically handles errors using return codes and <code>errno</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;errno.h&gt;
#include &lt;math.h&gt;

int divide(double a, double b, double *result) {
    if (b == 0.0) {
        errno = EDOM; // Domain error
        return -1;
    } else {
        *result = a / b;
        return 0;
    }
}

int main() {
    double res;
    if (divide(4.0, 0.0, &amp;res) != 0) {
        perror("Error");
    } else {
        printf("Result is %f\n", res);
    }
    return 0;
}
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="212-memory-safety-and-ownership"><a class="header" href="#212-memory-safety-and-ownership">2.12 Memory Safety and Ownership</a></h2>
<p>While not deeply covered in this chapter, it's essential to recognize that Rust's ownership model ensures memory safety without a garbage collector.</p>
<ul>
<li><strong>Ownership</strong>: Each value in Rust has a variable that's its owner.</li>
<li><strong>Borrowing</strong>: References allow you to borrow data without taking ownership.</li>
<li><strong>No Null</strong>: Rust does not have null pointers; instead, it uses <code>Option&lt;T&gt;</code> to represent optional values.</li>
</ul>
<h3 id="2121-comparison-with-c"><a class="header" href="#2121-comparison-with-c">2.12.1 Comparison with C</a></h3>
<ul>
<li>C requires manual memory management with <code>malloc</code> and <code>free</code>.</li>
<li>Null pointers can lead to segmentation faults.</li>
<li>Rust prevents common errors like use-after-free and null dereferencing at compile time.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="213-syntax-structures-expressions-and-statements"><a class="header" href="#213-syntax-structures-expressions-and-statements">2.13 Syntax Structures: Expressions and Statements</a></h2>
<h3 id="2131-expressions-vs-statements"><a class="header" href="#2131-expressions-vs-statements">2.13.1 Expressions vs. Statements</a></h3>
<p>Rust is an expression-based language.</p>
<ul>
<li><strong>Expression</strong>: Evaluates to a value.</li>
<li><strong>Statement</strong>: Performs an action.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5; // Statement with an expression

    let y = {
        let x = 3;
        x + 1 // Expression without semicolon
    }; // y is 4

    println!("x = {}, y = {}", x, y);
}</code></pre></pre>
<h3 id="2132-semicolons"><a class="header" href="#2132-semicolons">2.13.2 Semicolons</a></h3>
<ul>
<li>Adding a semicolon turns an expression into a statement that does not return a value.</li>
<li>Omitting the semicolon means the expression's value is returned.</li>
</ul>
<h3 id="2133-blocks"><a class="header" href="#2133-blocks">2.13.3 Blocks</a></h3>
<ul>
<li>Blocks <code>{}</code> can be used as expressions.</li>
</ul>
<h3 id="2134-comparison-with-c"><a class="header" href="#2134-comparison-with-c">2.13.4 Comparison with C</a></h3>
<ul>
<li>C distinguishes between expressions and statements but does not allow blocks to be expressions that return values.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="214-code-conventions-and-style"><a class="header" href="#214-code-conventions-and-style">2.14 Code Conventions and Style</a></h2>
<h3 id="2141-formatting"><a class="header" href="#2141-formatting">2.14.1 Formatting</a></h3>
<ul>
<li>Indentation: 4 spaces (by convention).</li>
<li>Use <code>rustfmt</code> to automatically format code.</li>
</ul>
<h3 id="2142-naming-conventions"><a class="header" href="#2142-naming-conventions">2.14.2 Naming Conventions</a></h3>
<ul>
<li><strong>Variables and Functions</strong>: <code>snake_case</code></li>
<li><strong>Constants and Statics</strong>: <code>SCREAMING_SNAKE_CASE</code></li>
<li><strong>Types and Traits</strong>: <code>PascalCase</code></li>
<li><strong>Crates and Modules</strong>: <code>snake_case</code></li>
</ul>
<h3 id="2143-comparison-with-c"><a class="header" href="#2143-comparison-with-c">2.14.3 Comparison with C</a></h3>
<ul>
<li>C has similar conventions, but practices vary more widely.</li>
<li>Consistency is encouraged but not enforced in C.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="215-comments-and-documentation"><a class="header" href="#215-comments-and-documentation">2.15 Comments and Documentation</a></h2>
<h3 id="2151-comments"><a class="header" href="#2151-comments">2.15.1 Comments</a></h3>
<ul>
<li>Single-line comments use <code>//</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">// This is a comment
fn main() {
    // Another comment
    println!("Comments are ignored by the compiler");
}</code></pre></pre>
<ul>
<li>Multi-line comments use <code>/* */</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">/*
This is a
multi-line comment
*/
fn main() {
    println!("Multi-line comments are useful");
}</code></pre></pre>
<h3 id="2152-documentation-comments"><a class="header" href="#2152-documentation-comments">2.15.2 Documentation Comments</a></h3>
<ul>
<li>Use <code>///</code> for documentation comments that can be processed by tools like <code>rustdoc</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">/// Adds two numbers together.
///
/// # Examples
///
/// ```
/// let result = add(2, 3);
/// assert_eq!(result, 5);
/// ```
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

fn main() {
    let sum = add(2, 3);
    println!("Sum is: {}", sum);
}</code></pre></pre>
<h3 id="2153-comparison-with-c"><a class="header" href="#2153-comparison-with-c">2.15.3 Comparison with C</a></h3>
<ul>
<li>C uses <code>//</code> and <code>/* */</code> for comments.</li>
<li>Documentation is often less standardized in C, though tools like Doxygen can be used.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="216-additional-topics"><a class="header" href="#216-additional-topics">2.16 Additional Topics</a></h2>
<h3 id="2161-the-standard-library"><a class="header" href="#2161-the-standard-library">2.16.1 The Standard Library</a></h3>
<ul>
<li>Rust's standard library provides common functionality, similar to C's standard library (<code>libc</code>).</li>
<li>Includes data structures like <code>Vec</code>, <code>HashMap</code>, and utilities for I/O, threading, and more.</li>
</ul>
<h3 id="2162-testing"><a class="header" href="#2162-testing">2.16.2 Testing</a></h3>
<ul>
<li>Rust has built-in support for unit tests using the <code>#[test]</code> attribute.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable">#[cfg(test)]
mod tests {
    #[test]
    fn test_add() {
        assert_eq!(2 + 2, 4);
    }
}</code></pre></pre>
<h3 id="2163-cargo-features"><a class="header" href="#2163-cargo-features">2.16.3 Cargo Features</a></h3>
<ul>
<li><strong>Building</strong>: <code>cargo build</code></li>
<li><strong>Running</strong>: <code>cargo run</code></li>
<li><strong>Testing</strong>: <code>cargo test</code></li>
<li><strong>Documentation</strong>: <code>cargo doc --open</code></li>
</ul>
<h3 id="2164-error-messages-and-tooling"><a class="header" href="#2164-error-messages-and-tooling">2.16.4 Error Messages and Tooling</a></h3>
<ul>
<li>Rust provides detailed compiler error messages to help you fix issues.</li>
<li>Tools like <code>rustc</code> (the compiler) and <code>clippy</code> (a linter) assist in writing idiomatic Rust code.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="217-summary"><a class="header" href="#217-summary">2.17 Summary</a></h2>
<p>In this chapter, we've introduced the basic structure of a Rust program, highlighting the similarities and differences with C to ease your transition. We covered:</p>
<ul>
<li><strong>Compiled Language and Build System</strong>: Understanding Rust's compilation process and the role of Cargo as both a build system and package manager.</li>
<li><strong>The <code>main</code> Function</strong>: How Rust's entry point compares to C's, including returning <code>Result</code> for error handling.</li>
<li><strong>Variables and Mutability</strong>: Rust's immutable variables by default and how to declare mutable ones.</li>
<li><strong>Data Types and Type Annotations</strong>: The explicit and inferred typing system in Rust, with a comparison to C's types.</li>
<li><strong>Constants and Statics</strong>: Declaring constants and static variables in Rust versus C.</li>
<li><strong>Functions and Control Flow</strong>: Defining functions, control structures like <code>if</code>, <code>while</code>, <code>for</code>, and the unique <code>loop</code> in Rust.</li>
<li><strong>Modules and Crates</strong>: Organizing code using modules and crates, and how this differs from C's header files.</li>
<li><strong><code>use</code> Statements and Namespacing</strong>: Bringing names into scope and the precision of Rust's <code>use</code> compared to C's <code>#include</code>.</li>
<li><strong>Traits and Implementations</strong>: Introducing traits as a way to define shared behavior, similar to interfaces.</li>
<li><strong>Macros</strong>: The power and safety of Rust's macros compared to C's preprocessor macros.</li>
<li><strong>Error Handling</strong>: Using <code>Result</code> and <code>Option</code> types instead of exceptions, and comparing this to C's error handling.</li>
<li><strong>Memory Safety and Ownership</strong>: An overview of Rust's ownership model for memory safety.</li>
<li><strong>Expressions and Statements</strong>: Understanding Rust's expression-based syntax.</li>
<li><strong>Code Conventions and Style</strong>: Formatting and naming conventions in Rust.</li>
<li><strong>Comments and Documentation</strong>: Writing comments and documentation, utilizing <code>rustdoc</code>.</li>
<li><strong>Additional Topics</strong>: Leveraging the standard library, testing with Cargo, and the robust tooling available in Rust.</li>
</ul>
<p>By understanding these fundamental concepts, you are well on your way to writing safe, efficient, and idiomatic Rust code.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="218-closing-thoughts"><a class="header" href="#218-closing-thoughts">2.18 Closing Thoughts</a></h2>
<p>Transitioning from C to Rust involves learning new paradigms and embracing Rust's focus on safety and concurrency. While many concepts in Rust have parallels in C, Rust introduces powerful features like ownership, lifetimes, and traits that enhance code reliability and expressiveness.</p>
<p>As you continue your journey with Rust, remember that the language is designed to help you catch errors at compile time, preventing many common bugs that occur in C. Embrace Rust's strictness regarding mutability, type safety, and memory management—it leads to more robust and maintainable code.</p>
<p>Keep practicing by writing Rust programs, experimenting with the examples provided, and exploring Rust's rich ecosystem of libraries and tools. The concepts covered in this chapter lay the groundwork for more advanced topics that we'll delve into in subsequent chapters, such as ownership, borrowing, lifetimes, and concurrency.</p>
<p>Happy coding, and welcome to the Rust community!</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3-installing-rust"><a class="header" href="#chapter-3-installing-rust">Chapter 3: Installing Rust</a></h1>
<p>This chapter provides a brief overview of how to set up Rust on your system. Rather than providing detailed installation instructions here, we recommend following the official Rust website for the most up-to-date information. These instructions are continuously maintained to accommodate various operating systems and will help ensure that you install the latest version of Rust.</p>
<p>You can find the installation guide here:<br />
<a href="https://www.rust-lang.org/learn/get-started">Rust Installation Instructions</a></p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="31-linux-users"><a class="header" href="#31-linux-users">3.1 Linux Users</a></h2>
<p>For many Linux distributions, Rust may already be preinstalled or can be installed easily using the distribution's package manager. Examples include:</p>
<ul>
<li>
<p>On Ubuntu or other Debian-based systems, you can install Rust with:</p>
<pre><code class="language-bash">sudo apt install rustc
</code></pre>
</li>
<li>
<p>On Fedora-based systems, use:</p>
<pre><code class="language-bash">sudo dnf install rust
</code></pre>
</li>
</ul>
<p>However, to ensure that you have the latest version of Rust and the ability to easily manage multiple versions, it is recommended to install Rust using the <strong>rustup</strong> tool. <strong>rustup</strong> provides the most current release of Rust and simplifies switching between versions.</p>
<p>To install Rust using <strong>rustup</strong>, follow the instructions on the official website or run the following command in your terminal:</p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="32-experimenting-with-rust-in-the-playground"><a class="header" href="#32-experimenting-with-rust-in-the-playground">3.2 Experimenting with Rust in the Playground</a></h2>
<p>If you want to try Rust before installing it locally, you can use the <strong>Rust Playground</strong>, an online tool that allows you to write and execute Rust code directly in your browser.</p>
<p>You can visit the Rust Playground here:<br />
<a href="https://play.rust-lang.org/">Rust Playground</a></p>
<p>The playground is a convenient way to experiment with Rust, run code snippets, and familiarize yourself with the language—even if you haven't installed Rust on your system yet.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4-rustc-and-cargo"><a class="header" href="#chapter-4-rustc-and-cargo">Chapter 4: Rustc and Cargo</a></h1>
<p>When writing and compiling Rust code, you have several tools at your disposal, depending on your preferred workflow and environment. Popular Integrated Development Environments (IDEs) like <strong>VSCode</strong> or editors written in Rust, such as <strong>Helix</strong> and <strong>Lapce</strong>, are widely used for Rust development. These tools often integrate with <strong>rust-analyzer</strong>, a powerful extension providing features like code completion, real-time syntax checking, and navigation aids. You can also choose to use any other text editor of your choice, as Rust is highly flexible regarding development environments.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="41-compiling-with-rustc"><a class="header" href="#41-compiling-with-rustc">4.1 Compiling with Rustc</a></h2>
<p>The Rust compiler, <code>rustc</code>, is the fundamental tool for compiling Rust programs. To compile a single Rust source file, you can run the following command in your terminal:</p>
<pre><code class="language-bash">rustc main.rs
</code></pre>
<p>This command will compile the file <code>main.rs</code> into an executable. You can then run the executable directly from the command line. While this method works well for small, simple projects, managing more complex projects with multiple files and dependencies becomes cumbersome without a dedicated build system.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="42-introduction-to-cargo"><a class="header" href="#42-introduction-to-cargo">4.2 Introduction to Cargo</a></h2>
<p>Rather than using <code>rustc</code> directly for each file, most Rust developers rely on <strong>Cargo</strong>, Rust’s package manager and build system. Cargo simplifies various aspects of project management, including compiling code, running tests, handling dependencies, and building for different configurations. With Cargo, developers seldom need to interact with <code>rustc</code> directly, as Cargo automates most of the tasks.</p>
<h3 id="421-creating-a-new-project-with-cargo"><a class="header" href="#421-creating-a-new-project-with-cargo">4.2.1 Creating a New Project with Cargo</a></h3>
<p>To create a new Rust project using Cargo, you can run the following command:</p>
<pre><code class="language-bash">cargo new my_project
</code></pre>
<p>This command creates a new directory called <code>my_project</code> with the following structure:</p>
<pre><code>my_project
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<ul>
<li><strong>Cargo.toml</strong>: This manifest file contains project metadata, including the project name, version, and dependencies.</li>
<li><strong>src/main.rs</strong>: This is where your Rust code resides. Cargo automatically sets up this structure, so you can begin coding immediately.</li>
</ul>
<h3 id="422-compiling-and-running-a-program-with-cargo"><a class="header" href="#422-compiling-and-running-a-program-with-cargo">4.2.2 Compiling and Running a Program with Cargo</a></h3>
<p>Once your project is set up, you can compile it with the following command:</p>
<pre><code class="language-bash">cargo build
</code></pre>
<p>This will compile the project and store the resulting binary in the <code>target/debug</code> directory. If you want to build your project for release with optimizations, you can use the following command:</p>
<pre><code class="language-bash">cargo build --release
</code></pre>
<p>To compile and run your program in a single step, you can use:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>This command both compiles your project and executes the resulting binary, providing a streamlined workflow during development.</p>
<h3 id="423-managing-dependencies"><a class="header" href="#423-managing-dependencies">4.2.3 Managing Dependencies</a></h3>
<p>One of Cargo's key features is managing project dependencies. Dependencies are defined in the <code>Cargo.toml</code> file. For instance, to add the <code>rand</code> crate (a popular library for generating random numbers), you would include the following in your <code>Cargo.toml</code> file:</p>
<pre><code class="language-toml">[dependencies]
rand = "0.8"
</code></pre>
<p>When you run <code>cargo build</code>, Cargo will automatically download and compile the <code>rand</code> crate and any other dependencies specified, including all of their transitive dependencies.</p>
<p>You can also add a dependency using the <code>cargo add</code> command, which updates <code>Cargo.toml</code> for you:</p>
<pre><code class="language-bash">cargo add rand
</code></pre>
<h3 id="424-the-role-of-cargotoml"><a class="header" href="#424-the-role-of-cargotoml">4.2.4 The Role of Cargo.toml</a></h3>
<p>The <strong>Cargo.toml</strong> file is essential to every Cargo project. It contains key information about the project, including:</p>
<ul>
<li><strong>[package]</strong>: Defines metadata such as the project name, version, and authors.</li>
<li><strong>[dependencies]</strong>: Specifies the external crates that your project relies on.</li>
<li><strong>[dev-dependencies]</strong>: Lists dependencies needed only during development and testing.</li>
</ul>
<p>Cargo uses this file to manage the build process and ensure that the correct versions of dependencies are included during compilation.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="43-further-resources"><a class="header" href="#43-further-resources">4.3 Further Resources</a></h2>
<p>This chapter provided an introduction to <code>rustc</code> and Cargo, but there is much more to explore. The official Rust website offers extensive documentation on both tools. For more detailed guidance, refer to the following resources:</p>
<ul>
<li><a href="https://www.rust-lang.org/learn">Rust Documentation</a></li>
<li><a href="https://doc.rust-lang.org/cargo/">Cargo Documentation</a></li>
</ul>
<p>Cargo is a powerful and versatile tool that streamlines project management in Rust, making it easy to handle dependencies, compile code, and manage development workflows. With the basics covered here, you should be ready to start building and managing Rust projects effectively.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5-common-programming-concepts"><a class="header" href="#chapter-5-common-programming-concepts">Chapter 5: Common Programming Concepts</a></h1>
<p>In this chapter, we will explore fundamental programming concepts that are shared across most programming languages, including Rust. These concepts serve as the foundation for software development, regardless of the language you use. We'll begin by examining the role of <strong>keywords</strong> in structuring and defining the behavior of a program. From there, we'll cover important topics such as <strong>data types</strong> and <strong>variables</strong>, which allow us to manage data efficiently. Additionally, we’ll delve into <strong>expressions and statements</strong>, discuss how Rust handles <strong>operators</strong>, and explore <strong>numeric literals</strong>. We'll also examine how Rust handles <strong>arithmetic overflow</strong> and consider the <strong>performance characteristics</strong> of numeric types.</p>
<p>These core concepts are essential for writing functional programs, and while their implementation may vary between languages, their purpose remains largely the same. This chapter will help you understand how these fundamentals are applied in Rust and how they compare to other languages like C, establishing a solid foundation for understanding Rust's unique features.</p>
<p>While topics like conditional code execution with <code>if</code> statements, loops, and functions might also be part of this chapter, we will first discuss Rust's memory management through ownership and borrowing before addressing control flow and structuring code with functions and modules in later chapters. This approach makes sense because functions in Rust often involve borrowing or copying data used as arguments, so it’s best to cover them in detail after memory management has been introduced. Additionally, important topics such as the <code>struct</code> data type and dynamic types like vectors and strings will also be discussed in their own dedicated chapters.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="51-keywords"><a class="header" href="#51-keywords">5.1 Keywords</a></h2>
<p>Keywords are an integral part of any programming language, including Rust. They are reserved words that have a specific meaning to the compiler and cannot be used for variable names, function names, or any other identifiers in your programs. Keywords define the structure and behavior of your code, from flow control to data declarations and memory management.</p>
<p>Rust has a unique set of keywords that you’ll see frequently as you write Rust programs. Some of these keywords will look familiar if you come from a C or C++ background, while others might be new. It’s important to understand that while Rust shares some similarities with C, it also introduces concepts that are specific to memory safety and concurrency, which are reflected in its keyword set.</p>
<p>Additionally, Rust provides a special feature called <strong>raw identifiers</strong>, which allow you to use keywords as regular identifiers by prefixing them with <code>r#</code>. This is particularly useful when interfacing with C code, where certain keywords may conflict with variable names or function names from other languages. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r#struct = 5;
// 'struct' is a keyword in Rust, but here it's used as a regular variable name
println!("The value is {}", r#struct);
<span class="boring">}</span></code></pre></pre>
<p>Below, we’ll list the Rust keywords that are currently in use, along with a separate list of reserved keywords that may be used in the future. We’ll also draw comparisons to C and C++ where relevant.</p>
<h3 id="511-rust-keywords"><a class="header" href="#511-rust-keywords">5.1.1 Rust Keywords</a></h3>
<div class="table-wrapper"><table><thead><tr><th><strong>Keyword</strong></th><th><strong>Description</strong></th><th><strong>C/C++ Equivalent</strong></th></tr></thead><tbody>
<tr><td><code>as</code></td><td>Type casting or renaming imports</td><td><code>typedef</code>, <code>as</code> in C++</td></tr>
<tr><td><code>async</code></td><td>Defines asynchronous functions</td><td>None (C++20 has <code>co_await</code>)</td></tr>
<tr><td><code>await</code></td><td>Awaits the result of an asynchronous operation</td><td>None (C++20 <code>co_await</code>)</td></tr>
<tr><td><code>break</code></td><td>Exits loops or blocks early</td><td><code>break</code></td></tr>
<tr><td><code>const</code></td><td>Defines a constant value</td><td><code>const</code></td></tr>
<tr><td><code>continue</code></td><td>Skips the rest of the loop iteration</td><td><code>continue</code></td></tr>
<tr><td><code>crate</code></td><td>Refers to the current crate/module</td><td>None</td></tr>
<tr><td><code>else</code></td><td>Follows an <code>if</code> block with an alternative branch</td><td><code>else</code></td></tr>
<tr><td><code>enum</code></td><td>Defines an enumeration</td><td><code>enum</code></td></tr>
<tr><td><code>extern</code></td><td>Declares external language functions or data</td><td><code>extern</code></td></tr>
<tr><td><code>false</code></td><td>Boolean false literal</td><td><code>false</code></td></tr>
<tr><td><code>fn</code></td><td>Defines a function</td><td><code>void</code>, <code>int</code>, etc. in C</td></tr>
<tr><td><code>for</code></td><td>Defines a loop over iterators</td><td><code>for</code></td></tr>
<tr><td><code>if</code></td><td>Conditional code execution</td><td><code>if</code></td></tr>
<tr><td><code>impl</code></td><td>Defines implementations for traits or types</td><td>None</td></tr>
<tr><td><code>in</code></td><td>Used in <code>for</code> loop to iterate over elements</td><td>(C++ <code>range-for</code>)</td></tr>
<tr><td><code>let</code></td><td>Defines a variable</td><td>No direct equivalent</td></tr>
<tr><td><code>loop</code></td><td>Creates an infinite loop</td><td><code>while (true)</code></td></tr>
<tr><td><code>match</code></td><td>Pattern matching</td><td><code>switch</code> in C/C++</td></tr>
<tr><td><code>mod</code></td><td>Declares a module</td><td>None</td></tr>
<tr><td><code>move</code></td><td>Forces closure to take ownership of variables</td><td>None</td></tr>
<tr><td><code>mut</code></td><td>Declares a mutable variable</td><td>No direct equivalent</td></tr>
<tr><td><code>pub</code></td><td>Makes an item public (visibility modifier)</td><td><code>public</code> in C++</td></tr>
<tr><td><code>ref</code></td><td>Refers to a reference in pattern matching</td><td>C++ <code>&amp;</code> (reference types)</td></tr>
<tr><td><code>return</code></td><td>Exits from a function with a value</td><td><code>return</code></td></tr>
<tr><td><code>self</code></td><td>Refers to the current instance of an object or module</td><td>C++ <code>this</code></td></tr>
<tr><td><code>static</code></td><td>Declares a static variable or lifetime</td><td><code>static</code></td></tr>
<tr><td><code>struct</code></td><td>Defines a structure</td><td><code>struct</code></td></tr>
<tr><td><code>trait</code></td><td>Defines a trait (similar to interfaces)</td><td>C++ abstract classes</td></tr>
<tr><td><code>true</code></td><td>Boolean true literal</td><td><code>true</code></td></tr>
<tr><td><code>type</code></td><td>Defines an alias or associated type</td><td><code>typedef</code></td></tr>
<tr><td><code>unsafe</code></td><td>Allows code that bypasses Rust’s safety checks</td><td>None (unsafe C inherently)</td></tr>
<tr><td><code>use</code></td><td>Brings items into scope from other modules</td><td><code>#include</code>, <code>using</code> in C++</td></tr>
<tr><td><code>where</code></td><td>Specifies conditions for generics</td><td>None</td></tr>
<tr><td><code>while</code></td><td>Defines a loop with a condition</td><td><code>while</code></td></tr>
</tbody></table>
</div>
<h3 id="512-reserved-keywords-for-future-use"><a class="header" href="#512-reserved-keywords-for-future-use">5.1.2 Reserved Keywords (For Future Use)</a></h3>
<p>Rust also reserves certain keywords that aren’t currently in use but may be added in future language versions. These cannot be used as identifiers even though they have no current functionality.</p>
<div class="table-wrapper"><table><thead><tr><th><strong>Reserved Keyword</strong></th><th><strong>C/C++ Equivalent</strong></th></tr></thead><tbody>
<tr><td><code>abstract</code></td><td><code>abstract</code> (C++)</td></tr>
<tr><td><code>become</code></td><td>None</td></tr>
<tr><td><code>box</code></td><td>None</td></tr>
<tr><td><code>do</code></td><td><code>do</code> (C)</td></tr>
<tr><td><code>final</code></td><td><code>final</code> (C++)</td></tr>
<tr><td><code>macro</code></td><td>None</td></tr>
<tr><td><code>override</code></td><td><code>override</code> (C++)</td></tr>
<tr><td><code>priv</code></td><td><code>private</code> (C++)</td></tr>
<tr><td><code>try</code></td><td><code>try</code> (C++)</td></tr>
<tr><td><code>typeof</code></td><td><code>typeof</code> (C++)</td></tr>
<tr><td><code>unsized</code></td><td>None</td></tr>
<tr><td><code>virtual</code></td><td><code>virtual</code> (C++)</td></tr>
<tr><td><code>yield</code></td><td><code>yield</code> (C++)</td></tr>
</tbody></table>
</div>
<h3 id="513-comparison-to-cc"><a class="header" href="#513-comparison-to-cc">5.1.3 Comparison to C/C++</a></h3>
<p>In many cases, Rust keywords will look familiar to those coming from C or C++. For example, <code>if</code>, <code>else</code>, <code>while</code>, <code>for</code>, and <code>return</code> function much as they do in C. However, Rust introduces new concepts that have no direct equivalent in C/C++, such as <code>async</code>, <code>await</code>, <code>match</code>, <code>trait</code>, and <code>unsafe</code>. These keywords reflect Rust’s design priorities around safety, concurrency, and pattern matching.</p>
<p>One of the most significant differences is Rust’s concept of <strong>ownership</strong> and the associated keywords like <code>mut</code>, <code>move</code>, and <code>ref</code>, which are designed to ensure memory safety at compile time. In C and C++, memory management is largely manual and prone to errors, whereas Rust’s keywords enforce strict borrowing rules to avoid issues like dangling pointers or data races.</p>
<p>Understanding the set of keywords in Rust is key to mastering the language and writing safe, efficient, and expressive code.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="52-expressions-and-statements"><a class="header" href="#52-expressions-and-statements">5.2 Expressions and Statements</a></h2>
<p>Before diving into variables and data types, it's important to understand how Rust distinguishes between <strong>expressions</strong> and <strong>statements</strong>, a concept that differs slightly from C and C++.</p>
<h3 id="521-expressions"><a class="header" href="#521-expressions">5.2.1 Expressions</a></h3>
<p>An <strong>expression</strong> is a piece of code that evaluates to a value. In Rust, almost everything is an expression, including literals, variable bindings, arithmetic operations, and even control flow constructs like <code>if</code> and <code>match</code>.</p>
<p>Examples of expressions:</p>
<pre><code class="language-rust ignore">5          // A literal expression, evaluates to 5</code></pre>
<pre><code class="language-rust ignore">x + y      // An arithmetic expression</code></pre>
<pre><code class="language-rust ignore">a &gt; b      // A logical expression with a boolean result</code></pre>
<pre><code class="language-rust ignore">if x &gt; y { x } else { y }  // An if expression that returns a value</code></pre>
<p>Note that these three code lines are not terminated with a semicolon, as adding one would convert the expression into a statement.
Expressions by themselves do not form valid Rust code; they must be part of a larger construct, such as being assigned to a variable, passed to a function, or used within a control flow statement.</p>
<h3 id="522-statements"><a class="header" href="#522-statements">5.2.2 Statements</a></h3>
<p>A <strong>statement</strong> is an instruction that performs an action but does not return a value. Statements include variable declarations, assignments, and expression statements (expressions followed by a semicolon).</p>
<p>Examples of statements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut y = 0;
</span>let x = 5;   // A variable declaration statement
y = x + 1;   // An assignment statement
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note: In Rust, assignments are statements that do not return a value, unlike in C where assignments are expressions that return the assigned value. This means you cannot use assignments within expressions in Rust, which prevents certain types of bugs.</p>
</blockquote>
<p>In Rust, the semicolon <code>;</code> is used to turn an expression into a statement by discarding its value. If you omit the semicolon at the end of an expression inside a function or block, it becomes the <strong>return value</strong> of that block.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = {
    let y = 3;
    y + 1  // No semicolon, this expression's value is returned
};
println!("The value of x is: {}", x);  // Outputs: The value of x is: 4
<span class="boring">}</span></code></pre></pre>
<p>Understanding the distinction between expressions and statements is crucial in Rust because it affects how you write functions and control flow constructs.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="53-data-types"><a class="header" href="#53-data-types">5.3 Data Types</a></h2>
<p>Rust is a <strong>statically</strong> and <strong>strongly typed</strong> language, meaning that the type of each variable is known at compile time and cannot change. This ensures both <strong>performance</strong> and <strong>safety</strong>. In statically typed languages like Rust, many errors are caught early at compile time, reducing runtime errors that might otherwise occur in <strong>dynamically typed</strong> languages. Additionally, strong typing enforces that operations on data are well-defined, avoiding unexpected behavior from implicit type conversions common in <strong>weakly typed</strong> languages. These characteristics allow Rust to produce highly efficient machine code, with direct support for many of its types in primitive CPU instructions, leading to predictable performance, especially in systems programming.</p>
<h3 id="531-scalar-types"><a class="header" href="#531-scalar-types">5.3.1 Scalar Types</a></h3>
<p>Rust's <strong>scalar types</strong> are the simplest types, representing single values. They are analogous to the basic types in C, with some notable differences. Rust’s scalar types are categorized as integers, floating-point numbers, booleans, and characters. Here’s how they compare to C types:</p>
<h4 id="integers"><a class="header" href="#integers">Integers</a></h4>
<p>Rust offers a wide range of integer types, both signed and unsigned, similar to C but with stricter definitions of behavior. In C, integer sizes can sometimes be platform-dependent, whereas Rust defines its types clearly, ensuring predictable size and behavior across platforms.</p>
<p>For fixed-size integer types, Rust uses type names that specify both the size and whether the type is signed or unsigned. Signed types begin with <code>i</code>, while unsigned types begin with <code>u</code>, followed by the number of bits they occupy. The available integer types are:</p>
<ul>
<li><code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, and <code>i128</code> for signed integers (ranging from 8-bit to 128-bit).</li>
<li><code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, and <code>u128</code> for unsigned integers.</li>
</ul>
<p>By default, Rust uses the 32-bit signed integer type <code>i32</code> for integer literals if no specific type is annotated. This default strikes a balance between memory usage and performance for most use cases.</p>
<p><strong><code>usize</code> and <code>isize</code></strong>: Rust introduces two integer types that are specifically tied to the <strong>architecture</strong> of the machine. The <code>usize</code> type is an unsigned integer, and the <code>isize</code> type is a signed integer. These types are used in situations where the size of memory addresses is important, such as array indexing and pointer arithmetic. On a 64-bit system, <code>usize</code> and <code>isize</code> are 64 bits wide, while on a 32-bit system, they are 32 bits wide. The actual size is determined by the target architecture of the compiled program. These types are particularly useful in systems programming for tasks that involve memory management or when dealing with collections where the index size is architecture-dependent. Notably, <code>usize</code> is the default type for indexing arrays and other collections in Rust, and you cannot use other integer types like <code>i32</code> for indexing without an explicit cast.</p>
<h4 id="floating-point-numbers"><a class="header" href="#floating-point-numbers">Floating-Point Numbers</a></h4>
<p>Rust follows the IEEE 754 standard for floating-point types, similar to C, but ensures stricter error handling and precision guarantees. Rust also uses clear type names for its floating-point types, which specify the bit size:</p>
<ul>
<li><code>f32</code> for a 32-bit floating-point number.</li>
<li><code>f64</code> for a 64-bit floating-point number (the default).</li>
</ul>
<p>Rust defaults to <code>f64</code> (64-bit) for floating-point numbers, as it provides better precision and is generally optimized for performance on modern processors. The explicit naming of floating-point types helps avoid confusion and ensures consistent behavior across platforms.</p>
<h4 id="booleans-and-characters"><a class="header" href="#booleans-and-characters">Booleans and Characters</a></h4>
<ul>
<li>
<p><strong>Boolean (<code>bool</code>)</strong>: Rust’s boolean type (<code>bool</code>) is always 1 byte in size, even though it represents a value of <code>true</code> or <code>false</code>. While it might seem more efficient to represent a boolean as a single bit, modern CPUs generally operate more efficiently with byte-aligned memory. Using a full byte for a boolean simplifies memory access and allows for faster processing, particularly in situations where the boolean is stored in arrays or structs.</p>
</li>
<li>
<p><strong>Character (<code>char</code>)</strong>: The character type (<code>char</code>) in Rust represents a Unicode scalar value, differing from C’s <code>char</code>, which holds a single byte (ASCII or UTF-8). Rust’s <code>char</code> is 4 bytes, allowing for full Unicode support. This means it can represent characters from virtually any language, including emoji.</p>
</li>
</ul>
<h4 id="scalar-types-table"><a class="header" href="#scalar-types-table">Scalar Types Table</a></h4>
<div class="table-wrapper"><table><thead><tr><th><strong>Rust Type</strong></th><th><strong>Size</strong></th><th><strong>Range</strong></th><th><strong>Equivalent C Type</strong></th><th><strong>Comment</strong></th></tr></thead><tbody>
<tr><td><code>i8</code></td><td>8 bits</td><td>-128 to 127</td><td><code>int8_t</code></td><td>Signed 8-bit integer</td></tr>
<tr><td><code>u8</code></td><td>8 bits</td><td>0 to 255</td><td><code>uint8_t</code></td><td>Unsigned 8-bit integer</td></tr>
<tr><td><code>i16</code></td><td>16 bits</td><td>-32,768 to 32,767</td><td><code>int16_t</code></td><td>Signed 16-bit integer</td></tr>
<tr><td><code>u16</code></td><td>16 bits</td><td>0 to 65,535</td><td><code>uint16_t</code></td><td>Unsigned 16-bit integer</td></tr>
<tr><td><code>i32</code></td><td>32 bits</td><td>-2,147,483,648 to 2,147,483,647</td><td><code>int32_t</code></td><td>Signed 32-bit integer (default integer type)</td></tr>
<tr><td><code>u32</code></td><td>32 bits</td><td>0 to 4,294,967,295</td><td><code>uint32_t</code></td><td>Unsigned 32-bit integer</td></tr>
<tr><td><code>i64</code></td><td>64 bits</td><td>-9,223,372,036,854,775,808 to 9,223,372,036,854,775,807</td><td><code>int64_t</code></td><td>Signed 64-bit integer</td></tr>
<tr><td><code>u64</code></td><td>64 bits</td><td>0 to 18,446,744,073,709,551,615</td><td><code>uint64_t</code></td><td>Unsigned 64-bit integer</td></tr>
<tr><td><code>isize</code></td><td>Platform Dependent</td><td>Varies based on architecture (32-bit or 64-bit)</td><td><code>intptr_t</code></td><td>Signed pointer-sized integer</td></tr>
<tr><td><code>usize</code></td><td>Platform Dependent</td><td>Varies based on architecture (32-bit or 64-bit)</td><td><code>uintptr_t</code></td><td>Unsigned pointer-sized integer</td></tr>
<tr><td><code>f32</code></td><td>32 bits</td><td>~1.4E-45 to ~3.4E+38</td><td><code>float</code></td><td>32-bit floating point, IEEE 754</td></tr>
<tr><td><code>f64</code></td><td>64 bits</td><td>~5E-324 to ~1.8E+308</td><td><code>double</code></td><td>64-bit floating point (default)</td></tr>
<tr><td><code>bool</code></td><td>1 byte</td><td><code>true</code> or <code>false</code></td><td><code>_Bool</code></td><td>Boolean type, always 1 byte</td></tr>
<tr><td><code>char</code></td><td>4 bytes</td><td>Unicode scalar value (0 to 0x10FFFF)</td><td>None (C’s <code>char</code> is 1 byte)</td><td>Represents a Unicode character</td></tr>
</tbody></table>
</div>
<h3 id="532-primitive-compound-types-tuple-and-array"><a class="header" href="#532-primitive-compound-types-tuple-and-array">5.3.2 Primitive Compound Types: Tuple and Array</a></h3>
<p>Rust also provides <strong>compound types</strong>, which allow you to group multiple values into a single type. The two most basic compound types are <strong>tuples</strong> and <strong>arrays</strong>.</p>
<p>Note that "tuple" and "array" are not Rust keywords, meaning they can be used as variable names.</p>
<h3 id="tuple"><a class="header" href="#tuple">Tuple</a></h3>
<p>A <strong>tuple</strong> is a fixed-size collection of values of various types. In Rust, tuples are often used when you want to return multiple values from a function without using a struct. Since tuples may be unfamiliar to those coming from C or other languages that lack this data type, we will explore them in more detail.</p>
<h4 id="tuple-type-syntax"><a class="header" href="#tuple-type-syntax">Tuple Type Syntax</a></h4>
<p>In Rust, a tuple's type is defined by listing the types of its elements within parentheses <code>()</code>, separated by commas. This defines the exact types and the number of elements the tuple will hold.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">(i32, f64, char)</code></pre>
<p>This tuple type consists of three elements:</p>
<ul>
<li>An <code>i32</code> (32-bit signed integer)</li>
<li>An <code>f64</code> (64-bit floating-point number)</li>
<li>A <code>char</code> (Unicode scalar value)</li>
</ul>
<h4 id="tuple-value-syntax"><a class="header" href="#tuple-value-syntax">Tuple Value Syntax</a></h4>
<p>To create a tuple value, you use the same parentheses <code>()</code> and provide the actual values, again separated by commas.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">(500, 6.4, 'x')</code></pre>
<p>This creates a tuple value with:</p>
<ul>
<li>The integer <code>500</code></li>
<li>The floating-point number <code>6.4</code></li>
<li>The character <code>'x'</code></li>
</ul>
<p><strong>Note on Single-Element Tuples and the Unit Type:</strong></p>
<ul>
<li>
<p><strong>Singleton Tuples:</strong> To define a tuple with a single element, include a trailing comma to differentiate it from a value in parentheses.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let single_element_tuple = (5,); // A tuple containing one element
let not_a_tuple = (5);           // Just the value 5 in parentheses
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Unit Type <code>()</code></strong>: The unit type is a special tuple with zero elements, represented by <code>()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unit: () = (); // The unit type
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Functions that don't return a value actually return the unit type <code>()</code>.</li>
</ul>
</li>
</ul>
<h4 id="combining-type-annotation-and-value-assignment"><a class="header" href="#combining-type-annotation-and-value-assignment">Combining Type Annotation and Value Assignment</a></h4>
<p>When declaring a tuple variable with an explicit type and initializing it with values, you write:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tuple: (i32, f64, char) = (500, 6.4, 'x');
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>let tuple:</code></strong> Declares a new variable named <code>tuple</code>.</li>
<li><strong><code>(i32, f64, char)</code></strong> Specifies the tuple's type.</li>
<li><strong><code>=</code></strong> Assigns the value to the variable.</li>
<li><strong><code>(500, 6.4, 'x')</code></strong> Provides the tuple's initial values.</li>
</ul>
<p>This line tells Rust to create a variable <code>tuple</code> that holds a tuple of type <code>(i32, f64, char)</code> initialized with the values <code>(500, 6.4, 'x')</code>. In this example, the tuple is initialized with constant values, but it is more common to use values evaluated at runtime.</p>
<h4 id="accessing-tuple-elements"><a class="header" href="#accessing-tuple-elements">Accessing Tuple Elements</a></h4>
<p>Accessing individual elements of a tuple is done using dot notation followed by the index of the element, starting from zero. However, tuples can <strong>only</strong> be indexed using <strong>constants known at compile time</strong>. You cannot dynamically loop over a tuple’s components by index because each element may be of a different type.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let tuple: (i32, f64, char) = (500, 6.4, 'x');
</span>let first_element = tuple.0; // Accesses the first element (500)
let second_element = tuple.1; // Accesses the second element (6.4)
let third_element = tuple.2; // Accesses the third element ('x')
<span class="boring">}</span></code></pre></pre>
<h4 id="mutability-and-assignment-of-tuple-elements"><a class="header" href="#mutability-and-assignment-of-tuple-elements">Mutability and Assignment of Tuple Elements</a></h4>
<p>By default, variables in Rust are immutable. If you want to modify the elements of a tuple after its creation, you need to declare it as mutable using the <code>mut</code> keyword.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut tuple = (500, 6.4, 'x');
tuple.0 = 600; // Changes the first element to 600
<span class="boring">}</span></code></pre></pre>
<p><strong>Important Notes:</strong></p>
<ul>
<li>
<p><strong>Fixed Size and Types:</strong> Tuples have a fixed size, and their types are known at compile time. You cannot add or remove elements once the tuple is created.</p>
</li>
<li>
<p><strong>Assignment at Creation:</strong> You must provide all the values for the tuple when you create it. You cannot declare an empty tuple and fill in its elements later.</p>
<p><strong>This will NOT work:</strong></p>
<pre><code class="language-rust ignore">// Attempting to declare an uninitialized tuple (Not allowed)
let mut tuple: (i32, f64, char);
tuple.0 = 500; // Error: tuple is not initialized</code></pre>
</li>
<li>
<p><strong>Assignment Step by Step:</strong> Rust does not allow assigning to individual tuple elements to build up the tuple after declaration without initial values.</p>
</li>
</ul>
<h4 id="destructuring-tuples"><a class="header" href="#destructuring-tuples">Destructuring Tuples</a></h4>
<p>It’s not possible to loop through a tuple’s elements by index, but you can unpack or "destructure" a tuple into individual variables for easier access.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let tuple: (i32, f64, char) = (500, 6.4, 'x');
</span>let (x, y, z) = tuple;
println!("x = {}, y = {}, z = {}", x, y, z);
<span class="boring">}</span></code></pre></pre>
<p>This assigns:</p>
<ul>
<li><code>x</code> to <code>tuple.0</code> (500)</li>
<li><code>y</code> to <code>tuple.1</code> (6.4)</li>
<li><code>z</code> to <code>tuple.2</code> ('x')</li>
</ul>
<h4 id="memory-layout-of-tuples"><a class="header" href="#memory-layout-of-tuples">Memory Layout of Tuples</a></h4>
<ul>
<li>Contiguous Memory: Tuples in Rust are stored contiguously in memory, meaning that all the elements of the tuple are laid out sequentially in a single block of memory.</li>
<li>Element Order: The elements are stored in the order they are defined in the tuple.</li>
<li>Alignment and Padding: Due to differing sizes and alignment requirements of the elements, there may be padding bytes inserted between elements to satisfy alignment constraints. This can lead to the tuple occupying more memory than the simple sum of the sizes of its elements.</li>
</ul>
<h4 id="tuples-in-functions"><a class="header" href="#tuples-in-functions">Tuples in Functions</a></h4>
<p>Tuples are often used to return multiple values from a function.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn calculate(x: i32, y: i32) -&gt; (i32, i32) {
    (x + y, x * y)
}

let (sum, product) = calculate(5, 10);
println!("Sum = {}, Product = {}", sum, product);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The <code>calculate</code> function returns a tuple containing the sum and product of two numbers.</li>
<li>Destructuring is used to unpack the returned tuple.</li>
</ul>
<p>Functions will be covered in full detail in a later chapter.</p>
<h4 id="comparison-to-c"><a class="header" href="#comparison-to-c">Comparison to C</a></h4>
<p>In C, you might use <code>structs</code> to group different types together. However, structs in C require you to define a new type with named fields, whereas Rust's tuples are anonymous and access their elements by position.</p>
<p><strong>C Struct Example:</strong></p>
<pre><code class="language-c">struct Tuple {
    int a;
    double b;
    char c;
};

struct Tuple tuple = {500, 6.4, 'x'};
</code></pre>
<p>In C, you can assign to the fields individually after declaration because the struct has named fields.</p>
<p><strong>Rust Equivalent with Structs:</strong></p>
<p>If you need similar functionality in Rust (e.g., assigning values to fields individually), you might define a struct.</p>
<p><strong>Rust Struct Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TupleStruct {
    a: i32,
    b: f64,
    c: char,
}

let mut tuple = TupleStruct { a: 0, b: 0.0, c: '\0' };
tuple.a = 500;
tuple.b = 6.4;
tuple.c = 'x';
<span class="boring">}</span></code></pre></pre>
<p>We will cover the Rust struct type in greater detail in a later chapter.</p>
<h4 id="when-to-use-tuples-vs-structs"><a class="header" href="#when-to-use-tuples-vs-structs">When to Use Tuples vs. Structs</a></h4>
<ul>
<li>
<p><strong>Tuples:</strong> Best when you have a small, fixed set of elements with different types and you don't need to refer to the elements by name.</p>
</li>
<li>
<p><strong>Structs:</strong> Preferable when you need to:</p>
<ul>
<li>Assign or modify fields individually after creation.</li>
<li>Access elements by names for clarity.</li>
<li>Have more complex data structures.</li>
</ul>
</li>
</ul>
<h4 id="traits-implemented-by-tuples"><a class="header" href="#traits-implemented-by-tuples">Traits Implemented by Tuples</a></h4>
<p>Tuples implement several traits if their component types implement them. For example, if all elements implement the <code>Copy</code> trait, the tuple will also implement <code>Copy</code>.
This is useful when you need to copy tuples without moving ownership.</p>
<p>The next chapter will cover ownership, references, borrowing, and move semantics, while Rust's traits will be discussed later.</p>
<h4 id="summary"><a class="header" href="#summary">Summary</a></h4>
<ul>
<li>
<p><strong>Tuple Type Syntax:</strong> <code>(Type1, Type2, Type3)</code></p>
</li>
<li>
<p><strong>Tuple Value Syntax:</strong> <code>(value1, value2, value3)</code></p>
</li>
<li>
<p><strong>Declaration and Initialization:</strong> Must provide all elements at creation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tuple: (i32, f64, char) = (500, 6.4, 'x');
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Mutability:</strong> Use <code>mut</code> to make the tuple mutable if you need to modify its elements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut tuple = (500, 6.4, 'x');
tuple.0 = 600;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Accessing Elements:</strong> Use dot notation with the index.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut tuple = (500, 6.4, 'x');
</span>let value = tuple.1; // Accesses the second element
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Destructuring:</strong> Unpack the tuple into variables.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut tuple = (500, 6.4, 'x');
</span>let (a, b, c) = tuple;
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Fixed Size and Types:</strong> Cannot change the size or types of a tuple after creation.</p>
</li>
</ul>
<h4 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h4>
<p>In Rust, tuples are a simple way to group a few values with different types.</p>
<h3 id="array"><a class="header" href="#array">Array</a></h3>
<p>An <strong>array</strong> in Rust is a fixed-size collection of elements of the same type, much like an array in C. Arrays are stored on the stack and are ideal when you know the size at compile time. Rust arrays are more strict than C arrays, enforcing bounds checking at runtime, which prevents out-of-bounds memory access, a common source of bugs in C.</p>
<h4 id="array-type-and-initialization-syntax"><a class="header" href="#array-type-and-initialization-syntax">Array Type and Initialization Syntax</a></h4>
<p>In Rust, you declare an array's type using square brackets <code>[]</code>, specifying the element type and the array's length.</p>
<p><strong>Syntax:</strong></p>
<pre><code class="language-rust ignore">let array: [Type; Length] = [value1, value2, value3, ...];</code></pre>
<ul>
<li><strong><code>[Type; Length]</code></strong>: Specifies an array of elements of <code>Type</code> with a fixed <code>Length</code>.</li>
<li><strong><code>[value1, value2, value3, ...]</code></strong>: Provides the initial values for the array elements.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [i32; 3] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>[i32; 3]</code></strong>: An array of <code>i32</code> integers with 3 elements.</li>
<li><strong><code>[1, 2, 3]</code></strong>: Initializes the array with values <code>1</code>, <code>2</code>, and <code>3</code>.</li>
</ul>
<h4 id="arrays-with-arbitrary-values"><a class="header" href="#arrays-with-arbitrary-values">Arrays with Arbitrary Values</a></h4>
<p>In Rust, arrays can be initialized with values that are the result of expressions, not just literals or constants.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x * 2;
let array: [i32; 3] = [x, y, x + y];
<span class="boring">}</span></code></pre></pre>
<p>This demonstrates that you can use any valid expression to initialize the elements of an array, providing flexibility in how you construct arrays.</p>
<h4 id="initializing-arrays-with-default-values"><a class="header" href="#initializing-arrays-with-default-values">Initializing Arrays with Default Values</a></h4>
<p>You can initialize an array where all elements have the same value using the following syntax:</p>
<pre><code class="language-rust ignore">let array = [initial_value; array_length];</code></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let zeros = [0; 5]; // Creates an array [0, 0, 0, 0, 0]
<span class="boring">}</span></code></pre></pre>
<p>This is particularly useful when you need an array filled with a default value.</p>
<h4 id="type-inference-and-initialization"><a class="header" href="#type-inference-and-initialization">Type Inference and Initialization</a></h4>
<p>Rust often allows you to omit the type annotation if it can infer the type from the context.</p>
<p><strong>Example with Type Inference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Rust infers that <code>array</code> is of type <code>[i32; 3]</code> because all elements are <code>i32</code> literals and there are three of them.</li>
</ul>
<p>Alternatively, you could use type inference in combination with an explicit type for one of the elements:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1u8, 2, 3];
<span class="boring">}</span></code></pre></pre>
<h4 id="accessing-array-elements"><a class="header" href="#accessing-array-elements">Accessing Array Elements</a></h4>
<p>To access elements of an array, you use indexing using square brackets <code>[]</code> with the index of the element, starting from zero. Arrays can be indexed by either <strong>compile-time constants</strong> or <strong>runtime-evaluated values</strong>, as long as the index is of type <code>usize</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [i32; 3] = [1, 2, 3];
let index = 1;
let second = array[index];
println!("Second element is {}", second);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Indexing starts at <code>0</code>, as in C.</li>
<li>Indices must be of type <code>usize</code>.</li>
</ul>
<h4 id="bounds-checking"><a class="header" href="#bounds-checking">Bounds Checking</a></h4>
<p>Unlike C, Rust performs <strong>runtime bounds checking</strong> on array accesses. If you attempt to access an index outside the array's bounds, Rust will panic and safely abort the program, preventing undefined behavior.</p>
<p><strong>Example of Out-of-Bounds Access:</strong></p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];
let i = 3; // Content of variable i is evaluated at runtime
let invalid = array[i]; // Panics at runtime: index out of bounds
<span class="boring">}</span></code></pre></pre>
<p>To safely handle potential out-of-bounds access, you can use the <code>get</code> method, which returns an <code>Option&lt;&amp;T&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(value) = array.get(3) {
    println!("Value: {}", value);
} else {
    println!("Index out of bounds");
}
<span class="boring">}</span></code></pre></pre>
<h4 id="iterating-over-arrays"><a class="header" href="#iterating-over-arrays">Iterating Over Arrays</a></h4>
<p>You can iterate over arrays using loops.</p>
<p><strong>Using a <code>for</code> Loop:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3];

for element in array.iter() {
    println!("Element: {}", element);
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>array.iter()</code></strong>: Returns an iterator over the array's elements.</li>
</ul>
<p><strong>Using Indices:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let array = [1, 2, 3];
</span>for i in 0..array.len() {
    println!("Element {}: {}", i, array[i]);
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>0..array.len()</code></strong>: Creates a range from <code>0</code> up to (but not including) <code>array.len()</code>.</li>
<li><strong><code>array.len()</code></strong>: Returns the number of elements in the array.</li>
</ul>
<h4 id="memory-layout-of-arrays"><a class="header" href="#memory-layout-of-arrays">Memory Layout of Arrays</a></h4>
<ul>
<li>Homogeneous Elements: Arrays contain elements of the same type, size, and alignment.</li>
<li>Contiguous Memory: Stored in a single contiguous block without padding between elements (since all elements have the same alignment).</li>
<li>Predictable Layout: Memory layout is straightforward because each element follows the previous one without any padding.</li>
</ul>
<h4 id="arrays-in-functions"><a class="header" href="#arrays-in-functions">Arrays in Functions</a></h4>
<p>Arrays can be passed to functions, but since the size is part of the array's type, it's often more flexible to use slices.</p>
<p><strong>Example Using a Slice:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sum(array: &amp;[i32]) -&gt; i32 {
    array.iter().sum()
}

let array = [1, 2, 3];
let total = sum(&amp;array);
println!("Total sum is {}", total);
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Slices allow functions to accept arrays of any size, as long as the element type matches.</li>
</ul>
<h4 id="slices"><a class="header" href="#slices">Slices</a></h4>
<p>A <strong>slice</strong> is a view into a block of memory represented as a pointer and a length. Slices can be used to reference a portion of an array or vector.</p>
<p><strong>Example of Creating a Slice from an Array:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array = [1, 2, 3, 4, 5];
let slice = &amp;array[1..4]; // Slice containing elements [2, 3, 4]
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Slices are similar to pointers in C but include length information, enhancing safety.</li>
</ul>
<p>Slices and the use of the ampersand (<code>&amp;</code>) to denote references will be explored in greater detail in the next chapter of the book.</p>
<h4 id="mutable-arrays"><a class="header" href="#mutable-arrays">Mutable Arrays</a></h4>
<p>By default, variables in Rust are immutable. To modify the contents of an array, declare it as mutable using the <code>mut</code> keyword.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut array = [1, 2, 3];
array[0] = 10; // Now array is [10, 2, 3]
<span class="boring">}</span></code></pre></pre>
<h4 id="arrays-with-const-length"><a class="header" href="#arrays-with-const-length">Arrays with <code>const</code> Length</a></h4>
<p>The length of an array in Rust must be a constant value known at compile time.</p>
<p><strong>Example with Constant Length:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const SIZE: usize = 3;
let array: [i32; SIZE] = [1, 2, 3];
<span class="boring">}</span></code></pre></pre>
<h4 id="multidimensional-arrays"><a class="header" href="#multidimensional-arrays">Multidimensional Arrays</a></h4>
<p>Rust supports multidimensional arrays by nesting arrays within arrays.</p>
<p><strong>Example of a 2D Array:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let matrix: [[i32; 3]; 2] = [
    [1, 2, 3],
    [4, 5, 6],
];
<span class="boring">}</span></code></pre></pre>
<ul>
<li>This creates a 2x3 matrix (2 rows, 3 columns).</li>
</ul>
<h4 id="traits-implemented-by-arrays"><a class="header" href="#traits-implemented-by-arrays">Traits Implemented by Arrays</a></h4>
<p>Arrays implement several traits if their element types implement them. For example, if the elements implement <code>Copy</code>, the array will also implement <code>Copy</code>.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn duplicate(array: [i32; 3]) -&gt; [i32; 3] {
    array // Copies the array because i32 implements Copy
}
<span class="boring">}</span></code></pre></pre>
<p>This allows arrays to be copied by value, similar to how structs can derive the <code>Copy</code> trait.</p>
<h4 id="comparing-rust-and-c-arrays"><a class="header" href="#comparing-rust-and-c-arrays">Comparing Rust and C Arrays</a></h4>
<ul>
<li><strong>Fixed Size:</strong> Both Rust and C arrays have a fixed size known at compile time.</li>
<li><strong>Type Safety:</strong> Rust arrays are type-safe; all elements must be of the same type.</li>
<li><strong>Bounds Checking:</strong> Rust performs bounds checking at runtime, preventing out-of-bounds memory access—a common issue in C.</li>
<li><strong>Memory Location:</strong> Rust arrays are stored on the stack by default.</li>
<li><strong>Slices:</strong> Rust introduces slices for safe and flexible array access, which is not directly available in C.</li>
</ul>
<h4 id="other-initialization-methods"><a class="header" href="#other-initialization-methods">Other Initialization Methods</a></h4>
<p><strong>Initializing Arrays Without Specifying All Elements:</strong></p>
<p>In Rust, you must initialize all elements of an array. Unlike in C, where uninitialized elements might be set to zero or garbage values, Rust requires explicit initialization.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [i32; 5] = [1, 2, 3, 0, 0];
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Manually specify default values for unspecified elements.</li>
</ul>
<h4 id="summary-1"><a class="header" href="#summary-1">Summary</a></h4>
<ul>
<li><strong>Declaration Syntax:</strong> <code>let array: [Type; Length] = [values];</code></li>
<li><strong>Type Inference:</strong> Rust can infer the type and length based on the values provided.</li>
<li><strong>Initialization with Default Values:</strong> <code>let array = [initial_value; array_length];</code></li>
<li><strong>Accessing Elements:</strong> Use <code>array[index]</code>, where <code>index</code> is of type <code>usize</code>.</li>
<li><strong>Mutability:</strong> Declare with <code>mut</code> if you need to modify elements after creation.</li>
<li><strong>Bounds Checking:</strong> Rust checks array bounds at runtime to prevent invalid access.</li>
<li><strong>Iteration:</strong> Use loops to iterate over elements or indices.</li>
<li><strong>Slices:</strong> Use slices for flexible and safe access to arrays.</li>
</ul>
<h4 id="when-to-use-tuples-arrays-and-vectors"><a class="header" href="#when-to-use-tuples-arrays-and-vectors">When to Use Tuples, Arrays, and Vectors</a></h4>
<p>Rust provides <strong>tuples</strong>, <strong>arrays</strong>, and <strong>vectors</strong> to group multiple values, each serving distinct purposes:</p>
<ul>
<li>
<p><strong>Tuples</strong>: Fixed-size collections that can hold elements of different types. Ideal for grouping a small, fixed number of related values where each position has a specific meaning.</p>
</li>
<li>
<p><strong>Arrays</strong>: Fixed-size collections of elements of the same type. Suitable for handling a known number of homogeneous items, allowing efficient indexed access and iteration.</p>
</li>
<li>
<p><strong>Vectors (<code>Vec&lt;T&gt;</code>)</strong>: Growable arrays stored on the heap. Use when you need a collection of elements of the same type, but the size can change at runtime.</p>
</li>
</ul>
<p><strong>Key Differences:</strong></p>
<ul>
<li>
<p><strong>Homogeneity</strong>:</p>
<ul>
<li><em>Tuples</em>: Heterogeneous elements (different types).</li>
<li><em>Arrays and Vectors</em>: Homogeneous elements (same type).</li>
</ul>
</li>
<li>
<p><strong>Size</strong>:</p>
<ul>
<li><em>Tuples and Arrays</em>: Fixed size known at compile time.</li>
<li><em>Vectors</em>: Dynamic size that can grow or shrink at runtime.</li>
</ul>
</li>
<li>
<p><strong>Usage Scenarios</strong>:</p>
<ul>
<li><em>Tuples</em>: Grouping related values with different types or meanings, like coordinates <code>(x, y)</code>.</li>
<li><em>Arrays</em>: Collections of fixed-size homogeneous data, like days in a week.</li>
<li><em>Vectors</em>: Collections where the number of elements isn't known at compile time or can change, like lines read from a file.</li>
</ul>
</li>
</ul>
<p><strong>Examples:</strong></p>
<ul>
<li>
<p><strong>Tuple</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point = (10.0, 20.0); // x and y coordinates
let (x, y) = point;       // Destructure into variables
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Array</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let weekdays = ["Mon", "Tue", "Wed", "Thu", "Fri"];
for day in weekdays.iter() {
    println!("{}", day);
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Vector</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut numbers = vec![1, 2, 3];
numbers.push(4); // Now numbers is [1, 2, 3, 4]
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p><strong>Choosing the Right Type:</strong></p>
<ul>
<li>Use <strong>tuples</strong> when you have a small, fixed set of values with possibly different types or meanings.</li>
<li>Use <strong>arrays</strong> when you have a fixed-size collection of the same type and need efficient access or iteration.</li>
<li>Use <strong>vectors</strong> when dealing with a collection that can change in size.</li>
</ul>
<h4 id="tuples-or-arrays-as-function-return-types"><a class="header" href="#tuples-or-arrays-as-function-return-types">Tuples or Arrays as Function Return Types</a></h4>
<p>When a function needs to return multiple values, the choice between tuples and arrays depends on the nature of the data:</p>
<ul>
<li>
<p><strong>Tuples</strong> are preferable when:</p>
<ul>
<li>Returning a fixed number of values with distinct meanings.</li>
<li>Each value may represent a different concept, even if they're the same type.</li>
<li>You want to leverage destructuring for clarity.</li>
</ul>
<p><strong>Example: Returning Coordinates</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_coordinates() -&gt; (f64, f64) {
    (10.0, 20.0)
}

let (x, y) = get_coordinates();
println!("x = {}, y = {}", x, y);
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Arrays</strong> are suitable when:</p>
<ul>
<li>Returning a fixed-size collection of homogeneous values.</li>
<li>The elements represent the same kind of data.</li>
<li>You might need to iterate over the elements.</li>
</ul>
<p><strong>Example: Returning a Row of Data</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_row() -&gt; [i32; 3] {
    [1, 2, 3]
}

let row = get_row();
for value in row.iter() {
    println!("{}", value);
}
<span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p><strong>Why Choose Tuples for Coordinates:</strong></p>
<ul>
<li><strong>Semantic Clarity</strong>: Destructuring tuples into variables like <code>x</code> and <code>y</code> makes the code more readable and self-explanatory.</li>
<li><strong>Distinct Meanings</strong>: Even if <code>x</code> and <code>y</code> are the same type, they represent different dimensions.</li>
</ul>
<p><strong>Alternative with Structs:</strong></p>
<p>For enhanced clarity and scalability, especially with more complex data, consider using a <code>struct</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Coordinates {
    x: f64,
    y: f64,
}

fn get_coordinates() -&gt; Coordinates {
    Coordinates { x: 10.0, y: 20.0 }
}

let coords = get_coordinates();
println!("x = {}, y = {}", coords.x, coords.y);
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Advantages</strong>:
<ul>
<li><strong>Named Fields</strong>: Clearly indicate what each value represents.</li>
<li><strong>Extensibility</strong>: Easy to add more fields (e.g., <code>z</code> for 3D coordinates).</li>
<li><strong>Methods</strong>: Ability to implement associated functions or methods.</li>
</ul>
</li>
</ul>
<p><strong>Summary:</strong></p>
<ul>
<li><strong>Use Tuples</strong> when returning multiple values with different meanings or when you want to unpack values into variables with meaningful names.</li>
<li><strong>Use Arrays</strong> when returning a collection of similar items that might be processed collectively.</li>
<li><strong>Use Structs</strong> for even greater clarity and when you might need to expand functionality.</li>
</ul>
<p><strong>Final Recommendation:</strong></p>
<ul>
<li>For returning pairs like coordinates, <strong>tuples</strong> offer a good balance between simplicity and clarity.</li>
<li>For collections of homogeneous data where iteration is needed, <strong>arrays</strong> (or <strong>vectors</strong> if the size is dynamic) are more appropriate.</li>
</ul>
<p>By choosing the most suitable data structure, you enhance code readability, maintainability, and safety, aligning with Rust's emphasis on clarity and reliability.</p>
<blockquote>
<p><strong>Note:</strong> Using very large arrays can cause a stack overflow, as the default stack size is usually limited to a few megabytes and varies depending on the operating system. For large collections, consider using a vector (<code>Vec&lt;T&gt;</code>) instead.</p>
</blockquote>
<h3 id="stack-vs-heap-allocation"><a class="header" href="#stack-vs-heap-allocation">Stack vs. Heap Allocation</a></h3>
<p>Rust's primitive types—scalars, tuples, and arrays—are typically <strong>stack-allocated</strong>, providing fast access due to their predictability and locality. Rust takes advantage of <strong>direct CPU support</strong> for many of these primitive types, optimizing them for performance.</p>
<p>On the other hand, <strong>dynamic types</strong> like vectors (<code>Vec&lt;T&gt;</code>) and dynamically sized strings (<code>String</code>) use <strong>heap allocation</strong> to store their data, allowing for flexible and dynamic resizing at runtime. This heap allocation introduces overhead but is necessary for handling collections of unknown size at compile time.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="54-variables-and-mutability"><a class="header" href="#54-variables-and-mutability">5.4 Variables and Mutability</a></h2>
<p>Variables in programming represent a named space in memory where data can be stored and accessed. They allow you to store values, manipulate them, and retrieve them later in your program. In Rust, every variable has a well-defined <strong>data type</strong>, which is determined when the variable is declared and cannot change afterward.</p>
<h3 id="541-declaring-variables"><a class="header" href="#541-declaring-variables">5.4.1 Declaring Variables</a></h3>
<p>In Rust, variables are declared using the <code>let</code> keyword. By default, variables are <strong>immutable</strong>, meaning once a value is assigned, it cannot be changed. This immutability helps prevent unintended changes to data, improving the safety and reliability of the program.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
println!("The value of x is: {}", x);
<span class="boring">}</span></code></pre></pre>
<p>In this example, <code>x</code> is an immutable variable with the value <code>5</code>. The <code>println!()</code> macro, similar to <code>printf()</code> in C, is used to print values to the terminal window.</p>
<h3 id="542-type-annotations-and-type-inference"><a class="header" href="#542-type-annotations-and-type-inference">5.4.2 Type Annotations and Type Inference</a></h3>
<p>In Rust, you can specify the data type of a variable explicitly using a type annotation, or you can let the compiler infer the type based on the value.</p>
<p><strong>Example with type annotation:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 10;  // Explicitly specifying the type
println!("The value of x is: {}", x);
<span class="boring">}</span></code></pre></pre>
<p><strong>Example with type inference:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let y = 20;  // The compiler infers that y is an i32
println!("The value of y is: {}", y);
<span class="boring">}</span></code></pre></pre>
<p>In the second example, since <code>20</code> is an integer literal, the compiler automatically infers that <code>y</code> has the type <code>i32</code>.</p>
<p>Rust's type inference is highly intelligent and often determines the most appropriate type based on how a variable is used. For example, when an integer variable is used as an array index, Rust may infer the <code>usize</code> type instead of the default <code>i32</code>.</p>
<h3 id="543-mutable-variables"><a class="header" href="#543-mutable-variables">5.4.3 Mutable Variables</a></h3>
<p>If you need a variable whose value can change, you can declare it as mutable using the <code>mut</code> keyword.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">// this example is editable
fn main() {
    let mut z = 30;
    println!("The initial value of z is: {}", z);
    z = 40;
    println!("The new value of z is: {}", z);
}</code></pre></pre>
<p>In this example, <code>z</code> is declared as mutable, allowing its value to be changed from <code>30</code> to <code>40</code>. While mutable variables are useful when values need to change, immutability by default encourages safer, more predictable code.</p>
<h3 id="544-why-immutability-by-default"><a class="header" href="#544-why-immutability-by-default">5.4.4 Why Immutability by Default?</a></h3>
<p>Immutability is the default in Rust because it promotes safety and helps avoid bugs caused by unexpected data changes. Immutable data can also be shared across threads without the need for synchronization, making it safer and more efficient in concurrent programs.</p>
<h3 id="545-constants"><a class="header" href="#545-constants">5.4.5 Constants</a></h3>
<p>Constants in Rust are similar to immutable variables, but they differ in important ways:</p>
<ul>
<li>Constants are declared using the <code>const</code> keyword.</li>
<li>Constants must have their type explicitly stated.</li>
<li>Constants are evaluated at compile time and can be used across the entire program, unlike variables that are initialized at runtime.</li>
<li>Constants can only be set to a constant expression, not the result of a function call or any other runtime computation.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">const MAX_POINTS: u32 = 100_000;
fn main() {
    println!("The maximum points are: {}", MAX_POINTS);
}</code></pre></pre>
<p>Constants are typically used for values that should never change, like configuration parameters or limits. Unlike variables, constants are not part of the program’s runtime memory management, making them very efficient.</p>
<h3 id="546-shadowing-and-re-declaration"><a class="header" href="#546-shadowing-and-re-declaration">5.4.6 Shadowing and Re-declaration</a></h3>
<p>In Rust, you can <strong>redeclare</strong> a variable with the same name using the <code>let</code> keyword, even with a different type. This is called <strong>shadowing</strong>.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let spaces = "   ";
let spaces = spaces.len();
println!("The number of spaces is: {}", spaces);
<span class="boring">}</span></code></pre></pre>
<p>In this example, the variable <code>spaces</code> is first declared as a string, and then it is shadowed to hold an integer representing the length of the string. Shadowing allows you to reuse variable names without mutability and with the flexibility to change types when needed.</p>
<h3 id="547-deferred-initialization"><a class="header" href="#547-deferred-initialization">5.4.7 Deferred Initialization</a></h3>
<p>In Rust, a variable can be declared without an initial value, as long as it is assigned a value before being used. Rust ensures that all variables have well-defined values, preventing bugs caused by uninitialized memory.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a;  // Declare without initialization
a = 42;  // Assign a value later
println!("The value of a is: {}", a);
<span class="boring">}</span></code></pre></pre>
<p>Deferred initialization can be useful when the assigned value depends on a condition, as shown below:</p>
<pre><code class="language-rust ignore">let a;  // Immutable variable declared without initialization
if some_condition {
    a = 42;
} else {
    a = 7;
}</code></pre>
<p>However, in simple cases like this, an <code>if</code> expression could be used instead:</p>
<pre><code class="language-rust ignore">let a = if some_condition {
    42
} else {
    7
};</code></pre>
<p>If you attempt to use a variable before it is initialized, Rust will not compile the code, ensuring that no variable is ever left uninitialized.</p>
<h3 id="548-scopes-and-deallocation"><a class="header" href="#548-scopes-and-deallocation">5.4.8 Scopes and Deallocation</a></h3>
<p>In Rust, variables have a <strong>scope</strong>, which determines where they are valid and when they are dropped (freed). A variable’s scope begins when it is declared and ends when it goes out of scope, typically at the end of a block (e.g., a function or conditional block). Rust also deallocates variables when they are used for the last time, potentially freeing memory earlier than the end of the scope.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let b = 5;
    {
        let c = 10;
        println!("Inside block: b = {}, c = {}", b, c);
    }
    // c is no longer accessible here
    println!("Outside block: b = {}", b);
}</code></pre></pre>
<p>In this example, <code>c</code> goes out of scope when the inner block ends and is deallocated, while <code>b</code> remains accessible outside the block.</p>
<h3 id="549-global-variables-and-constants"><a class="header" href="#549-global-variables-and-constants">5.4.9 Global Variables and Constants</a></h3>
<p>Rust generally avoids the use of global variables because they can lead to bugs and complexity in large programs. However, <strong>global constants</strong> are common practice in Rust and provide a safe way to share values across different parts of the program without risking data corruption.</p>
<p><strong>Example of a global constant:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">const PI: f64 = 3.1415926535;

fn main() {
    println!("The value of PI is: {}", PI);
}</code></pre></pre>
<h3 id="5410-declaring-multiple-entities-with-let-or-const"><a class="header" href="#5410-declaring-multiple-entities-with-let-or-const">5.4.10 Declaring Multiple Entities with <code>let</code> or <code>const</code></a></h3>
<p>In Rust, each variable or constant must be declared with its own <code>let</code> or <code>const</code> statement. However, you can declare multiple variables in a single line by separating the declarations with semicolons or by destructuring a tuple.</p>
<p><strong>Example with semicolons:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5.0; let i = 10;
    println!("x = {}, i = {}", x, i);
}</code></pre></pre>
<p><strong>Example using tuple destructuring:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let (x, i) = (5.0, 10);
    println!("x = {}, i = {}", x, i);
}</code></pre></pre>
<p>This requirement promotes clarity and avoids ambiguity in complex declarations. For constants, each must also be declared individually, ensuring that their types are explicitly defined.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="55-operators"><a class="header" href="#55-operators">5.5 Operators</a></h2>
<p>Operators in Rust allow you to perform operations on variables and values. Rust provides a wide range of operators, including unary, binary, and assignment operators, similar to C and C++. However, there are some key differences, such as the absence of certain operators like <code>++</code> and <code>--</code>. In this section, we will cover Rust’s operators in detail, explain operator precedence, and compare them to those in C/C++. We will also explore how to define custom operators in Rust.</p>
<h3 id="551-unary-operators"><a class="header" href="#551-unary-operators">5.5.1 Unary Operators</a></h3>
<p>Unary operators operate on a single operand. Rust provides the following unary operators:</p>
<ul>
<li><strong>Negation (<code>-</code>)</strong>: Negates the value of a number.
<ul>
<li>Example: <code>-x</code></li>
</ul>
</li>
<li><strong>Logical negation (<code>!</code>)</strong>: Inverts the value of a boolean.
<ul>
<li>Example: <code>!true</code> evaluates to <code>false</code></li>
</ul>
</li>
<li><strong>Dereference (<code>*</code>)</strong>: Dereferences a reference to access the underlying value.
<ul>
<li>Example: <code>*pointer</code></li>
</ul>
</li>
<li><strong>Reference (<code>&amp;</code>)</strong>: Creates a reference to a value.
<ul>
<li>Example: <code>&amp;x</code> creates a reference to <code>x</code>.</li>
</ul>
</li>
</ul>
<p>Example program using unary operators:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() { // editable example
    let x = 5;
    let neg_x = -x;
    let is_false = !true;
    let reference = &amp;x;
    let deref_x = *reference;

    println!("Negation of {} is {}", x, neg_x);
    println!("The opposite of true is {}", is_false);
    println!("Reference to x is: {:?}", reference);
    println!("Dereferenced value is: {}", deref_x);
}</code></pre></pre>
<h3 id="552-binary-operators"><a class="header" href="#552-binary-operators">5.5.2 Binary Operators</a></h3>
<p>Binary operators in Rust work on two operands. These include arithmetic, logical, comparison, and bitwise operators.</p>
<h4 id="arithmetic-operators"><a class="header" href="#arithmetic-operators">Arithmetic Operators</a></h4>
<ul>
<li><strong>Addition (<code>+</code>)</strong>: Adds two values.</li>
<li><strong>Subtraction (<code>-</code>)</strong>: Subtracts the second value from the first.</li>
<li><strong>Multiplication (<code>*</code>)</strong>: Multiplies two values.</li>
<li><strong>Division (<code>/</code>)</strong>: Divides the first value by the second (integer division for integers).</li>
<li><strong>Modulus (<code>%</code>)</strong>: Finds the remainder after division.</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = 10;
    let b = 3;
    let sum = a + b;
    let difference = a - b;
    let product = a * b;
    let quotient = a / b;
    let remainder = a % b;

    println!("{} + {} = {}", a, b, sum);
    println!("{} - {} = {}", a, b, difference);
    println!("{} * {} = {}", a, b, product);
    println!("{} / {} = {}", a, b, quotient);
    println!("{} % {} = {}", a, b, remainder);
}</code></pre></pre>
<p>Note that Rust's binary arithmetic operators generally require both operands to have the same type, meaning expressions like <code>1u8 + 2i32</code> or <code>1.0 + 2</code> are invalid.</p>
<h4 id="comparison-operators"><a class="header" href="#comparison-operators">Comparison Operators</a></h4>
<ul>
<li><strong>Equal to (<code>==</code>)</strong>: Checks if two values are equal.</li>
<li><strong>Not equal to (<code>!=</code>)</strong>: Checks if two values are not equal.</li>
<li><strong>Greater than (<code>&gt;</code>)</strong>: Checks if the first value is greater than the second.</li>
<li><strong>Less than (<code>&lt;</code>)</strong>: Checks if the first value is less than the second.</li>
<li><strong>Greater than or equal to (<code>&gt;=</code>)</strong>: Checks if the first value is greater than or equal to the second.</li>
<li><strong>Less than or equal to (<code>&lt;=</code>)</strong>: Checks if the first value is less than or equal to the second.</li>
</ul>
<p>These operators work on integers, floating-point numbers, and other comparable types.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5;
    let y = 10;

    println!("x == y: {}", x == y);
    println!("x != y: {}", x != y);
    println!("x &lt; y: {}", x &lt; y);
    println!("x &gt; y: {}", x &gt; y);
}</code></pre></pre>
<h4 id="logical-operators"><a class="header" href="#logical-operators">Logical Operators</a></h4>
<ul>
<li><strong>Logical AND (<code>&amp;&amp;</code>)</strong>: Returns <code>true</code> if both operands are <code>true</code>.</li>
<li><strong>Logical OR (<code>||</code>)</strong>: Returns <code>true</code> if at least one operand is <code>true</code>.</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let a = true;
    let b = false;

    println!("a &amp;&amp; b: {}", a &amp;&amp; b);
    println!("a || b: {}", a || b);
}</code></pre></pre>
<h4 id="bitwise-operators"><a class="header" href="#bitwise-operators">Bitwise Operators</a></h4>
<ul>
<li><strong>Bitwise AND (<code>&amp;</code>)</strong>: Performs a bitwise AND operation.</li>
<li><strong>Bitwise OR (<code>|</code>)</strong>: Performs a bitwise OR operation.</li>
<li><strong>Bitwise XOR (<code>^</code>)</strong>: Performs a bitwise XOR operation.</li>
<li><strong>Left shift (<code>&lt;&lt;</code>)</strong>: Shifts the bits of the left operand to the left by the number of positions specified by the right operand.</li>
<li><strong>Right shift (<code>&gt;&gt;</code>)</strong>: Shifts the bits of the left operand to the right by the number of positions specified by the right operand.</li>
</ul>
<p>For <strong>shift operations</strong>, there is a key distinction between signed and unsigned integer types. For <strong>unsigned types</strong>, right shifts fill the leftmost bits with zeros. For <strong>signed types</strong>, right shifts use <em>sign extension</em>, meaning that the leftmost bit (the sign bit) is preserved, which maintains the negative or positive sign of the number.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x: u8 = 2;  // 0000_0010 in binary
    let y: u8 = 3;  // 0000_0011 in binary

    println!("x &amp; y: {}", x &amp; y); // 0000_0010
    println!("x | y: {}", x | y); // 0000_0011
    println!("x ^ y: {}", x ^ y); // 0000_0001
    println!("x &lt;&lt; 1: {}", x &lt;&lt; 1); // 0000_0100
    println!("x &gt;&gt; 1: {}", x &gt;&gt; 1); // 0000_0001

    let z: i8 = -2; // 1111_1110 in binary (signed)
    println!("z &gt;&gt; 1 (signed): {}", z &gt;&gt; 1); // Sign bit is preserved: 1111_1111
}</code></pre></pre>
<h3 id="553-assignment-operators"><a class="header" href="#553-assignment-operators">5.5.3 Assignment Operators</a></h3>
<p>The <strong>assignment operator</strong> in Rust is the equal sign (<code>=</code>), which is used to assign values to variables. Rust also supports compound assignment operators, which combine arithmetic or bitwise operations with assignment:</p>
<ul>
<li><strong>Add and assign (<code>+=</code>)</strong>: <code>x += 1;</code></li>
<li><strong>Subtract and assign (<code>-=</code>)</strong>: <code>x -= 1;</code></li>
<li><strong>Multiply and assign (<code>*=</code>)</strong>: <code>x *= 1;</code></li>
<li><strong>Divide and assign (<code>/=</code>)</strong>: <code>x /= 1;</code></li>
<li><strong>Modulus and assign (<code>%=</code>)</strong>: <code>x %= 1;</code></li>
<li><strong>Bitwise AND and assign (<code>&amp;=</code>)</strong>: <code>x &amp;= y;</code></li>
<li><strong>Bitwise OR and assign (<code>|=</code>)</strong>: <code>x |= y;</code></li>
<li><strong>Bitwise XOR and assign (<code>^=</code>)</strong>: <code>x ^= y;</code></li>
<li><strong>Left shift and assign (<code>&lt;&lt;=</code>)</strong>: <code>x &lt;&lt;= y;</code></li>
<li><strong>Right shift and assign (<code>&gt;&gt;=</code>)</strong>: <code>x &gt;&gt;= y;</code></li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut x = 5;
x += 2;
println!("x after addition: {}", x);
<span class="boring">}</span></code></pre></pre>
<h3 id="554-ternary-operator"><a class="header" href="#554-ternary-operator">5.5.4 Ternary Operator</a></h3>
<p>Rust does <strong>not</strong> have a traditional ternary operator like C's <code>? :</code>. Instead, Rust uses <code>if</code> expressions that can return values, making the ternary operator unnecessary.</p>
<p>Example of an <code>if</code> expression in Rust:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let condition = true;
let result = if condition { 5 } else { 10 };
println!("The result is: {}", result);
<span class="boring">}</span></code></pre></pre>
<h3 id="555-custom-operators-and-operator-overloading"><a class="header" href="#555-custom-operators-and-operator-overloading">5.5.5 Custom Operators and Operator Overloading</a></h3>
<p>Unlike C++, Rust does <strong>not</strong> allow defining new custom operators (e.g., using special Unicode characters). However, Rust does support <strong>operator overloading</strong> through traits. You can implement Rust's built-in traits, like <code>Add</code>, to define custom behavior for existing operators.</p>
<p>Example: Overloading the <code>+</code> operator for a custom type.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::ops::Add;

struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 3, y: 4 };
    let p3 = p1 + p2;  // Uses the overloaded + operator
    println!("p3: x = {}, y = {}", p3.x, p3.y);
}</code></pre></pre>
<p>In this example, the <code>+</code> operator is overloaded for the <code>Point</code> struct by implementing the <code>Add</code> trait. This allows two <code>Point</code> instances to be added using the <code>+</code> operator.</p>
<h3 id="556-operator-precedence"><a class="header" href="#556-operator-precedence">5.5.6 Operator Precedence</a></h3>
<p>Operator precedence in Rust determines the order in which operations are evaluated. Rust’s precedence rules are similar to those in C and C++, with multiplication and division taking precedence over addition and subtraction, and parentheses <code>()</code> being used to control the order of evaluation.</p>
<p>Here is a simplified operator precedence table (from highest to lowest precedence):</p>
<ol>
<li><strong>Method call and field access</strong>: <code>.</code></li>
<li><strong>Function call and array indexing</strong>: <code>()</code> and <code>[]</code></li>
<li><strong>Unary operators</strong>: <code>-</code>, <code>!</code>, <code>*</code>, <code>&amp;</code></li>
<li><strong>Multiplicative</strong>: <code>*</code>, <code>/</code>, <code>%</code></li>
<li><strong>Additive</strong>: <code>+</code>, <code>-</code></li>
<li><strong>Bitwise shifts</strong>: <code>&lt;&lt;</code>, <code>&gt;&gt;</code></li>
<li><strong>Bitwise AND</strong>: <code>&amp;</code></li>
<li><strong>Bitwise XOR</strong>: <code>^</code></li>
<li><strong>Bitwise OR</strong>: <code>|</code></li>
<li><strong>Comparison and equality</strong>: <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></li>
<li><strong>Logical AND</strong>: <code>&amp;&amp;</code></li>
<li><strong>Logical OR</strong>: <code>||</code></li>
<li><strong>Range operators</strong>: <code>..</code>, <code>..=</code></li>
<li><strong>Assignment and compound assignment</strong>: <code>=</code>, <code>+=</code>, <code>-=</code>, etc.</li>
</ol>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let result = 2 + 3 * 4;
println!("Result without parentheses: {}", result);  // Outputs 14
let result_with_parentheses = (2 + 3) * 4;
println!("Result with parentheses: {}", result_with_parentheses);  // Outputs 20
<span class="boring">}</span></code></pre></pre>
<h3 id="557-comparison-with-c-and-c"><a class="header" href="#557-comparison-with-c-and-c">5.5.7 Comparison with C and C++</a></h3>
<p>Rust’s operators are quite similar to those in C and C++. However, Rust lacks the <code>++</code> and <code>--</code> operators, which increment or decrement variables in C/C++. This design decision in Rust prevents unintended side effects and encourages clearer code, requiring you to use <code>+= 1</code> or <code>-= 1</code> explicitly for incrementing or decrementing values.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="56-numeric-literals-and-their-default-type"><a class="header" href="#56-numeric-literals-and-their-default-type">5.6 Numeric Literals and Their Default Type</a></h2>
<p>In Rust, numeric literals are used to define values for different numeric types, such as integers and floating-point numbers. One of the key features of Rust’s type system is that it requires numeric types to be explicitly stated or inferred by the compiler, meaning that every literal is assigned a type either based on the context or its default type.</p>
<h3 id="561-integer-literals"><a class="header" href="#561-integer-literals">5.6.1 Integer Literals</a></h3>
<p>By default, an integer literal without a suffix is inferred as an <code>i32</code>. However, Rust provides several ways to specify a literal’s type explicitly using suffixes, such as:</p>
<ul>
<li><code>123i8</code> for a signed 8-bit integer</li>
<li><code>123u64</code> for an unsigned 64-bit integer</li>
</ul>
<p>You can also use type annotations when declaring a variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 123u16;        // Literal with a suffix
let y: u16 = 123;      // Type annotation
<span class="boring">}</span></code></pre></pre>
<p>Rust supports the use of <strong>underscores</strong> to make large numbers more readable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let large_num = 1_000_000; // Inferred as i32
<span class="boring">}</span></code></pre></pre>
<h3 id="562-floating-point-literals"><a class="header" href="#562-floating-point-literals">5.6.2 Floating-Point Literals</a></h3>
<p>Floating-point literals default to <code>f64</code> for precision and performance reasons. As with integers, the type can be explicitly defined using a suffix, for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let pi = 3.14f32; // 32-bit floating point
let e = 2.718;    // Inferred as f64
<span class="boring">}</span></code></pre></pre>
<p>It's important to note that assigning an integer directly to a floating-point variable, such as <code>let a: f64 = 10;</code>, is invalid in Rust because <code>10</code> is treated as an integer literal. Instead, you must use a floating-point literal, like <code>10.0</code>.</p>
<p>However, floating-point literals can be written without a fractional part. For example, <code>1.</code> is treated as <code>1.0</code>, similar to C:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 1.;  // Equivalent to 1.0
<span class="boring">}</span></code></pre></pre>
<p>Unlike in C, Rust does not allow omitting the digit before the decimal point. Therefore, <code>.7</code> is <strong>not</strong> a valid floating-point literal in Rust. Instead, you must write it as <code>0.7</code>:
This requirement ensures clarity in floating-point literals, avoiding potential confusion in code.</p>
<h3 id="563-hexadecimal-octal-and-binary-literals"><a class="header" href="#563-hexadecimal-octal-and-binary-literals">5.6.3 Hexadecimal, Octal, and Binary Literals</a></h3>
<p>Rust supports other number systems for literals, which can be useful for low-level programming:</p>
<ul>
<li><strong>Hexadecimal</strong>: Prefix with <code>0x</code>
<ul>
<li>Example: <code>let hex = 0xFF;</code></li>
</ul>
</li>
<li><strong>Octal</strong>: Prefix with <code>0o</code>
<ul>
<li>Example: <code>let octal = 0o77;</code></li>
</ul>
</li>
<li><strong>Binary</strong>: Prefix with <code>0b</code>
<ul>
<li>Example: <code>let binary = 0b1010;</code></li>
</ul>
</li>
</ul>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() { // editable example
    let decimal = 255;
    let hex = 0xFF;
    let octal = 0o377;
    let binary = 0b1111_1111;
    let byte = b'A';  // Byte literal

    println!("Decimal: {}", decimal);
    println!("Hexadecimal: {}", hex);
    println!("Octal: {}", octal);
    println!("Binary: {}", binary);
    println!("Byte: {}", byte);
}</code></pre></pre>
<h3 id="564-type-inference"><a class="header" href="#564-type-inference">5.6.4 Type Inference</a></h3>
<p>While Rust allows type inference, it's important to note that certain operations may require explicit type annotations, especially in cases where a literal could be interpreted in multiple ways.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 42;         // Inferred as i32
    let y = 3.14;       // Inferred as f64
    let z = x as f64 + y; // Type casting x to f64
    println!("Result: {}", z);
}</code></pre></pre>
<p>In this example, we cast <code>x</code> to <code>f64</code> to match the type of <code>y</code> for the addition operation.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="57-overflow-for-arithmetic-operations"><a class="header" href="#57-overflow-for-arithmetic-operations">5.7 Overflow for Arithmetic Operations</a></h2>
<p>Handling integer overflow is a critical consideration in systems programming, where incorrect handling can lead to security vulnerabilities or logic errors. Rust takes a different approach compared to languages like C when it comes to handling overflow in arithmetic operations.</p>
<h3 id="571-overflow-behavior-in-debug-mode"><a class="header" href="#571-overflow-behavior-in-debug-mode">5.7.1 Overflow Behavior in Debug Mode</a></h3>
<p>In <strong>debug mode</strong>, Rust detects integer overflows and triggers a <strong>panic</strong> when overflow occurs. This allows developers to catch overflow issues early in the development process.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: u8 = 255;
let y = x + 1; // This will panic in debug mode due to overflow
println!("y = {}", y);
<span class="boring">}</span></code></pre></pre>
<p>Running this code in debug mode results in a panic with a message indicating an attempt to add with overflow.</p>
<h3 id="572-overflow-behavior-in-release-mode"><a class="header" href="#572-overflow-behavior-in-release-mode">5.7.2 Overflow Behavior in Release Mode</a></h3>
<p>In <strong>release mode</strong>, however, Rust performs <strong>two's complement wrapping arithmetic</strong> by default, where numbers wrap around (e.g., <code>255 + 1</code> becomes <code>0</code> for an <code>u8</code>).</p>
<h3 id="573-explicit-overflow-handling"><a class="header" href="#573-explicit-overflow-handling">5.7.3 Explicit Overflow Handling</a></h3>
<p>Rust provides several methods to handle overflow explicitly:</p>
<ul>
<li>
<p><strong>Wrapping Arithmetic</strong>:</p>
<ul>
<li>
<p><strong><code>wrapping_add</code></strong>, <strong><code>wrapping_sub</code></strong>, <strong><code>wrapping_mul</code></strong>, etc.: Performs wrapping arithmetic explicitly.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: u8 = 255;
    let y = x.wrapping_add(1); // y will be 0
    println!("Wrapping add result: {}", y);
}</code></pre></pre>
</li>
</ul>
</li>
<li>
<p><strong>Checked Arithmetic</strong>:</p>
<ul>
<li>
<p><strong><code>checked_add</code></strong>, <strong><code>checked_sub</code></strong>, <strong><code>checked_mul</code></strong>, etc.: Returns <code>Option</code> types (<code>Some(result)</code> or <code>None</code> if overflow occurs), allowing for safe handling of overflows.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: u8 = 255;
    match x.checked_add(1) {
        Some(y) =&gt; println!("Checked add result: {}", y),
        None =&gt; println!("Overflow occurred!"),
    }
}</code></pre></pre>
</li>
</ul>
</li>
<li>
<p><strong>Saturating Arithmetic</strong>:</p>
<ul>
<li>
<p><strong><code>saturating_add</code></strong>, <strong><code>saturating_sub</code></strong>, <strong><code>saturating_mul</code></strong>, etc.: Saturates at the numeric boundaries (e.g., <code>u8::MAX</code> or <code>u8::MIN</code>).</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: u8 = 250;
    let y = x.saturating_add(10); // y will be 255 (u8::MAX)
    println!("Saturating add result: {}", y);
}</code></pre></pre>
</li>
</ul>
</li>
<li>
<p><strong>Overflowing Arithmetic</strong>:</p>
<ul>
<li>
<p><strong><code>overflowing_add</code></strong>, <strong><code>overflowing_sub</code></strong>, <strong><code>overflowing_mul</code></strong>, etc.: Returns a tuple containing the result and a boolean indicating whether overflow occurred.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let x: u8 = 255;
    let (y, overflowed) = x.overflowing_add(1);
    println!("Overflowing add result: {}, overflowed: {}", y, overflowed);
}</code></pre></pre>
</li>
</ul>
</li>
</ul>
<p>By explicitly handling overflow, Rust ensures that you are aware of potential issues and can design safer programs, eliminating some of the vulnerabilities commonly found in systems written in C.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="58-performance-considerations-for-numeric-types"><a class="header" href="#58-performance-considerations-for-numeric-types">5.8 Performance Considerations for Numeric Types</a></h2>
<p>When working with numeric types in Rust, it's important to consider the trade-offs between performance and precision. Rust’s wide range of numeric types allows developers to choose the best fit for their use case.</p>
<h3 id="581-integer-types"><a class="header" href="#581-integer-types">5.8.1 Integer Types</a></h3>
<p>In general, smaller types like <code>i8</code> or <code>u8</code> consume less memory, but they can introduce overhead when operations require upscaling to larger types or when they cause frequent overflow checks. On most modern CPUs, using the default <code>i32</code> and <code>u32</code> types is optimal for performance, as these sizes align well with the word size of the CPU.</p>
<p>Larger types like <code>i64</code> or <code>u64</code> might introduce additional overhead on 32-bit architectures, where the processor cannot handle 64-bit integers natively. In contrast, on 64-bit processors, operations with 64-bit integers are typically fast and efficient.</p>
<h3 id="582-floating-point-types"><a class="header" href="#582-floating-point-types">5.8.2 Floating-Point Types</a></h3>
<p>Rust defaults to <strong><code>f64</code></strong> for floating-point numbers because modern processors are highly optimized for 64-bit floating-point operations. However, if you need to save memory or work with less precision, <code>f32</code> is an option, though it may result in slower calculations on certain architectures due to the need for converting or extending to <code>f64</code> in intermediate operations.</p>
<h3 id="583-simd-and-parallel-processing"><a class="header" href="#583-simd-and-parallel-processing">5.8.3 SIMD and Parallel Processing</a></h3>
<p>Rust's ability to utilize <strong>SIMD (Single Instruction, Multiple Data)</strong> can significantly boost performance for operations over vectors of numbers. Additionally, Rust’s <strong>parallelism</strong> model, supported by the strict ownership and borrowing system, enables safe and efficient concurrency, allowing multiple threads to operate on numeric data without risking data races.</p>
<h3 id="584-cache-efficiency-and-memory-alignment"><a class="header" href="#584-cache-efficiency-and-memory-alignment">5.8.4 Cache Efficiency and Memory Alignment</a></h3>
<p>When choosing between smaller types (like <code>i8</code>) and larger types (like <code>i32</code>), cache efficiency becomes an important factor. Smaller types can reduce the memory footprint, leading to fewer cache misses, but they might introduce conversion overhead. In contrast, using <code>i32</code> or <code>i64</code> might lead to faster computation overall due to reduced conversion overhead, especially in tight loops.</p>
<p>Aligning data structures to the natural word size of the CPU can improve performance due to more efficient memory access patterns.</p>
<p>By understanding these performance characteristics, developers can choose numeric types that best balance performance, memory use, and safety for their specific applications.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="59-comments-in-rust"><a class="header" href="#59-comments-in-rust">5.9 Comments in Rust</a></h2>
<p>Comments are an essential part of writing clear, maintainable code. In Rust, comments are ignored by the compiler but are crucial for explaining code logic, intentions, or providing context to future developers (including yourself). Rust supports two types of comments: regular comments and documentation comments.</p>
<h3 id="591-regular-comments"><a class="header" href="#591-regular-comments">5.9.1 Regular Comments</a></h3>
<p>Rust uses two types of regular comments:</p>
<ol>
<li>
<p><strong>Single-line comments:</strong>
Single-line comments start with <code>//</code> and continue to the end of the line. These are typically used for short explanations or notes about the code.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let number = 5; // This is a single-line comment
    println!("Number is: {}", number); // Prints the value of number
}</code></pre></pre>
</li>
<li>
<p><strong>Multi-line comments:</strong>
For longer explanations or temporarily commenting out blocks of code, you can use multi-line comments, which start with <code>/*</code> and end with <code>*/</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    /* 
    This is a multi-line comment.
    It can span multiple lines and is useful
    for providing longer explanations.
    */
    println!("Multi-line comments are useful for long notes.");
}</code></pre></pre>
<p><strong>Note:</strong> Multi-line comments can be nested, which allows you to comment out sections of code that may already contain comments. This is a useful feature when you want to disable larger portions of code without interfering with existing comments.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    /*
    This is a multi-line comment.
    /* Nested comments are allowed in Rust. */
    */
}</code></pre></pre>
</li>
</ol>
<h3 id="592-documentation-comments"><a class="header" href="#592-documentation-comments">5.9.2 Documentation Comments</a></h3>
<p>Rust provides a special type of comment, called <strong>documentation comments</strong>, to generate API documentation. These comments use <code>///</code> or <code>//!</code>, depending on their context.</p>
<ol>
<li>
<p><strong>Outer documentation comments (<code>///</code>):</strong>
Outer documentation comments are placed before items like functions, structs, modules, etc. They describe the item they precede and can be processed by Rust’s documentation tool (<code>rustdoc</code>) to generate user-friendly HTML documentation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds two numbers together.
///
/// # Arguments
///
/// * `a` - The first number.
/// * `b` - The second number.
///
/// # Example
///
/// ```
/// let result = add(5, 3);
/// assert_eq!(result, 8);
/// ```
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>///</code> comment documents the <code>add</code> function. It includes a description of the function, its arguments, and an example of how to use it. Rustdoc extracts these comments and generates web-based documentation from them.</p>
</li>
<li>
<p><strong>Inner documentation comments (<code>//!</code>):</strong>
Inner documentation comments are used inside modules or crates to provide information about the enclosing scope. They typically describe the purpose of the module, file, or crate as a whole.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! This is a library for basic mathematical operations.
//! It supports addition, subtraction, multiplication, and division.

/// Multiplies two numbers together.
fn multiply(a: i32, b: i32) -&gt; i32 {
    a * b
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="593-commenting-guidelines"><a class="header" href="#593-commenting-guidelines">5.9.3 Commenting Guidelines</a></h3>
<p>Here are a few guidelines for using comments effectively in Rust:</p>
<ul>
<li>Use single-line comments (<code>//</code>) for short, simple notes.</li>
<li>Use multi-line comments (<code>/* */</code>) for longer explanations or for temporarily disabling sections of code.</li>
<li>Avoid excessive comments that simply restate what the code does. Comments should explain <em>why</em> something is done rather than <em>what</em> is being done if the code itself is clear.</li>
<li>Documentation comments (<code>///</code>, <code>//!</code>) are encouraged for documenting public APIs, especially in libraries, to ensure the code is well-documented and understandable.</li>
</ul>
<h3 id="594-markdown-in-documentation-comments"><a class="header" href="#594-markdown-in-documentation-comments">5.9.4 Markdown in Documentation Comments</a></h3>
<p>Rust allows you to use <strong>Markdown</strong> in documentation comments to format text, create lists, and provide code examples. Rustdoc will automatically process the Markdown syntax when generating documentation.</p>
<p>For example, in the following documentation comment, we use Markdown to format the text:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adds two numbers and returns the result.
///
/// # Example
///
/// ```
/// let result = add(1, 2);
/// assert_eq!(result, 3);
/// ```
///
/// # Panics
///
/// This function will never panic.
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>Here, the <code># Example</code> and <code># Panics</code> headings are created using Markdown, and a code block example is provided inside triple backticks (```).</p>
<h3 id="595-summary"><a class="header" href="#595-summary">5.9.5 Summary</a></h3>
<ul>
<li><strong>Single-line comments</strong> (<code>//</code>) are used for brief remarks.</li>
<li><strong>Multi-line comments</strong> (<code>/* */</code>) are for longer explanations or disabling blocks of code. Rust allows <strong>nested comments</strong>, which can be useful when temporarily disabling sections of code that already contain comments.</li>
<li><strong>Documentation comments</strong> (<code>///</code>, <code>//!</code>) are used to generate documentation for items such as functions, modules, and structs. They are written in Markdown to create rich, readable documentation.</li>
<li>It’s a good practice to document public APIs using documentation comments so that users of the code can easily understand its purpose and usage.</li>
</ul>
<p>Comments are a valuable tool in writing maintainable code. They not only help others understand your code but also serve as helpful reminders for yourself when you revisit the code later.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="510-summary"><a class="header" href="#510-summary">5.10 Summary</a></h2>
<p>In this chapter, we've explored fundamental programming concepts essential to understanding Rust and how they compare to languages like C. We covered:</p>
<ul>
<li><strong>Keywords:</strong> The reserved words in Rust that define the structure and behavior of programs.</li>
<li><strong>Expressions and Statements:</strong> Understanding how Rust differentiates between expressions (which evaluate to a value) and statements (which perform actions).</li>
<li><strong>Data Types:</strong> Rust's scalar types (integers, floating-point numbers, booleans, and characters) and compound types (tuples and arrays), including their syntax and usage.</li>
<li><strong>Variables and Mutability:</strong> How to declare variables, the concept of immutability by default, and how to use mutable variables when necessary.</li>
<li><strong>Operators:</strong> The various operators available in Rust, including arithmetic, comparison, logical, and bitwise operators, and how to use them.</li>
<li><strong>Numeric Literals:</strong> How to work with numeric literals in Rust, including integer and floating-point literals, and specifying their types.</li>
<li><strong>Arithmetic Overflow:</strong> How Rust handles arithmetic overflow in debug and release modes, and the methods available for explicit overflow handling.</li>
<li><strong>Performance Considerations:</strong> Factors to consider when choosing numeric types for performance and efficiency.</li>
<li><strong>Comments in Rust:</strong> The importance of comments for code clarity and maintainability, including regular and documentation comments.</li>
</ul>
<p>By understanding these concepts, you're building a solid foundation for writing safe, efficient, and expressive Rust programs.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="511-closing-thoughts"><a class="header" href="#511-closing-thoughts">5.11 Closing Thoughts</a></h2>
<p>Grasping the common programming concepts outlined in this chapter is crucial for any programmer working with Rust or transitioning from other languages like C. Rust's emphasis on safety, performance, and concurrency introduces unique features and considerations that set it apart.</p>
<p>As you continue your journey with Rust, remember that the language is designed to help you write robust code by catching errors at compile time and enforcing strict rules around memory safety and data types. Embracing these concepts will not only make you a better Rust programmer but also enhance your overall programming skills.</p>
<p>In the upcoming chapters, we'll delve deeper into Rust's ownership model, borrowing, and lifetimes, which are key to understanding how Rust manages memory safely and efficiently. We'll also explore more advanced topics like control flow, functions, modules, and data structures.</p>
<p>Keep practicing, experimenting with code examples, and exploring Rust's rich ecosystem. Happy coding!</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6-ownership-and-memory-management-in-rust"><a class="header" href="#chapter-6-ownership-and-memory-management-in-rust">Chapter 6: Ownership and Memory Management in Rust</a></h1>
<p>For C programmers, manual memory management is a fundamental aspect of programming. In C, you have complete control over memory allocation and deallocation using functions like <code>malloc</code> and <code>free</code>. While this offers flexibility, it also introduces risks such as memory leaks, dangling pointers, and buffer overflows. Rust introduces a different approach to memory management that ensures <strong>memory safety</strong> without a garbage collector and minimizes runtime overhead.</p>
<p>In this chapter, we'll delve into Rust's ownership system, borrowing, lifetimes, and other related topics, comparing them directly with C to help you leverage your existing knowledge. We'll also explore advanced concepts like smart pointers (<code>Box</code>, <code>Rc</code>, <code>Arc</code>) and touch upon unsafe Rust and interoperability with C.</p>
<p>We will use Rust's <code>String</code> type as an example to introduce ownership and borrowing. Strings represent more complex data than scalar types, and their dynamic nature helps illustrate key concepts in memory management. Here, we focus on basic string operations such as creating and appending text. A more in-depth discussion of the string type will be covered in a dedicated chapter later on.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="61-overview-of-ownership"><a class="header" href="#61-overview-of-ownership">6.1 Overview of Ownership</a></h2>
<p>Ownership is the cornerstone of Rust's memory management system. It enables Rust to guarantee memory safety at compile time, preventing many common errors that can occur in C. Understanding ownership is crucial for mastering Rust.</p>
<h3 id="611-ownership-rules"><a class="header" href="#611-ownership-rules">6.1.1 Ownership Rules</a></h3>
<p>Rust enforces a set of rules for ownership:</p>
<ol>
<li><strong>Each value in Rust has a single owner.</strong></li>
<li><strong>When the owner goes out of scope, the value is dropped (memory is freed).</strong></li>
<li><strong>Ownership can be transferred (moved) to another variable.</strong></li>
<li><strong>There can only be one owner at a time.</strong></li>
</ol>
<p>These rules are enforced at compile time by the <strong>borrow checker</strong>, ensuring memory safety without runtime overhead. The borrow checker analyzes your code to enforce these ownership and borrowing rules, preventing data races, dangling pointers, and other memory safety issues.</p>
<p>Types in Rust can implement the <code>Drop</code> trait to customize what happens when they go out of scope. This allows you to define custom cleanup logic, similar to destructors in C++.</p>
<h4 id="example-scope-and-drop"><a class="header" href="#example-scope-and-drop">Example: Scope and Drop</a></h4>
<pre><code class="language-rust ignore">fn main() {
    {
        let s = String::from("hello"); // s comes into scope
        // use s
    } // s goes out of scope and is dropped here
}</code></pre>
<p>In this example, <code>s</code> is a <code>String</code> that is created within an inner scope. When the scope ends, <code>s</code> is automatically dropped, and its memory is freed. This automatic cleanup is similar to C++'s RAII (Resource Acquisition Is Initialization) pattern but is enforced by the compiler in Rust.</p>
<h4 id="comparison-with-c"><a class="header" href="#comparison-with-c">Comparison with C</a></h4>
<p>In C, memory management is manual:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt; // for strcpy

int main() {
    {
        char *s = malloc(6); // Allocate memory on the heap
        strcpy(s, "hello");
        // use s
        free(s); // Manually free the memory
    } // No automatic cleanup in C
    return 0;
}
</code></pre>
<p>In C, failing to call <code>free(s)</code> would result in a memory leak. Rust eliminates this risk by automatically calling <code>drop</code> when variables go out of scope.</p>
<h3 id="612-ownership-transfer-move-semantics"><a class="header" href="#612-ownership-transfer-move-semantics">6.1.2 Ownership Transfer (Move Semantics)</a></h3>
<p>When you assign or pass ownership of a heap-allocated value to another variable, Rust <strong>moves</strong> the ownership rather than copying the data. This move is the default behavior for types that do not implement the <code>Copy</code> trait, and it helps prevent data races and dangling pointers by ensuring only one owner of the data exists at a time.</p>
<h4 id="rust-code"><a class="header" href="#rust-code">Rust Code</a></h4>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // s1 is moved to s2
    // println!("{}", s1); // Error: s1 is no longer valid
    println!("{}", s2); // Outputs: hello
}</code></pre></pre>
<p>After moving <code>s1</code> to <code>s2</code>, <code>s1</code> is invalidated. Attempting to use <code>s1</code> results in a compile-time error, preventing issues like double frees. This is different from a shallow copy in C, where both variables might point to the same memory location.</p>
<h4 id="comparison-with-c-1"><a class="header" href="#comparison-with-c-1">Comparison with C</a></h4>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
    char *s1 = malloc(6);
    strcpy(s1, "hello");
    char *s2 = s1; // Both s1 and s2 point to the same memory
    free(s1);
    // Using s2 here would be undefined behavior
    return 0;
}
</code></pre>
<p>In C, both <code>s1</code> and <code>s2</code> point to the same memory. Freeing <code>s1</code> and then using <code>s2</code> leads to undefined behavior. Rust prevents this by invalidating <code>s1</code> after the move.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="62-move-semantics-cloning-and-copying"><a class="header" href="#62-move-semantics-cloning-and-copying">6.2 Move Semantics, Cloning, and Copying</a></h2>
<h3 id="621-move-semantics"><a class="header" href="#621-move-semantics">6.2.1 Move Semantics</a></h3>
<p>Rust uses <strong>move semantics</strong> for types that manage resources like heap memory or file handles. When you assign such a type to another variable or pass it to a function, the ownership is moved.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1 = String::from("hello");
    let s2 = s1; // Move occurs
    // s1 is invalidated
}</code></pre></pre>
<p>Move semantics ensure that there's always a single owner of the data, preventing issues like data races and dangling pointers.</p>
<h3 id="622-shallow-vs-deep-copy-and-the-clone-method"><a class="header" href="#622-shallow-vs-deep-copy-and-the-clone-method">6.2.2 Shallow vs. Deep Copy and the <code>clone()</code> Method</a></h3>
<p>If you need to retain the original value, you can create a deep copy using the <code>clone()</code> method. The <code>clone()</code> method creates a new instance of the data on the heap, duplicating the contents of the original data. This can be expensive depending on the size of the data, so it's important to be mindful of performance implications when using <code>clone()</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // Creates a deep copy of s1
    println!("s1: {}, s2: {}", s1, s2);
}</code></pre></pre>
<p>In the code above, <code>s1.clone()</code> creates a deep copy of the <code>String</code> data in <code>s1</code>. This new <code>String</code> is then moved into <code>s2</code>. The variable <code>s1</code> remains valid and unchanged because the ownership of the cloned data is moved, not the original <code>s1</code>. Now both <code>s1</code> and <code>s2</code> own separate copies of the data.</p>
<h4 id="example-difference-between-move-and-clone"><a class="header" href="#example-difference-between-move-and-clone">Example: Difference Between Move and Clone</a></h4>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let s1 = String::from("hello");
    let s2 = s1;          // Move occurs
    // println!("{}", s1); // Error: s1 is moved

    let s3 = String::from("world");
    let s4 = s3.clone();  // Clone occurs
    println!("s3: {}, s4: {}", s3, s4); // Both s3 and s4 are valid
}</code></pre></pre>
<p>In this example, <code>s1</code> is moved to <code>s2</code>, so <code>s1</code> becomes invalid. However, <code>s3</code> is cloned to <code>s4</code>, so both <code>s3</code> and <code>s4</code> remain valid.</p>
<h4 id="comparison-with-c-2"><a class="header" href="#comparison-with-c-2">Comparison with C</a></h4>
<p>In C, you would manually copy the data:</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main() {
    char *s1 = malloc(6);
    strcpy(s1, "hello");
    char *s2 = malloc(6);
    strcpy(s2, s1); // Deep copy
    // Use s1 and s2
    free(s1);
    free(s2);
    return 0;
}
</code></pre>
<h3 id="623-copying-scalar-types"><a class="header" href="#623-copying-scalar-types">6.2.3 Copying Scalar Types</a></h3>
<p>For simple types like integers and floats, Rust implements <strong>copy semantics</strong>. These types implement the <code>Copy</code> trait, allowing for bitwise copies without invalidating the original variable. Types that implement the <code>Copy</code> trait are generally simple, stack-allocated types like integers and floats. They do not manage resources on the heap, making bitwise copies safe.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 5;
    let y = x; // Copy occurs
    println!("x: {}, y: {}", x, y); // Both x and y are valid
}</code></pre></pre>
<h4 id="comparison-with-c-3"><a class="header" href="#comparison-with-c-3">Comparison with C</a></h4>
<p>In C, simple types are copied by value:</p>
<pre><code class="language-c">int x = 5;
int y = x; // Copy
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="63-borrowing-and-references"><a class="header" href="#63-borrowing-and-references">6.3 Borrowing and References</a></h2>
<p>Borrowing in Rust allows you to access data without taking ownership. This is achieved through references.</p>
<h3 id="631-references-in-rust-vs-pointers-in-c"><a class="header" href="#631-references-in-rust-vs-pointers-in-c">6.3.1 References in Rust vs. Pointers in C</a></h3>
<h4 id="rust-references"><a class="header" href="#rust-references">Rust References</a></h4>
<ul>
<li><strong>Immutable References (<code>&amp;T</code>)</strong>: Read-only access.</li>
<li><strong>Mutable References (<code>&amp;mut T</code>)</strong>: Read and write access.</li>
<li><strong>Non-nullable</strong>: Rust references cannot be null.</li>
<li><strong>Guaranteed Validity</strong>: References are guaranteed to point to valid data.</li>
<li><strong>Automatically Dereferenced</strong>: Accessing the value doesn't require explicit dereferencing.</li>
</ul>
<h4 id="c-pointers"><a class="header" href="#c-pointers">C Pointers</a></h4>
<ul>
<li><strong>Nullable</strong>: Can be null.</li>
<li><strong>Explicit Dereferencing</strong>: Require explicit dereferencing (<code>*ptr</code>).</li>
<li><strong>No Enforced Mutability Rules</strong>: Mutability is not enforced.</li>
<li><strong>Possible Invalid Pointers</strong>: May point to invalid or uninitialized memory.</li>
</ul>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<p><strong>Rust Code:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let x = 10;
    let y = &amp;x; // Immutable reference
    println!("y points to {}", y);
}</code></pre></pre>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int x = 10;
    int *y = &amp;x; // Pointer to x
    printf("y points to %d\n", *y);
    return 0;
}
</code></pre>
<h3 id="632-borrowing-rules"><a class="header" href="#632-borrowing-rules">6.3.2 Borrowing Rules</a></h3>
<p>Rust enforces strict borrowing rules to ensure safety:</p>
<ol>
<li><strong>At any given time, you can have either one mutable reference or any number of immutable references.</strong></li>
<li><strong>References must always be valid.</strong></li>
</ol>
<h4 id="single-mutable-reference"><a class="header" href="#single-mutable-reference">Single Mutable Reference</a></h4>
<p>Here's an example that demonstrates the correct use of a mutable reference:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s = String::from("hello");
    let r = &amp;mut s;         // Mutable reference to s
    r.push_str(" world");
    println!("{}", r);
}</code></pre></pre>
<p>In this code:</p>
<ul>
<li>We create a mutable reference <code>r</code> to <code>s</code>.</li>
<li>We mutate the data through <code>r</code>.</li>
<li>We do not use <code>s</code> directly while <code>r</code> is active.</li>
<li>This adheres to Rust's borrowing rules and compiles successfully.</li>
</ul>
<h4 id="invalid-code-mutable-reference-and-use-of-original-variable"><a class="header" href="#invalid-code-mutable-reference-and-use-of-original-variable">Invalid Code: Mutable Reference and Use of Original Variable</a></h4>
<p>Consider the following code:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s = String::from("hello");
    let r = &amp;mut s;         // Mutable reference to s
    r.push_str(" world");

    s.push_str(" all");     // Attempt to use s while r is still in scope

    println!("{}", r);
    println!("{}", s);
}</code></pre></pre>
<p>This code <strong>does not compile</strong> because it violates Rust's borrowing rules.</p>
<p><strong>Compiler Error:</strong></p>
<pre><code>error[E0503]: cannot use `s` because it was mutably borrowed
 --&gt; src/main.rs:6:5
  |
3 |     let r = &amp;mut s;         // Mutable reference to s
  |             ------ borrow of `s` occurs here
...
6 |     s.push_str(" all");     // Attempt to use s while r is still in scope
  |     ^^^^^^^^^^^^^^^^^^ use of borrowed `s`
7 |     
8 |     println!("{}", r);
  |                    - borrow later used here
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>When <code>r</code> is created as a mutable reference to <code>s</code>, it has exclusive access to <code>s</code>.</li>
<li>Attempting to use <code>s</code> directly (<code>s.push_str(" all")</code>) while <code>r</code> is still active violates the rule that you cannot have other references to a variable while a mutable reference exists.</li>
<li>The compiler prevents this to ensure memory safety and avoid data races.</li>
</ul>
<p><strong>How to Fix the Code:</strong></p>
<ul>
<li>
<p><strong>Option 1:</strong> Limit the scope of the mutable reference:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s = String::from("hello");
    {
        let r = &amp;mut s;
        r.push_str(" world");
        println!("{}", r);
    } // r goes out of scope here

    s.push_str(" all");
    println!("{}", s);
}</code></pre></pre>
</li>
<li>
<p><strong>Option 2:</strong> Perform all mutations through the mutable reference:</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut s = String::from("hello");
    let r = &amp;mut s;
    r.push_str(" world");
    r.push_str(" all");
    println!("{}", r);
}</code></pre></pre>
</li>
</ul>
<p>By adjusting the code to comply with Rust's borrowing rules, we ensure that our program is both safe and functional.</p>
<h3 id="633-why-these-rules"><a class="header" href="#633-why-these-rules">6.3.3 Why These Rules?</a></h3>
<p>These rules prevent data races and ensure memory safety without a garbage collector. By enforcing them at compile time, Rust eliminates entire classes of runtime errors common in C.</p>
<p>The borrow checker analyzes your code to track ownership and borrowing, ensuring that references are used safely according to the borrowing rules. It prevents you from having multiple mutable references to the same data, which could lead to data races, especially in concurrent contexts.</p>
<h4 id="comparison-with-c-4"><a class="header" href="#comparison-with-c-4">Comparison with C</a></h4>
<p>In C, nothing prevents you from having multiple pointers to the same data, leading to potential undefined behavior.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char s[6] = "hello";
    char *p1 = s;
    char *p2 = s;
    strcpy(p1, "world");
    printf("%s\n", p2); // Outputs: world
    return 0;
}
</code></pre>
<p>In C, modifying data through one pointer affects all other pointers to that data. Rust prevents this when mutable references are involved.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="64-the-string-type-and-memory-allocation"><a class="header" href="#64-the-string-type-and-memory-allocation">6.4 The <code>String</code> Type and Memory Allocation</a></h2>
<h3 id="641-stack-vs-heap-allocation"><a class="header" href="#641-stack-vs-heap-allocation">6.4.1 Stack vs. Heap Allocation</a></h3>
<ul>
<li><strong>Stack Allocation</strong>: Fixed size, fast access, automatically managed. Variables allocated on the stack are known at compile time.</li>
<li><strong>Heap Allocation</strong>: Dynamic size, requires manual management (in C) or smart pointers (in Rust). Used when data size is not known at compile time or when allocating large amounts of data.</li>
</ul>
<p>Heap allocation allows <code>String</code> to store data of variable length, but accessing heap-allocated memory is generally slower than stack memory due to additional indirection.</p>
<h3 id="642-the-structure-of-a-string"><a class="header" href="#642-the-structure-of-a-string">6.4.2 The Structure of a <code>String</code></a></h3>
<p>In Rust, a <code>String</code> consists of:</p>
<ul>
<li><strong>Pointer</strong>: Points to the heap-allocated data.</li>
<li><strong>Length</strong>: Current length of the string.</li>
<li><strong>Capacity</strong>: Total allocated capacity.</li>
</ul>
<p>This structure (pointer, length, capacity) is stored on the stack, while the actual string data resides on the heap. The <code>String</code> type implements the <code>Drop</code> trait, ensuring that the heap memory is automatically freed when the <code>String</code> goes out of scope.</p>
<h3 id="643-how-strings-grow"><a class="header" href="#643-how-strings-grow">6.4.3 How Strings Grow</a></h3>
<p>When a <code>String</code> needs more capacity, Rust reallocates a larger buffer on the heap and copies the data over, managing memory automatically. Rust often doubles the capacity when reallocating to amortize the cost of reallocations. This process is abstracted away from the programmer.</p>
<h3 id="644-string-literals"><a class="header" href="#644-string-literals">6.4.4 String Literals</a></h3>
<p>String literals (<code>&amp;'static str</code>) are immutable and stored in the program's binary.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;str = "hello";
<span class="boring">}</span></code></pre></pre>
<p>In C, string literals are also immutable:</p>
<pre><code class="language-c">const char *s = "hello";
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="65-slices-borrowing-portions-of-data"><a class="header" href="#65-slices-borrowing-portions-of-data">6.5 Slices: Borrowing Portions of Data</a></h2>
<p>Slices are references to a segment of a collection, allowing you to access parts of data without owning it or making unnecessary copies. This makes working with subsets of data efficient and safe.</p>
<h3 id="651-string-slices"><a class="header" href="#651-string-slices">6.5.1 String Slices</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from("hello world");
let hello = &amp;s[0..5]; // "hello"
let world = &amp;s[6..11]; // "world"
<span class="boring">}</span></code></pre></pre>
<p>String slices (<code>&amp;str</code>) are references to a sequence of UTF-8 bytes within a <code>String</code>. They allow you to work with parts of a string without taking ownership.</p>
<h3 id="652-array-slices"><a class="header" href="#652-array-slices">6.5.2 Array Slices</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3, 4, 5];
let slice = &amp;arr[1..4]; // [2, 3, 4]
<span class="boring">}</span></code></pre></pre>
<h3 id="653-slices-in-functions"><a class="header" href="#653-slices-in-functions">6.5.3 Slices in Functions</a></h3>
<p>Slices are commonly used in function parameters to allow functions to work with parts of data without taking ownership, making functions more flexible.</p>
<pre><pre class="playground"><code class="language-rust">fn sum(slice: &amp;[i32]) -&gt; i32 {
    slice.iter().sum()
}

fn main() {
    let arr = [1, 2, 3, 4, 5];

    // Passing a slice of the array (partial array)
    let partial_result = sum(&amp;arr[1..4]);
    println!("Sum of slice is {}", partial_result);

    // Passing the whole array as a slice
    let total_result = sum(&amp;arr);
    println!("Sum of entire array is {}", total_result);
}</code></pre></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>
<p><strong>Function Definition:</strong></p>
<ul>
<li>The <code>sum</code> function takes a slice of <code>i32</code> values (<code>&amp;[i32]</code>) and returns their sum.</li>
<li>The function operates on the slice without taking ownership, allowing it to accept any segment of an array or vector.</li>
</ul>
</li>
<li>
<p><strong>In <code>main</code>:</strong></p>
<ul>
<li>We define an array <code>arr</code> containing five integers.</li>
<li><strong>Passing a Partial Slice:</strong>
<ul>
<li>We pass a slice of the array to <code>sum</code> using <code>&amp;arr[1..4]</code>, which includes elements at indices 1 to 3 (<code>2, 3, 4</code>).</li>
<li>The <code>partial_result</code> calculates the sum of this slice.</li>
</ul>
</li>
<li><strong>Passing the Whole Array:</strong>
<ul>
<li>We pass the entire array to <code>sum</code> using <code>&amp;arr</code> without specifying a range.</li>
<li>The <code>total_result</code> calculates the sum of all elements in the array.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>By using slices, functions can operate on data without taking ownership, allowing them to accept both entire arrays and portions of arrays seamlessly.</p>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Flexibility:</strong> The same function can operate on both full arrays and subarrays without any modification.</li>
<li><strong>Efficiency:</strong> Since slices are references, they avoid unnecessary copying of data.</li>
<li><strong>Safety:</strong> Rust ensures that slices do not outlive the data they reference, preventing dangling references.</li>
</ul>
<p><strong>Additional Example with String Slices:</strong></p>
<pre><pre class="playground"><code class="language-rust">fn print_slice(slice: &amp;str) {
    println!("Slice: {}", slice);
}

fn main() {
    let s = String::from("hello world");

    // Passing a substring
    print_slice(&amp;s[0..5]); // Outputs: Slice: hello

    // Passing the whole string
    print_slice(&amp;s);       // Outputs: Slice: hello world
}</code></pre></pre>
<p><strong>Key Takeaways:</strong></p>
<ul>
<li>
<p><strong>Passing the Whole Collection:</strong></p>
<ul>
<li>You can pass the entire array or string to a function expecting a slice by referencing it with <code>&amp;arr</code> or <code>&amp;s</code>.</li>
</ul>
</li>
<li>
<p><strong>Automatic Coercion:</strong></p>
<ul>
<li>Rust automatically coerces arrays and strings to slices when you pass them by reference to functions expecting slices.</li>
</ul>
</li>
<li>
<p><strong>No Need for Full Range Specification:</strong></p>
<ul>
<li>Specifying the full range like <code>&amp;arr[0..arr.len()]</code> is unnecessary; <code>&amp;arr</code> suffices.</li>
</ul>
</li>
</ul>
<h3 id="comparison-with-c-5"><a class="header" href="#comparison-with-c-5">Comparison with C</a></h3>
<p>In C, you use pointers and manual length management:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void sum(int *slice, int length) {
    int total = 0;
    for(int i = 0; i &lt; length; i++) {
        total += slice[i];
    }
    printf("Sum is %d\n", total);
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    sum(&amp;arr[1], 3);
    return 0;
}
</code></pre>
<p>C does not perform bounds checking, whereas Rust slices include length information and are bounds-checked at runtime.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="66-lifetimes-ensuring-valid-references"><a class="header" href="#66-lifetimes-ensuring-valid-references">6.6 Lifetimes: Ensuring Valid References</a></h2>
<p>Lifetimes in Rust prevent dangling references by ensuring that all references are valid as long as they are in use. Think of lifetimes as labels that tell the compiler how long references are valid. They ensure that references do not outlive the data they point to.</p>
<h3 id="661-understanding-lifetimes"><a class="header" href="#661-understanding-lifetimes">6.6.1 Understanding Lifetimes</a></h3>
<p>Every reference in Rust has a lifetime, which is the scope during which the reference is valid. Lifetimes are enforced by the compiler to ensure that references do not outlive the data they refer to.</p>
<h3 id="662-lifetime-annotations"><a class="header" href="#662-lifetime-annotations">6.6.2 Lifetime Annotations</a></h3>
<p>In simple cases, Rust infers lifetimes, but in more complex scenarios, you need to specify them. Lifetime annotations use an apostrophe followed by a name (e.g., <code>'a</code>) and are placed after the <code>&amp;</code> symbol in references (e.g., <code>&amp;'a str</code>). They link the lifetimes of references to ensure validity.</p>
<h4 id="example-function-returning-a-reference"><a class="header" href="#example-function-returning-a-reference">Example: Function Returning a Reference</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>'a</code> lifetime parameter specifies that the returned reference will be valid as long as both <code>x</code> and <code>y</code> are valid.</p>
<h3 id="663-invalid-code-examples-and-lifetime-misunderstandings"><a class="header" href="#663-invalid-code-examples-and-lifetime-misunderstandings">6.6.3 Invalid Code Examples and Lifetime Misunderstandings</a></h3>
<p>Understanding lifetimes can be challenging, especially when dealing with references that might outlive the data they point to. In this section, we'll explore invalid code examples related to lifetimes, explain why they don't compile, and clarify concepts like the use of <code>as_str()</code>, the role of string literals, and how variable scopes affect lifetimes.</p>
<h4 id="example-missing-lifetime-annotations"><a class="header" href="#example-missing-lifetime-annotations">Example: Missing Lifetime Annotations</a></h4>
<p>Consider the following function that returns a reference to a string slice:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() { x } else { y }
}
<span class="boring">}</span></code></pre></pre>
<p>When you try to compile this code, you'll encounter a compiler error:</p>
<details>
  <summary>Click to see the error message and explanation</summary>
<pre><code>error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:33
  |
1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>The compiler cannot determine the lifetime of the reference being returned.</li>
<li>Since <code>x</code> and <code>y</code> could have different lifetimes, Rust requires explicit lifetime annotations to ensure safety.</li>
</ul>
</details>
<h4 id="adding-lifetime-annotations"><a class="header" href="#adding-lifetime-annotations">Adding Lifetime Annotations</a></h4>
<p>By adding lifetime annotations, we specify that the returned reference will have the same lifetime as the input references:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><code>'a</code> is a generic lifetime parameter.</li>
<li>This tells the compiler that the returned reference will be valid as long as both <code>x</code> and <code>y</code> are valid.</li>
</ul>
<h4 id="example-with-variable-scope-and-lifetimes"><a class="header" href="#example-with-variable-scope-and-lifetimes">Example with Variable Scope and Lifetimes</a></h4>
<p>Let's explore a scenario where variable scopes and lifetimes interact in a way that causes a compiler error.</p>
<p><strong>Code Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let result;
    {
        let s1 = String::from("hello");
        result = longest(s1.as_str(), "world");
    } // s1 goes out of scope here
    // println!("The longest string is {}", result); // Error: `s1` does not live long enough
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>Inside the inner scope, we create <code>s1</code>, a <code>String</code> owning the heap-allocated data <code>"hello"</code>.</li>
<li>We call <code>longest(s1.as_str(), "world")</code>, passing a reference to <code>s1</code>'s data and the string literal <code>"world"</code>.</li>
<li>After the inner scope ends, <code>s1</code> is dropped, and its data becomes invalid.</li>
<li><code>result</code> holds a reference to the data returned by <code>longest</code>, which may be <code>s1.as_str()</code>.</li>
<li>When we attempt to use <code>result</code> outside the inner scope, it may reference invalid data, leading to a compiler error.</li>
</ul>
<p><strong>Compiler Error:</strong></p>
<pre><code>error[E0597]: `s1` does not live long enough
 --&gt; src/main.rs:5:21
  |
3 |         let s1 = String::from("hello");
  |             -- binding `s1` declared here
4 |         result = longest(s1.as_str(), "world");
  |                          ^^^^^^^^^^ borrowed value does not live long enough
5 |     } // s1 goes out of scope here
  |     - `s1` dropped here while still borrowed
6 |     println!("The longest string is {}", result);
  |                                          ------ borrow later used here
</code></pre>
<h4 id="why-is-as_str-used-and-what-does-it-do"><a class="header" href="#why-is-as_str-used-and-what-does-it-do">Why Is <code>as_str()</code> Used and What Does It Do?</a></h4>
<p><strong>Purpose of <code>as_str()</code>:</strong></p>
<ul>
<li><code>s1</code> is a <code>String</code>, which owns its data.</li>
<li><code>as_str()</code> converts the <code>String</code> into a string slice (<code>&amp;str</code>), a reference to the data inside the <code>String</code>.</li>
<li>This allows us to pass a <code>&amp;str</code> to the <code>longest</code> function, which expects string slices.</li>
</ul>
<p><strong>Alternative Without <code>as_str()</code>:</strong></p>
<ul>
<li>You can use <code>&amp;s1</code> instead of <code>s1.as_str()</code>.</li>
<li>Rust automatically dereferences <code>&amp;String</code> to <code>&amp;str</code> because <code>String</code> implements the <code>Deref</code> trait.</li>
</ul>
<p><strong>Modified Code:</strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let result;
    {
        let s1 = String::from("hello");
        result = longest(&amp;s1, "world"); // Using &amp;s1 instead of s1.as_str()
    }
    // println!("The longest string is {}", result); // Error remains the same
}</code></pre></pre>
<p><strong>Key Point:</strong></p>
<ul>
<li>Whether you use <code>s1.as_str()</code> or <code>&amp;s1</code>, the issue is not with the method but with the lifetime of <code>s1</code>.</li>
</ul>
<h4 id="what-happens-if-we-use-a-string-literal-instead"><a class="header" href="#what-happens-if-we-use-a-string-literal-instead">What Happens If We Use a String Literal Instead?</a></h4>
<p>Suppose we change <code>s1</code> to be a string literal:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let result;
    {
        let s1 = "hello"; // s1 is a &amp;str with 'static lifetime
        result = longest(s1, "world");
    }
    println!("The longest string is {}", result); // This works now
}

fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() { x } else { y }
}</code></pre></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>String literals like <code>"hello"</code> have a <code>'static</code> lifetime, meaning they are valid for the entire duration of the program.</li>
<li>Even though <code>s1</code> (the variable) goes out of scope, the data it references remains valid.</li>
<li>The <code>longest</code> function returns a reference with a lifetime tied to the shortest input lifetime, but since both are <code>'static</code>, the returned reference is valid outside the inner scope.</li>
</ul>
<h4 id="understanding-lifetimes-in-the-longest-function"><a class="header" href="#understanding-lifetimes-in-the-longest-function">Understanding Lifetimes in the <code>longest</code> Function</a></h4>
<ul>
<li>
<p>The function signature:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This means the returned reference's lifetime <code>'a</code> is the same as the lifetimes of <code>x</code> and <code>y</code>.</p>
</li>
<li>
<p>When one of the inputs has a shorter lifetime, <code>'a</code> becomes that shorter lifetime.</p>
</li>
</ul>
<p><strong>In the Original Code:</strong></p>
<ul>
<li><code>s1.as_str()</code> has a lifetime tied to <code>s1</code>, which is limited to the inner scope.</li>
<li><code>"world"</code> has a <code>'static</code> lifetime.</li>
<li>The compiler infers <code>'a</code> to be the shorter lifetime (that of <code>s1.as_str()</code>).</li>
<li>Therefore, <code>result</code> cannot outlive <code>s1</code>.</li>
</ul>
<h4 id="fixing-the-lifetime-issue"><a class="header" href="#fixing-the-lifetime-issue">Fixing the Lifetime Issue</a></h4>
<p>To resolve the error, we need to ensure that the data referenced by <code>result</code> is valid when we use it.</p>
<p><strong>Option 1: Extend the Lifetime of <code>s1</code></strong></p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let s1 = String::from("hello"); // Move s1 to the outer scope
    let result = longest(s1.as_str(), "world");
    println!("The longest string is {}", result); // Now this works
}</code></pre></pre>
<ul>
<li>By declaring <code>s1</code> in the outer scope, its data remains valid when we use <code>result</code>.</li>
</ul>
<p><strong>Option 2: Return an Owned <code>String</code></strong></p>
<p>Modify <code>longest</code> to return a <code>String</code>:</p>
<pre><pre class="playground"><code class="language-rust">fn longest(x: &amp;str, y: &amp;str) -&gt; String {
    if x.len() &gt; y.len() { x.to_string() } else { y.to_string() }
}

fn main() {
    let result;
    {
        let s1 = String::from("hello");
        result = longest(s1.as_str(), "world");
    }
    println!("The longest string is {}", result); // Works because result owns the data
}</code></pre></pre>
<ul>
<li>By returning a <code>String</code>, we transfer ownership of the data to <code>result</code>.</li>
<li>This eliminates lifetime concerns since <code>result</code> owns its data.</li>
</ul>
<h4 id="key-takeaways"><a class="header" href="#key-takeaways">Key Takeaways</a></h4>
<ul>
<li><strong>Lifetimes Ensure Valid References:</strong> They prevent references from pointing to invalid data.</li>
<li><strong>Variables vs. Data Lifetime:</strong> A variable going out of scope doesn't necessarily mean the data is invalid (e.g., string literals).</li>
<li><strong>String Literals Have <code>'static</code> Lifetime:</strong> They are valid for the entire duration of the program.</li>
<li><strong>Returning References:</strong> Be cautious when returning references to data created within a limited scope.</li>
</ul>
<h3 id="664-lifetime-elision"><a class="header" href="#664-lifetime-elision">6.6.4 Lifetime Elision</a></h3>
<p>In many cases, Rust can infer lifetimes, so you don't need to annotate them explicitly. Rust applies lifetime elision rules in certain cases, allowing you to omit lifetime annotations. For example, in functions with a single reference parameter and return type, the compiler assumes they have the same lifetime.</p>
<p>Understanding when and how to use lifetime annotations is important for more complex code.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="67-smart-pointers-and-heap-allocation"><a class="header" href="#67-smart-pointers-and-heap-allocation">6.7 Smart Pointers and Heap Allocation</a></h2>
<p>Rust offers smart pointers to safely manage heap-allocated data. The examples below are included for completeness, but we will explore all the types of Rust's smart pointers in greater detail in later chapters.</p>
<h3 id="671-boxt-heap-allocation"><a class="header" href="#671-boxt-heap-allocation">6.7.1 <code>Box&lt;T&gt;</code>: Heap Allocation</a></h3>
<p><code>Box&lt;T&gt;</code> allows you to store data on the heap. <code>Box&lt;T&gt;</code> implements the <code>Deref</code> trait, so you can use it similarly to a reference, automatically dereferencing when accessing the underlying data.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let b = Box::new(5); // Allocate integer on the heap
    println!("b = {}", b);
}</code></pre></pre>
<p>When <code>b</code> goes out of scope, the heap memory is automatically freed.</p>
<h3 id="672-recursive-types-with-boxt"><a class="header" href="#672-recursive-types-with-boxt">6.7.2 Recursive Types with <code>Box&lt;T&gt;</code></a></h3>
<pre><pre class="playground"><code class="language-rust editable">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

fn main() {
    use List::{Cons, Nil};

    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
}</code></pre></pre>
<p><code>Box&lt;T&gt;</code> allows for types of infinite size by providing a level of indirection.</p>
<h3 id="673-rct-and-reference-counting"><a class="header" href="#673-rct-and-reference-counting">6.7.3 <code>Rc&lt;T&gt;</code> and Reference Counting</a></h3>
<p><code>Rc&lt;T&gt;</code> enables multiple ownership in single-threaded scenarios through reference counting. Note that <code>Rc&lt;T&gt;</code> is not safe to use across threads. For multithreaded scenarios, use <code>Arc&lt;T&gt;</code> instead.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::rc::Rc;

fn main() {
    let a = Rc::new(String::from("hello"));
    let b = Rc::clone(&amp;a);
    let c = Rc::clone(&amp;a);
    println!("{}, {}, {}", a, b, c);
}</code></pre></pre>
<h3 id="674-arct-thread-safe-reference-counting"><a class="header" href="#674-arct-thread-safe-reference-counting">6.7.4 <code>Arc&lt;T&gt;</code>: Thread-Safe Reference Counting</a></h3>
<p>For multithreaded contexts, <code>Arc&lt;T&gt;</code> provides atomic reference counting.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::sync::Arc;
use std::thread;

fn main() {
    let a = Arc::new(String::from("hello"));
    let a1 = Arc::clone(&amp;a);

    let handle = thread::spawn(move || {
        println!("{}", a1);
    });

    println!("{}", a);
    handle.join().unwrap();
}</code></pre></pre>
<h3 id="675-refcellt-and-interior-mutability"><a class="header" href="#675-refcellt-and-interior-mutability">6.7.5 <code>RefCell&lt;T&gt;</code> and Interior Mutability</a></h3>
<p><code>RefCell&lt;T&gt;</code> allows for mutable borrows checked at runtime rather than compile time, enabling <strong>interior mutability</strong>. This is useful in scenarios where you need to modify data but are constrained by the borrowing rules.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cell::RefCell;

fn main() {
    let data = RefCell::new(5);

    {
        let mut v = data.borrow_mut();
        *v += 1;
    }

    println!("{}", data.borrow());
}</code></pre></pre>
<h4 id="using-refcellt-with-rct"><a class="header" href="#using-refcellt-with-rct">Using <code>RefCell&lt;T&gt;</code> with <code>Rc&lt;T&gt;</code></a></h4>
<p>You can combine <code>RefCell&lt;T&gt;</code> with <code>Rc&lt;T&gt;</code> to have multiple owners of mutable data in single-threaded contexts.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::cell::RefCell;
use std::rc::Rc;

struct Node {
    value: i32,
    next: Option&lt;Rc&lt;RefCell&lt;Node&gt;&gt;&gt;,
}

fn main() {
    let node1 = Rc::new(RefCell::new(Node { value: 1, next: None }));
    let node2 = Rc::new(RefCell::new(Node { value: 2, next: Some(Rc::clone(&amp;node1)) }));
    
    // Modify node1 through RefCell
    node1.borrow_mut().value = 10;

    println!("Node1 value: {}", node1.borrow().value);
    println!("Node2 next value: {}", node2.borrow().next.as_ref().unwrap().borrow().value);
}</code></pre></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="68-unsafe-rust-and-interoperability-with-c"><a class="header" href="#68-unsafe-rust-and-interoperability-with-c">6.8 Unsafe Rust and Interoperability with C</a></h2>
<p>While Rust enforces strict safety guarantees, sometimes you need to perform operations that the compiler cannot verify as safe.</p>
<h3 id="681-unsafe-blocks"><a class="header" href="#681-unsafe-blocks">6.8.1 Unsafe Blocks</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut num = 5;

    unsafe {
        let r1 = &amp;mut num as *mut i32; // Raw pointer
        *r1 += 1;
    }

    println!("num = {}", num);
}</code></pre></pre>
<p>Inside an <code>unsafe</code> block, you can perform operations like dereferencing raw pointers. Use <code>unsafe</code> blocks sparingly and encapsulate them within safe abstractions. This limits the scope of potential unsafe behavior and maintains overall program safety.</p>
<h3 id="682-interfacing-with-c"><a class="header" href="#682-interfacing-with-c">6.8.2 Interfacing with C</a></h3>
<p>Rust can interface with C code using <code>extern</code> blocks.</p>
<p><strong>Calling C from Rust:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">extern "C" {
    fn puts(s: *const i8);
}

fn main() {
    unsafe {
        puts(b"Hello from Rust!\0".as_ptr() as *const i8);
    }
}</code></pre></pre>
<p><strong>Calling Rust from C:</strong></p>
<p>Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<p>C code:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

extern int add(int a, int b);

int main() {
    int result = add(5, 3);
    printf("Result: %d\n", result);
    return 0;
}
</code></pre>
<p>You can use tools like <code>bindgen</code> to generate Rust bindings to existing C libraries, facilitating interoperability.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="69-comparison-with-c-memory-management"><a class="header" href="#69-comparison-with-c-memory-management">6.9 Comparison with C Memory Management</a></h2>
<h3 id="691-memory-safety-guarantees"><a class="header" href="#691-memory-safety-guarantees">6.9.1 Memory Safety Guarantees</a></h3>
<p>Rust eliminates many common errors that are prevalent in C:</p>
<ul>
<li><strong>Memory Leaks</strong>: Rust automatically frees memory when it goes out of scope.</li>
<li><strong>Dangling Pointers</strong>: The borrow checker prevents references to invalid memory.</li>
<li><strong>Double Frees</strong>: Ownership rules prevent freeing memory multiple times.</li>
<li><strong>Buffer Overflows</strong>: Bounds checking prevents writing outside allocated memory.</li>
</ul>
<h3 id="692-concurrency-safety"><a class="header" href="#692-concurrency-safety">6.9.2 Concurrency Safety</a></h3>
<p>Rust's ownership model enables safe concurrency. Rust uses the <code>Send</code> and <code>Sync</code> traits to enforce thread safety at compile time. Types that are <code>Send</code> can be transferred across thread boundaries, and <code>Sync</code> types can be safely shared between threads.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread;

fn main() {
    let s = String::from("hello");
    let handle = thread::spawn(move || {
        println!("{}", s);
    });
    handle.join().unwrap();
}</code></pre></pre>
<p>The compiler ensures that data accessed by multiple threads is handled safely.</p>
<h3 id="693-zero-cost-abstractions"><a class="header" href="#693-zero-cost-abstractions">6.9.3 Zero-Cost Abstractions</a></h3>
<p>Rust's abstractions compile down to efficient machine code, often matching or exceeding the performance of equivalent C code.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="610-summary"><a class="header" href="#610-summary">6.10 Summary</a></h2>
<p>In this chapter, we've explored:</p>
<ul>
<li><strong>Ownership and Memory Management:</strong>
<ul>
<li>Rust's ownership rules and how they ensure memory safety.</li>
<li>Comparison of ownership transfer (move semantics) between Rust and C.</li>
</ul>
</li>
<li><strong>Move Semantics, Cloning, and Copying:</strong>
<ul>
<li>The difference between moving and cloning data.</li>
<li>How scalar types implement the <code>Copy</code> trait.</li>
</ul>
</li>
<li><strong>Borrowing and References:</strong>
<ul>
<li>The rules of borrowing in Rust.</li>
<li>Comparison between Rust references and C pointers.</li>
</ul>
</li>
<li><strong>The <code>String</code> Type and Memory Allocation:</strong>
<ul>
<li>Understanding stack vs. heap allocation.</li>
<li>The internal structure of a <code>String</code>.</li>
</ul>
</li>
<li><strong>Slices:</strong>
<ul>
<li>How slices allow borrowing portions of data.</li>
<li>Using slices in functions for flexibility and efficiency.</li>
</ul>
</li>
<li><strong>Lifetimes:</strong>
<ul>
<li>Ensuring valid references with lifetimes.</li>
<li>Lifetime annotations and common pitfalls.</li>
</ul>
</li>
<li><strong>Smart Pointers and Heap Allocation:</strong>
<ul>
<li>Using <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, <code>Arc&lt;T&gt;</code>, and <code>RefCell&lt;T&gt;</code> for advanced memory management.</li>
</ul>
</li>
<li><strong>Unsafe Rust and Interoperability with C:</strong>
<ul>
<li>When and how to use <code>unsafe</code> blocks.</li>
<li>Interfacing Rust code with C.</li>
</ul>
</li>
<li><strong>Comparison with C Memory Management:</strong>
<ul>
<li>How Rust's approach prevents common memory safety issues found in C.</li>
</ul>
</li>
</ul>
<p>Understanding Rust's ownership and borrowing system is crucial for writing safe and efficient code. By leveraging these concepts, you can avoid many of the pitfalls associated with manual memory management in C.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="611-closing-thoughts"><a class="header" href="#611-closing-thoughts">6.11 Closing Thoughts</a></h2>
<p>Rust's ownership model represents a significant shift from traditional memory management practices in languages like C. While the concepts may seem complex at first, they provide powerful guarantees about memory safety without sacrificing performance.</p>
<p>As you continue your journey in Rust, remember to:</p>
<ul>
<li><strong>Embrace Ownership and Borrowing:</strong> These concepts are at the heart of Rust's safety guarantees.</li>
<li><strong>Leverage the Compiler:</strong> Trust the compiler's error messages; they guide you toward safer code.</li>
<li><strong>Practice with Examples:</strong> Experimenting with code will help solidify your understanding.</li>
<li><strong>Understand Lifetimes:</strong> Grasping lifetimes is essential for working with references and avoiding dangling pointers.</li>
<li><strong>Explore Advanced Features:</strong> As you become comfortable, delve into smart pointers and concurrency to harness Rust's full potential.</li>
</ul>
<p>By mastering Rust's ownership and memory management, you'll be equipped to write robust, high-performance applications that are free from many common bugs found in other systems programming languages.</p>
<p>Happy coding!</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7-control-flow-in-rust"><a class="header" href="#chapter-7-control-flow-in-rust">Chapter 7: Control Flow in Rust</a></h1>
<p>Control flow is a fundamental aspect of programming—it enables decision-making, conditional execution, and repeating actions. For C programmers transitioning to Rust, understanding Rust's control flow mechanisms, and how they differ from C's, is essential.</p>
<p>In this chapter, we'll examine Rust's control flow constructs and compare them to their counterparts in C, helping you build on your existing knowledge. We'll cover:</p>
<ul>
<li>Conditional statements (<code>if</code>, <code>else if</code>, <code>else</code>)</li>
<li>Looping constructs (<code>loop</code>, <code>while</code>, <code>for</code>)</li>
<li>The <code>match</code> statement for pattern matching</li>
<li>Variable scope and shadowing</li>
</ul>
<p>We will delve into Rust's more advanced control flow features, which have no direct equivalent in older languages like C, in later chapters. These include:</p>
<ul>
<li>Pattern matching with <code>match</code></li>
<li>Error handling using <code>Result</code> and <code>Option</code></li>
<li>The use of <code>if let</code> and <code>while let</code> for more concise control flow</li>
</ul>
<p>Unlike some languages, Rust avoids hidden control flow paths such as exception handling with <code>try/catch</code>. Instead, Rust uses the <code>Result</code> and <code>Option</code> types to handle errors in a more explicit and transparent way. We'll delve into these advanced control flow features, as well as <code>if let</code> and <code>while let</code>, in later chapters.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="71-conditional-statements"><a class="header" href="#71-conditional-statements">7.1 Conditional Statements</a></h2>
<p>Conditional statements allow your program to make decisions based on specific criteria. Rust's primary decision-making construct is the <code>if</code> statement, similar to C's, but with some key differences.</p>
<h3 id="711-conditions-must-be-boolean"><a class="header" href="#711-conditions-must-be-boolean">7.1.1 Conditions Must Be Boolean</a></h3>
<p>In Rust, conditions in <code>if</code> statements must explicitly be of type <code>bool</code>. Unlike C, where any non-zero integer is considered <code>true</code>, Rust does not perform implicit conversions from integers or other types to <code>bool</code>.</p>
<h4 id="comparison"><a class="header" href="#comparison">Comparison</a></h4>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">int number = 5;
if (number) {
    printf("Number is non-zero.\n");
}
</code></pre>
<p>In C, <code>number</code> being non-zero evaluates to <code>true</code>.</p>
<p><strong>Rust Equivalent:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number = 5;
    if number != 0 {
        println!("Number is non-zero.");
    }
}</code></pre></pre>
<p>In Rust, you must explicitly compare <code>number</code> to zero to produce a <code>bool</code>.</p>
<p><strong>Note:</strong> Attempting to use a non-boolean condition in Rust will result in a compile-time error, making your code safer by preventing unintended truthy or falsy evaluations.</p>
<h3 id="712-the-if-statement"><a class="header" href="#712-the-if-statement">7.1.2 The <code>if</code> Statement</a></h3>
<p>The <code>if</code> statement in Rust executes code based on a condition that evaluates to <code>true</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number = 5;
    if number &gt; 0 {
        println!("The number is positive.");
    }
}</code></pre></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>No Parentheses Required:</strong> Parentheses around the condition are optional in Rust.</li>
<li><strong>Braces Are Required:</strong> Even for single-line bodies, braces <code>{}</code> are required.</li>
</ul>
<h4 id="comparison-with-c-6"><a class="header" href="#comparison-with-c-6">Comparison with C</a></h4>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">int number = 5;
if (number &gt; 0) {
    printf("The number is positive.\n");
}
</code></pre>
<p>In C, parentheses around the condition are required, but braces are optional for single statements.</p>
<h3 id="713-else-if-and-else"><a class="header" href="#713-else-if-and-else">7.1.3 <code>else if</code> and <code>else</code></a></h3>
<p>You can extend <code>if</code> statements with <code>else if</code> and <code>else</code> clauses to handle multiple conditions.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number = 0;
    if number &gt; 0 {
        println!("The number is positive.");
    } else if number &lt; 0 {
        println!("The number is negative.");
    } else {
        println!("The number is zero.");
    }
}</code></pre></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Conditions Checked Sequentially:</strong> Conditions are evaluated from top to bottom.</li>
<li><strong>Exclusive Execution:</strong> Only the first branch where the condition evaluates to <code>true</code> is executed. If none of the conditions are met, the optional <code>else</code> branch is executed.</li>
<li><strong>Syntax Simplicity:</strong> No parentheses are needed around conditions, and Rust does not require <code>{}</code> between <code>else</code> and <code>if</code>.</li>
</ul>
<h4 id="comparison-with-c-7"><a class="header" href="#comparison-with-c-7">Comparison with C</a></h4>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">int number = 0;
if (number &gt; 0) {
    printf("The number is positive.\n");
} else if (number &lt; 0) {
    printf("The number is negative.\n");
} else {
    printf("The number is zero.\n");
}
</code></pre>
<p><strong>Note:</strong> In C, both parentheses around conditions and braces for code blocks are required by syntax rules.</p>
<h3 id="714-if-as-an-expression"><a class="header" href="#714-if-as-an-expression">7.1.4 <code>if</code> as an Expression</a></h3>
<p>In Rust, <code>if</code> statements can be used as expressions that return values. This allows you to assign the result of an <code>if</code> expression to a variable.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let condition = true;
    let number = if condition { 10 } else { 20 };
    println!("The number is: {}", number);
}</code></pre></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Expression-Based:</strong> Both <code>if</code> and <code>else</code> branches must return values.</li>
<li><strong>Type Consistency:</strong> All branches must return values of the same type.</li>
<li><strong>No Ternary Operator:</strong> Rust uses <code>if</code> expressions instead of the ternary operator found in C.</li>
</ul>
<p>When using <code>if</code> as an expression to assign a value, Rust requires that all possible conditions are covered. This means that you must include an <code>else</code> clause. Without an <code>else</code> clause, the <code>if</code> expression might not return a value in some cases, leading to a compile-time error.</p>
<h4 id="comparison-with-the-ternary-operator-in-c"><a class="header" href="#comparison-with-the-ternary-operator-in-c">Comparison with the Ternary Operator in C</a></h4>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">int condition = 1; // true
int number = condition ? 10 : 20;
printf("The number is: %d\n", number);
</code></pre>
<h3 id="715-type-consistency-in-if-expressions"><a class="header" href="#715-type-consistency-in-if-expressions">7.1.5 Type Consistency in <code>if</code> Expressions</a></h3>
<p>All branches of an <code>if</code> expression must return values of the same type.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        "six" // Error: mismatched types
    };
}</code></pre></pre>
<p><strong>Error:</strong></p>
<pre><code>error[E0308]: if and else have incompatible types
</code></pre>
<p><strong>Explanation:</strong> The <code>if</code> branch returns an <code>i32</code>, but the <code>else</code> branch returns a <code>&amp;str</code>. Rust's type system enforces consistency to prevent runtime errors.</p>
<h3 id="716-the-match-statement"><a class="header" href="#716-the-match-statement">7.1.6 The <code>match</code> Statement</a></h3>
<p>Rust's <code>match</code> statement is a powerful control flow construct for pattern matching. It is more versatile than C's <code>switch</code> statement.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let number = 2;
    match number {
        1 =&gt; println!("One"),
        2 =&gt; println!("Two"),
        3 =&gt; println!("Three"),
        _ =&gt; println!("Other"),
    }
}</code></pre></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Patterns:</strong> <code>match</code> can handle a wide range of patterns.</li>
<li><strong>Exhaustiveness Checking:</strong> The compiler ensures all possible cases are covered.</li>
<li><strong>Wildcard Pattern <code>_</code>:</strong> Acts as a catch-all, similar to <code>default</code> in C.</li>
</ul>
<h4 id="comparison-with-cs-switch"><a class="header" href="#comparison-with-cs-switch">Comparison with C's <code>switch</code></a></h4>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">int number = 2;
switch (number) {
    case 1:
        printf("One\n");
        break;
    case 2:
        printf("Two\n");
        break;
    default:
        printf("Other\n");
        break;
}
</code></pre>
<p><strong>Advantages of Rust's <code>match</code>:</strong></p>
<ul>
<li><strong>No Fall-Through:</strong> Each arm is independent; there's no implicit fall-through.</li>
<li><strong>Pattern Matching:</strong> Can match on more complex patterns, including ranges and destructured data.</li>
</ul>
<p>We will explore Rust's powerful pattern matching and the <code>match</code> statement in full detail in a later chapter.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="72-loops"><a class="header" href="#72-loops">7.2 Loops</a></h2>
<p>Loops allow you to execute a block of code repeatedly. Rust provides several looping constructs, some of which differ significantly from those in C.</p>
<h3 id="721-the-loop-construct"><a class="header" href="#721-the-loop-construct">7.2.1 The <code>loop</code> Construct</a></h3>
<p>The <code>loop</code> construct creates an infinite loop unless explicitly broken out of.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut count = 0;
    loop {
        println!("Count is: {}", count);
        count += 1;
        if count == 5 {
            break;
        }
    }
}</code></pre></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Infinite Loop:</strong> Continues indefinitely unless <code>break</code> is used.</li>
<li><strong>Can Return Values:</strong> Loops can return values using <code>break</code> with a value.</li>
</ul>
<h4 id="loops-as-expressions"><a class="header" href="#loops-as-expressions">Loops as Expressions</a></h4>
<p>Loops can return values when you use <code>break</code> with a value.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut count = 0;
    let result = loop {
        count += 1;
        if count == 10 {
            break count * 2;
        }
    };
    println!("The result is: {}", result);
}</code></pre></pre>
<p><strong>Explanation:</strong> When <code>count</code> reaches <code>10</code>, the loop breaks and returns <code>count * 2</code>, which is <code>20</code>. The value is assigned to <code>result</code>.</p>
<h3 id="722-the-while-loop"><a class="header" href="#722-the-while-loop">7.2.2 The <code>while</code> Loop</a></h3>
<p>A <code>while</code> loop runs as long as a condition is <code>true</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let mut count = 0;
    while count &lt; 5 {
        println!("Count is: {}", count);
        count += 1;
    }
}</code></pre></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Condition Checked Before Each Iteration:</strong> If the condition is false initially, the loop body may not execute at all.</li>
<li><strong>Mutable Variables:</strong> Often used with variables that need to be updated within the loop.</li>
</ul>
<h4 id="comparison-with-c-8"><a class="header" href="#comparison-with-c-8">Comparison with C</a></h4>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">int count = 0;
while (count &lt; 5) {
    printf("Count is: %d\n", count);
    count++;
}
</code></pre>
<h3 id="723-the-for-loop"><a class="header" href="#723-the-for-loop">7.2.3 The <code>for</code> Loop</a></h3>
<p>Rust's <code>for</code> loop is used to iterate over collections or ranges. It differs from the traditional C-style <code>for</code> loop.</p>
<h4 id="iterating-over-ranges"><a class="header" href="#iterating-over-ranges">Iterating Over Ranges</a></h4>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    for i in 0..5 {
        println!("i is {}", i);
    }
}</code></pre></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Range Syntax <code>start..end</code>:</strong> Includes <code>start</code>, excludes <code>end</code>.</li>
<li><strong>Inclusive Range <code>..=</code>:</strong> Use <code>start..=end</code> to include <code>end</code>.</li>
</ul>
<h4 id="iterating-over-collections"><a class="header" href="#iterating-over-collections">Iterating Over Collections</a></h4>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let numbers = [10, 20, 30];
    for number in numbers {
        println!("Number is {}", number);
    }
}</code></pre></pre>
<p><strong>Explanation:</strong> You can iterate directly over arrays and slices without needing to call <code>.iter()</code>.</p>
<p><strong>Comparison with C's <code>for</code> Loop</strong></p>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">for (int i = 0; i &lt; 5; i++) {
    printf("i is %d\n", i);
}
</code></pre>
<p><strong>Note:</strong> Rust does not have a traditional C-style <code>for</code> loop with initialization, condition, and increment expressions. Rust's <code>for</code> loop is more like a "for-each" loop, emphasizing safety and clarity.</p>
<h3 id="724-labeled-breaks-and-continues-in-nested-loops"><a class="header" href="#724-labeled-breaks-and-continues-in-nested-loops">7.2.4 Labeled Breaks and Continues in Nested Loops</a></h3>
<p>In Rust, the <code>loop</code>, <code>while</code>, and <code>for</code> constructs can all use the <code>break</code> and <code>continue</code> keywords. The <code>continue</code> keyword skips the rest of the current loop iteration and jumps to the beginning of the loop. In the case of nested loops, labels can be used to specify which loop you want to break out of or continue.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    'outer: for i in 0..3 {
        for j in 0..3 {
            if i == j {
                continue 'outer;
            }
            if i + j == 4 {
                break 'outer;
            }
            println!("i = {}, j = {}", i, j);
        }
    }
}</code></pre></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li><strong>Labels:</strong> Defined using a single quote followed by a name (e.g., <code>'outer</code>).</li>
<li><strong><code>break</code> and <code>continue</code> with Labels:</strong> Control flow can break out of or continue specific loops.</li>
</ul>
<h4 id="comparison-with-c-9"><a class="header" href="#comparison-with-c-9">Comparison with C</a></h4>
<p>C does not have labeled <code>break</code> or <code>continue</code>. Similar behavior can be achieved using <code>goto</code>, but this is generally discouraged due to readability and maintainability concerns.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="73-key-differences-between-rust-and-c-control-flow"><a class="header" href="#73-key-differences-between-rust-and-c-control-flow">7.3 Key Differences Between Rust and C Control Flow</a></h2>
<ul>
<li><strong>Boolean Conditions:</strong> Rust requires conditions to be <code>bool</code>.</li>
<li><strong>No Implicit Type Conversion:</strong> Types are not implicitly converted in conditions.</li>
<li><strong>No Traditional <code>for</code> Loop:</strong> Rust's <code>for</code> loop iterates over ranges or collections.</li>
<li><strong>No <code>do-while</code> Loop:</strong> Rust doesn't have a <code>do-while</code> loop, but <code>loop</code> can be used to achieve similar behavior.</li>
<li><strong>Pattern Matching with <code>match</code>:</strong> More powerful and safer than C's <code>switch</code>.</li>
<li><strong>No Implicit Fall-Through:</strong> In <code>match</code> statements, each arm is independent.</li>
<li><strong>Error Handling Without Exceptions:</strong> Rust uses <code>Result</code> and <code>Option</code> types for explicit error handling.</li>
<li><strong>Exhaustive <code>if</code> Expressions:</strong> Must cover all possible conditions when used as expressions.</li>
<li><strong>Variable Scope:</strong> Variables in Rust have stricter scoping rules, enhancing safety.</li>
<li><strong>No Implicit Variable Declaration:</strong> Variables must be declared before use, preventing accidental usage of undeclared variables.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="74-summary"><a class="header" href="#74-summary">7.4 Summary</a></h2>
<p>In this chapter, we've explored:</p>
<ul>
<li><strong>Conditional Statements:</strong>
<ul>
<li>Rust's <code>if</code>, <code>else if</code>, and <code>else</code> statements.</li>
<li>The requirement for conditions to be <code>bool</code>.</li>
<li>Using <code>if</code> as an expression to assign values.</li>
<li>Type consistency in <code>if</code> expressions.</li>
</ul>
</li>
<li><strong>The <code>match</code> Statement:</strong>
<ul>
<li>Pattern matching with <code>match</code>.</li>
<li>Comparison with C's <code>switch</code> statement.</li>
</ul>
</li>
<li><strong>Looping Constructs:</strong>
<ul>
<li>The <code>loop</code> construct for infinite loops.</li>
<li>Returning values from loops using <code>break</code>.</li>
<li>The <code>while</code> loop and its usage.</li>
<li>The <code>for</code> loop for iterating over ranges and collections.</li>
<li>Labeled <code>break</code> and <code>continue</code> in nested loops.</li>
</ul>
</li>
<li><strong>Key Differences Between Rust and C:</strong>
<ul>
<li>Emphasizing Rust's stricter type and scoping rules.</li>
<li>Highlighting the absence of certain constructs from C.</li>
</ul>
</li>
</ul>
<p>Understanding control flow in Rust is crucial for writing effective and idiomatic Rust code. Rust's control flow constructs provide safety and clarity, helping you avoid common pitfalls found in other languages.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="75-closing-thoughts"><a class="header" href="#75-closing-thoughts">7.5 Closing Thoughts</a></h2>
<p>Rust's control flow mechanisms are designed with safety and expressiveness in mind. By enforcing strict type checks and preventing implicit conversions, Rust helps you catch errors at compile time rather than at runtime.</p>
<p>As you continue your journey in Rust, remember to:</p>
<ul>
<li>Embrace Rust's emphasis on explicitness and type safety.</li>
<li>Leverage the power of <code>match</code> for pattern matching and decision-making.</li>
<li>Understand the scope and lifetime of variables to write safe and efficient code.</li>
<li>Practice writing loops using Rust's constructs to become familiar with their nuances.</li>
</ul>
<p>In the next chapters, we'll delve deeper into Rust's advanced control flow features, including pattern matching with <code>match</code>, error handling using <code>Result</code> and <code>Option</code>, and the use of <code>if let</code> and <code>while let</code> for more concise control flow.</p>
<p>Happy coding!</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8-functions-in-rust"><a class="header" href="#chapter-8-functions-in-rust">Chapter 8: Functions in Rust</a></h1>
<p>Functions are fundamental building blocks in any programming language. They allow you to encapsulate code for reuse, improve readability, and manage complexity. In Rust, functions are first-class citizens, and understanding how to define and use them is essential.</p>
<p>In this chapter, we'll explore functions in Rust in detail, covering:</p>
<ul>
<li>Defining and calling functions</li>
<li>The <code>main</code> function</li>
<li>Parameters and return types</li>
<li>The <code>return</code> keyword and implicit returns</li>
<li>Function scope and visibility</li>
<li>Default parameters and named arguments</li>
<li>Slices and tuples as parameters and return types</li>
<li>Function pointers and higher-order functions</li>
<li>Nested functions and scope</li>
<li>Tail call optimization and recursion</li>
<li>Inlining functions</li>
<li>Generics in functions</li>
<li>Type inference for function return types</li>
<li>Method syntax and associated functions</li>
<li>Function overloading</li>
<li>Variadic functions and macros</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="81-defining-and-calling-functions"><a class="header" href="#81-defining-and-calling-functions">8.1 Defining and Calling Functions</a></h2>
<h3 id="811-basic-function-definition"><a class="header" href="#811-basic-function-definition">8.1.1 Basic Function Definition</a></h3>
<p>In Rust, functions are defined using the <code>fn</code> keyword, followed by the function name, an optional parameter list enclosed in parentheses <code>()</code>, and an optional return type specified after <code>-&gt;</code>. The function body is a block of code enclosed in braces <code>{}</code>. The portion preceding the function body is often referred to as the function header or signature.</p>
<pre><code class="language-rust ignore">fn function_name(parameter1: Type1, parameter2: Type2) -&gt; ReturnType {
    // Function body
}</code></pre>
<ul>
<li><strong>Parameters</strong>: Each parameter must have a name and a type, separated by a colon <code>:</code>.</li>
<li><strong>Return Type</strong>: Specified after the <code>-&gt;</code> symbol. If omitted, the function returns the unit type <code>()</code>, similar to <code>void</code> in C.</li>
<li><strong>Function Body</strong>: Contains the code to be executed when the function is called.</li>
</ul>
<p><strong>Function Position in Code</strong></p>
<ul>
<li>In Rust, the position of function definitions in the program text does not matter. You can call a function before its definition appears in the code.</li>
<li>There is no need for separate function declarations (prototypes) as in C. The Rust compiler reads the entire module before compilation, so it knows all function definitions.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    let result = add(5, 3);
    println!("Result: {}", result);
}

fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}</code></pre></pre>
<ul>
<li>Here, <code>add</code> is called before it is defined, and the compiler has no issue with that.</li>
</ul>
<h4 id="comparison-with-c-10"><a class="header" href="#comparison-with-c-10">Comparison with C</a></h4>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int add(int a, int b); // Function declaration (prototype)

int main() {
    int result = add(5, 3);
    printf("Result: %d\n", result);
    return 0;
}

int add(int a, int b) { // Function definition
    return a + b;
}
</code></pre>
<ul>
<li>In C, if you call a function before its definition, you must provide a function declaration (prototype) beforehand.</li>
<li>Rust does not require function declarations; functions are defined once with their full signature and body.</li>
</ul>
<h3 id="812-calling-functions"><a class="header" href="#812-calling-functions">8.1.2 Calling Functions</a></h3>
<p>You can call any function you've defined by using its name followed by parentheses. If the function accepts arguments, they are placed inside the parentheses, separated by commas. Arguments must be passed in the same order as specified in the function's parameter list. Within the function body, parameters are used just like regular variables.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    greet("Alice");
}
fn greet(name: &amp;str) {
    println!("Hello, {}!", name);
}</code></pre></pre>
<ul>
<li>The <code>greet</code> function is called with the argument <code>"Alice"</code>.</li>
</ul>
<p><strong>Key Points</strong></p>
<ul>
<li><strong>Function Name</strong>: The name of the function you want to call.</li>
<li><strong>Parentheses</strong>: Always required, even if the function takes no arguments.</li>
<li><strong>Arguments</strong>: Provided inside the parentheses, separated by commas.</li>
</ul>
<h3 id="813-function-scope-and-visibility"><a class="header" href="#813-function-scope-and-visibility">8.1.3 Function Scope and Visibility</a></h3>
<p>Rust doesn't enforce a specific location for function definitions, as long as they are visible to the caller.</p>
<ul>
<li><strong>Top-Level Functions</strong>: Functions defined at the module level are visible throughout the module and can be called from anywhere within it.</li>
<li><strong>Nested Functions</strong>: Functions defined inside other functions (nested functions) are only visible within the enclosing function.</li>
</ul>
<p><strong>Example of Visibility:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    outer_function();
}

fn outer_function() {
    fn inner_function() {
        println!("This is the inner function.");
    }

    inner_function(); // This works
}

// inner_function(); // Error: not found in this scope</code></pre></pre>
<ul>
<li>The <code>inner_function</code> is only visible within <code>outer_function</code> and cannot be called from <code>main</code> or elsewhere.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="82-the-main-function"><a class="header" href="#82-the-main-function">8.2 The <code>main</code> Function</a></h2>
<p>Every Rust program must have exactly one <code>main</code> function, which serves as the entry point of the program.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    // Program entry point
}</code></pre></pre>
<ul>
<li><strong>Parameters</strong>: By default, the <code>main</code> function does not take parameters. However, you can use <code>std::env::args</code> to access command-line arguments.</li>
<li><strong>Return Type</strong>: The <code>main</code> function typically returns the unit type <code>()</code>. You can also have it return a <code>Result&lt;(), E&gt;</code> for error handling.</li>
</ul>
<h3 id="821-using-command-line-arguments"><a class="header" href="#821-using-command-line-arguments">8.2.1 Using Command-Line Arguments</a></h3>
<p>To access command-line arguments, you can use the <code>std::env</code> module.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::env;
fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!("Arguments: {:?}", args);
}</code></pre></pre>
<h3 id="822-returning-a-result-from-main"><a class="header" href="#822-returning-a-result-from-main">8.2.2 Returning a <code>Result</code> from <code>main</code></a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    // Your code here
    Ok(())
}</code></pre></pre>
<ul>
<li>Returning a <code>Result</code> allows the use of the <code>?</code> operator for error handling in the <code>main</code> function.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="83-parameters-and-return-types"><a class="header" href="#83-parameters-and-return-types">8.3 Parameters and Return Types</a></h2>
<h3 id="831-parameter-types"><a class="header" href="#831-parameter-types">8.3.1 Parameter Types</a></h3>
<p>In Rust, function parameters must always have explicitly defined types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greet(name: &amp;str) {
    println!("Hello, {}!", name);
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The <code>name</code> parameter is a string slice (<code>&amp;str</code>).</li>
<li>This function does not return a value (returns the unit type <code>()</code> implicitly).</li>
</ul>
<h3 id="832-return-types"><a class="header" href="#832-return-types">8.3.2 Return Types</a></h3>
<p>The return type is specified after the <code>-&gt;</code> symbol. If a function doesn't return a value, you can omit the return type or specify <code>-&gt; ()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_five() -&gt; i32 {
    5
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>This function returns an <code>i32</code>.</li>
</ul>
<h3 id="833-the-return-keyword-and-implicit-returns"><a class="header" href="#833-the-return-keyword-and-implicit-returns">8.3.3 The <code>return</code> Keyword and Implicit Returns</a></h3>
<p>In Rust, you can use the <code>return</code> keyword to return a value early, but it is common to omit it and let the last expression in the function body serve as the return value.</p>
<h4 id="using-return"><a class="header" href="#using-return">Using <code>return</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn square(x: i32) -&gt; i32 {
    return x * x;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="implicit-return"><a class="header" href="#implicit-return">Implicit Return</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn square(x: i32) -&gt; i32 {
    x * x // No semicolon; this expression is returned
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Important:</strong> The last expression without a semicolon is returned.</li>
<li>Adding a semicolon turns the expression into a statement that doesn't return a value.</li>
</ul>
<h4 id="comparison-with-c-11"><a class="header" href="#comparison-with-c-11">Comparison with C</a></h4>
<p>In C, the <code>return</code> keyword is always required when returning a value from a function.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="84-default-parameter-values-and-named-arguments"><a class="header" href="#84-default-parameter-values-and-named-arguments">8.4 Default Parameter Values and Named Arguments</a></h2>
<p>Rust does not support default parameter values or named arguments when calling functions.</p>
<ul>
<li><strong>Default Parameters</strong>: In some languages, you can specify default values for parameters so that callers can omit them. Rust does not support this feature.</li>
<li><strong>Named Arguments</strong>: Some languages allow you to specify arguments by name when calling a function. Rust requires that arguments are provided in the order they are defined, without naming them.</li>
</ul>
<p><strong>Example of Non-Supported Syntax:</strong></p>
<pre><code class="language-rust ignore">// This is not valid Rust
fn display(message: &amp;str, repeat: u32 = 1) {
    for _ in 0..repeat {
        println!("{}", message);
    }
}

fn main() {
    display("Hello"); // Error: missing argument for `repeat`
    display("Hello", repeat: 3); // Error: named arguments not supported
}</code></pre>
<p><strong>Workaround Using Option Types or Builder Patterns</strong></p>
<p>To achieve similar functionality, you can use <code>Option&lt;T&gt;</code> types for optional parameters or employ the builder pattern.</p>
<h3 id="using-optiont-for-optional-parameters"><a class="header" href="#using-optiont-for-optional-parameters">Using <code>Option&lt;T&gt;</code> for Optional Parameters</a></h3>
<p>You can define parameters as <code>Option&lt;T&gt;</code>, allowing callers to pass <code>None</code> to use a default value.</p>
<pre><pre class="playground"><code class="language-rust editable">fn display(message: &amp;str, repeat: Option&lt;u32&gt;) {
    let times = repeat.unwrap_or(1);
    for _ in 0..times {
        println!("{}", message);
    }
}

fn main() {
    display("Hello", None);         // Uses default repeat of 1
    display("Hi", Some(3));         // Repeats 3 times
}</code></pre></pre>
<ul>
<li>The <code>unwrap_or</code> method provides a default value if <code>None</code> is passed.</li>
<li>Callers must explicitly pass <code>Some(value)</code> or <code>None</code>.</li>
</ul>
<h3 id="using-the-builder-pattern"><a class="header" href="#using-the-builder-pattern">Using the Builder Pattern</a></h3>
<p>The builder pattern allows you to construct complex objects step by step. It's useful when you have many optional parameters.</p>
<pre><pre class="playground"><code class="language-rust editable">struct DisplayConfig {
    message: String,
    repeat: u32,
}

impl DisplayConfig {
    fn new(message: &amp;str) -&gt; Self {
        DisplayConfig {
            message: message.to_string(),
            repeat: 1, // Default value
        }
    }

    fn repeat(mut self, times: u32) -&gt; Self {
        self.repeat = times;
        self
    }

    fn show(&amp;self) {
        for _ in 0..self.repeat {
            println!("{}", self.message);
        }
    }
}

fn main() {
    DisplayConfig::new("Hello").show();          // Uses default repeat of 1
    DisplayConfig::new("Hi").repeat(3).show();   // Repeats 3 times
}</code></pre></pre>
<ul>
<li>The <code>DisplayConfig</code> struct acts as a builder.</li>
<li>Methods like <code>repeat</code> modify the configuration and return <code>self</code>, allowing method chaining.</li>
<li>This pattern provides flexibility similar to functions with default parameters and named arguments.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="85-slices-as-parameters-and-return-types"><a class="header" href="#85-slices-as-parameters-and-return-types">8.5 Slices as Parameters and Return Types</a></h2>
<p>Slices allow functions to work with portions of collections without taking ownership.</p>
<h3 id="851-string-slices"><a class="header" href="#851-string-slices">8.5.1 String Slices</a></h3>
<h4 id="passing-string-slices-to-functions"><a class="header" href="#passing-string-slices-to-functions">Passing String Slices to Functions</a></h4>
<pre><pre class="playground"><code class="language-rust editable">fn print_slice(s: &amp;str) {
    println!("Slice: {}", s);
}

fn main() {
    let s = String::from("Hello, world!");
    print_slice(&amp;s[7..12]); // Passes "world"
    print_slice(&amp;s);        // Passes the entire string
    print_slice("Hello");   // String literals are &amp;str
}</code></pre></pre>
<ul>
<li>Functions that take <code>&amp;str</code> can accept both string slices and string literals.</li>
</ul>
<h4 id="returning-string-slices"><a class="header" href="#returning-string-slices">Returning String Slices</a></h4>
<p>Returning slices requires careful handling of lifetimes to ensure safety.</p>
<pre><pre class="playground"><code class="language-rust editable">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[..i];
        }
    }
    &amp;s
}

fn main() {
    let s = String::from("Hello world");
    let word = first_word(&amp;s);
    println!("First word: {}", word);
}</code></pre></pre>
<ul>
<li>The <code>first_word</code> function returns a slice of the input string.</li>
</ul>
<h3 id="852-array-slices"><a class="header" href="#852-array-slices">8.5.2 Array Slices</a></h3>
<h4 id="passing-array-slices-to-functions"><a class="header" href="#passing-array-slices-to-functions">Passing Array Slices to Functions</a></h4>
<pre><pre class="playground"><code class="language-rust editable">fn sum(slice: &amp;[i32]) -&gt; i32 {
    slice.iter().sum()
}
fn main() {
    let arr = [1, 2, 3, 4, 5];
    let total = sum(&amp;arr);
    println!("Total sum: {}", total);
}</code></pre></pre>
<ul>
<li>The function <code>sum</code> takes a slice of integers and returns their sum.</li>
</ul>
<h3 id="853-slices-with-vectors"><a class="header" href="#853-slices-with-vectors">8.5.3 Slices with Vectors</a></h3>
<p>Vectors are resizable arrays in Rust. You can create slices from vectors as well.</p>
<pre><pre class="playground"><code class="language-rust editable">fn print_vector_slice(v: &amp;[i32]) {
    for item in v {
        println!("{}", item);
    }
}
fn main() {
    let v = vec![10, 20, 30, 40, 50];
    print_vector_slice(&amp;v[1..4]); // Prints 20, 30, 40
}</code></pre></pre>
<ul>
<li>Slices work uniformly across arrays and vectors.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="86-tuples-as-parameters-and-return-types"><a class="header" href="#86-tuples-as-parameters-and-return-types">8.6 Tuples as Parameters and Return Types</a></h2>
<p>Tuples group together multiple values of possibly different types.</p>
<h3 id="861-passing-tuples-to-functions"><a class="header" href="#861-passing-tuples-to-functions">8.6.1 Passing Tuples to Functions</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn print_point(point: (i32, i32)) {
    println!("Point is at ({}, {})", point.0, point.1);
}
fn main() {
    let p = (10, 20);
    print_point(p);
}</code></pre></pre>
<h3 id="862-returning-tuples-from-functions"><a class="header" href="#862-returning-tuples-from-functions">8.6.2 Returning Tuples from Functions</a></h3>
<pre><pre class="playground"><code class="language-rust editable">fn swap(x: i32, y: i32) -&gt; (i32, i32) {
    (y, x)
}
fn main() {
    let a = 5;
    let b = 10;
    let (b, a) = swap(a, b);
    println!("a: {}, b: {}", a, b);
}</code></pre></pre>
<ul>
<li>The <code>swap</code> function returns a tuple containing the swapped values.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="87-function-pointers-and-higher-order-functions"><a class="header" href="#87-function-pointers-and-higher-order-functions">8.7 Function Pointers and Higher-Order Functions</a></h2>
<h3 id="871-function-pointers"><a class="header" href="#871-function-pointers">8.7.1 Function Pointers</a></h3>
<p>You can pass functions as parameters using function pointers.</p>
<pre><pre class="playground"><code class="language-rust editable">fn add_one(x: i32) -&gt; i32 {
    x + 1
}
fn apply_function(f: fn(i32) -&gt; i32, value: i32) -&gt; i32 {
    f(value)
}
fn main() {
    let result = apply_function(add_one, 5);
    println!("Result: {}", result);
}</code></pre></pre>
<ul>
<li><code>fn(i32) -&gt; i32</code> is the type of a function that takes an <code>i32</code> and returns an <code>i32</code>.</li>
</ul>
<h3 id="872-higher-order-functions"><a class="header" href="#872-higher-order-functions">8.7.2 Higher-Order Functions</a></h3>
<p>Functions that take other functions as parameters or return functions are called higher-order functions.</p>
<p><strong>Note</strong>: Rust also has closures (anonymous functions), which will be discussed in a later chapter.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="88-nested-functions-and-scope"><a class="header" href="#88-nested-functions-and-scope">8.8 Nested Functions and Scope</a></h2>
<h3 id="881-nested-functions"><a class="header" href="#881-nested-functions">8.8.1 Nested Functions</a></h3>
<p>In Rust, you can define functions inside other functions. These are called nested functions or inner functions.</p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    fn inner_function() {
        println!("This is an inner function.");
    }
    inner_function();
    println!("This is the main function.");
}</code></pre></pre>
<ul>
<li><strong>Scope</strong>: The inner function <code>inner_function</code> is only visible within the <code>main</code> function.</li>
</ul>
<h3 id="882-function-visibility"><a class="header" href="#882-function-visibility">8.8.2 Function Visibility</a></h3>
<ul>
<li><strong>Top-Level Functions</strong>: Visible throughout the module.</li>
<li><strong>Nested Functions</strong>: Only visible within the enclosing function.</li>
<li>You cannot call a nested function from outside its scope.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn main() {
    outer_function();
    // inner_function(); // Error: not found in this scope
}
fn outer_function() {
    fn inner_function() {
        println!("Inner function");
    }
    inner_function(); // This works
}</code></pre></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="89-generics-in-functions"><a class="header" href="#89-generics-in-functions">8.9 Generics in Functions</a></h2>
<p>Generics allow you to write flexible and reusable code by parameterizing types.</p>
<h3 id="891-max-function-variants"><a class="header" href="#891-max-function-variants">8.9.1 Max Function Variants</a></h3>
<h4 id="variant-1-using-i32-parameters"><a class="header" href="#variant-1-using-i32-parameters">Variant 1: Using <code>i32</code> Parameters</a></h4>
<pre><pre class="playground"><code class="language-rust editable">fn max_i32(a: i32, b: i32) -&gt; i32 {
    if a &gt; b { a } else { b }
}
fn main() {
    let result = max_i32(5, 10);
    println!("The maximum is {}", result);
}</code></pre></pre>
<ul>
<li>A simple function that works only with <code>i32</code> types.</li>
</ul>
<h4 id="variant-2-using-references"><a class="header" href="#variant-2-using-references">Variant 2: Using References</a></h4>
<pre><pre class="playground"><code class="language-rust editable">fn max_ref&lt;'a&gt;(a: &amp;'a i32, b: &amp;'a i32) -&gt; &amp;'a i32 {
    if a &gt; b { a } else { b }
}
fn main() {
    let x = 5;
    let y = 10;
    let result = max_ref(&amp;x, &amp;y);
    println!("The maximum is {}", result);
}</code></pre></pre>
<ul>
<li>This function accepts references to <code>i32</code> and returns a reference to the maximum value.</li>
</ul>
<h4 id="variant-3-using-generics"><a class="header" href="#variant-3-using-generics">Variant 3: Using Generics</a></h4>
<pre><pre class="playground"><code class="language-rust editable">use std::cmp::PartialOrd;
fn max_generic&lt;T: PartialOrd&gt;(a: T, b: T) -&gt; T {
    if a &gt; b { a } else { b }
}
fn main() {
    let int_max = max_generic(5, 10);
    let float_max = max_generic(5.5, 2.3);
    println!("The maximum integer is {}", int_max);
    println!("The maximum float is {}", float_max);
}</code></pre></pre>
<ul>
<li>The <code>max_generic</code> function works with any type that implements the <code>PartialOrd</code> trait (i.e., can be compared).</li>
</ul>
<p>Generics will be explored in more detail in a later chapter.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="810-tail-call-optimization-and-recursion"><a class="header" href="#810-tail-call-optimization-and-recursion">8.10 Tail Call Optimization and Recursion</a></h2>
<h3 id="8101-recursive-functions"><a class="header" href="#8101-recursive-functions">8.10.1 Recursive Functions</a></h3>
<p>Rust supports recursive functions, similar to C.</p>
<pre><pre class="playground"><code class="language-rust editable">fn factorial(n: u64) -&gt; u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}
fn main() {
    let result = factorial(5);
    println!("Factorial of 5 is {}", result);
}</code></pre></pre>
<h3 id="8102-tail-call-optimization"><a class="header" href="#8102-tail-call-optimization">8.10.2 Tail Call Optimization</a></h3>
<p><strong>Tail call optimization (TCO)</strong> is a technique where the compiler can optimize recursive function calls that are in tail position (the last action in the function) to reuse the current function's stack frame, preventing additional stack growth.</p>
<ul>
<li><strong>In Rust:</strong> Tail call optimization is not guaranteed by the compiler. Deep recursion may lead to stack overflows.</li>
<li><strong>Recommendation:</strong> For large recursive computations, consider using iterative approaches or explicit stack structures.</li>
</ul>
<p><strong>Example of Tail Recursion:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">fn factorial_tail(n: u64, acc: u64) -&gt; u64 {
    if n == 0 {
        acc
    } else {
        factorial_tail(n - 1, n * acc)
    }
}
fn main() {
    let result = factorial_tail(5, 1);
    println!("Factorial of 5 is {}", result);
}</code></pre></pre>
<ul>
<li>Even though <code>factorial_tail</code> is tail-recursive, Rust does not optimize it to prevent stack growth.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="811-inlining-functions"><a class="header" href="#811-inlining-functions">8.11 Inlining Functions</a></h2>
<p>Inlining is an optimization where the compiler replaces a function call with the function's body to eliminate the overhead of the call.</p>
<ul>
<li><strong>In Rust:</strong> The compiler can automatically inline functions during optimization passes.</li>
<li><strong>Attributes:</strong> You can suggest inlining using attributes, but the compiler makes the final decision.</li>
</ul>
<h3 id="8111-using-the-inline-attribute"><a class="header" href="#8111-using-the-inline-attribute">8.11.1 Using the <code>#[inline]</code> Attribute</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[inline]
fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong><code>#[inline]</code></strong>: Hints to the compiler that it should consider inlining the function.</li>
<li><strong><code>#[inline(always)]</code></strong>: A stronger hint to always inline the function.</li>
<li><strong>Note:</strong> Overusing inlining can lead to code bloat.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="812-method-syntax-and-associated-functions"><a class="header" href="#812-method-syntax-and-associated-functions">8.12 Method Syntax and Associated Functions</a></h2>
<p>Methods are functions associated with a type, defined within an <code>impl</code> block.</p>
<h3 id="8121-defining-methods"><a class="header" href="#8121-defining-methods">8.12.1 Defining Methods</a></h3>
<pre><pre class="playground"><code class="language-rust editable">struct Rectangle {
    width: u32,
    height: u32,
}
impl Rectangle {
    // Associated function (constructor)
    fn new(width: u32, height: u32) -&gt; Rectangle {
        Rectangle { width, height }
    }
    // Method that borrows self immutably
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
    // Method that borrows self mutably
    fn set_width(&amp;mut self, width: u32) {
        self.width = width;
    }
}
fn main() {
    let mut rect = Rectangle::new(10, 20);
    println!("Area: {}", rect.area());
    rect.set_width(15);
    println!("New area: {}", rect.area());
}</code></pre></pre>
<ul>
<li><strong>Associated Functions</strong>: Functions like <code>new</code> that are associated with a type but don't take <code>self</code> as a parameter.</li>
<li><strong>Methods</strong>: Functions that have <code>self</code> as a parameter, allowing access to the instance's data.</li>
</ul>
<h3 id="8122-method-calls"><a class="header" href="#8122-method-calls">8.12.2 Method Calls</a></h3>
<ul>
<li>
<p>Use the dot syntax to call methods: <code>instance.method()</code>.</p>
</li>
<li>
<p>The first parameter of a method is <code>self</code>, which can be:</p>
<ul>
<li><code>&amp;self</code>: Immutable borrow of the instance.</li>
<li><code>&amp;mut self</code>: Mutable borrow of the instance.</li>
<li><code>self</code>: Takes ownership of the instance.</li>
</ul>
</li>
</ul>
<p>Methods and associated functions will be covered in more detail when we explore Rust's struct type in a later chapter.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="813-function-overloading"><a class="header" href="#813-function-overloading">8.13 Function Overloading</a></h2>
<h3 id="8131-function-name-overloading"><a class="header" href="#8131-function-name-overloading">8.13.1 Function Name Overloading</a></h3>
<p>In some languages like C++, you can have multiple functions with the same name but different parameter types (function overloading). In Rust, function overloading based on parameter types is not supported.</p>
<ul>
<li>Each function must have a unique name within its scope.</li>
<li>If you need similar functionality for different types, you can use generics or traits.</li>
</ul>
<p><strong>Example of Using Traits:</strong></p>
<pre><pre class="playground"><code class="language-rust editable">trait Draw {
    fn draw(&amp;self);
}
struct Circle;
struct Square;
impl Draw for Circle {
    fn draw(&amp;self) {
        println!("Drawing a circle");
    }
}
impl Draw for Square {
    fn draw(&amp;self) {
        println!("Drawing a square");
    }
}
fn main() {
    let c = Circle;
    let s = Square;
    c.draw();
    s.draw();
}</code></pre></pre>
<ul>
<li>By implementing traits, you can achieve similar behavior without function overloading.</li>
</ul>
<h3 id="8132-method-overloading-with-traits"><a class="header" href="#8132-method-overloading-with-traits">8.13.2 Method Overloading with Traits</a></h3>
<p>Methods can appear to be overloaded when they're defined in different implementations for different types.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="814-type-inference-for-function-return-types"><a class="header" href="#814-type-inference-for-function-return-types">8.14 Type Inference for Function Return Types</a></h2>
<p>Rust's type inference system can often determine the types of variables and expressions. However, for function signatures, return types usually need to be specified explicitly.</p>
<h3 id="8141-specifying-return-types"><a class="header" href="#8141-specifying-return-types">8.14.1 Specifying Return Types</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The return type <code>-&gt; i32</code> is specified explicitly.</li>
</ul>
<h3 id="8142-omission-of-return-types"><a class="header" href="#8142-omission-of-return-types">8.14.2 Omission of Return Types</a></h3>
<p>In certain cases, you can use the <code>impl Trait</code> syntax to allow the compiler to infer the return type, especially when returning closures or iterators.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_adder(x: i32) -&gt; impl Fn(i32) -&gt; i32 {
    move |y| x + y
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Here, <code>impl Fn(i32) -&gt; i32</code> tells the compiler that the function returns some type that implements the <code>Fn(i32) -&gt; i32</code> trait.</li>
</ul>
<p><strong>Note:</strong> For regular functions returning concrete types, you must specify the return type.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="815-variadic-functions-and-macros"><a class="header" href="#815-variadic-functions-and-macros">8.15 Variadic Functions and Macros</a></h2>
<p>Rust does not support variadic functions in the same way C does, but you can use macros or work with C functions in <code>unsafe</code> blocks.</p>
<h3 id="8151-variadic-functions-in-c"><a class="header" href="#8151-variadic-functions-in-c">8.15.1 Variadic Functions in C</a></h3>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void print_numbers(int count, ...) {
    va_list args;
    va_start(args, count);
    for(int i = 0; i &lt; count; i++) {
        int number = va_arg(args, int);
        printf("%d ", number);
    }
    va_end(args);
    printf("\n");
}

int main() {
    print_numbers(3, 10, 20, 30);
    return 0;
}
</code></pre>
<h3 id="8152-rust-equivalent-using-macros"><a class="header" href="#8152-rust-equivalent-using-macros">8.15.2 Rust Equivalent Using Macros</a></h3>
<p>Rust macros can accept a variable number of arguments.</p>
<pre><pre class="playground"><code class="language-rust editable">macro_rules! print_numbers {
    ($($x:expr),*) =&gt; {
        $(
            print!("{} ", $x);
        )*
        println!();
    };
}
fn main() {
    print_numbers!(10, 20, 30);
}</code></pre></pre>
<ul>
<li>Macros are a powerful feature in Rust that allow for metaprogramming.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="816-summary"><a class="header" href="#816-summary">8.16 Summary</a></h2>
<p>In this chapter, we've explored:</p>
<ul>
<li><strong>Function Definitions</strong>: Using <code>fn</code>, specifying parameters and return types.</li>
<li><strong>Calling Functions</strong>: Understanding how to call functions with arguments.</li>
<li><strong>Function Scope and Visibility</strong>: Knowing where functions can be called from.</li>
<li><strong>The <code>main</code> Function</strong>: Understanding the entry point of Rust programs.</li>
<li><strong>Parameters and Return Types</strong>: Including slices, tuples, and generics.</li>
<li><strong>The <code>return</code> Keyword</strong>: Using explicit and implicit returns.</li>
<li><strong>Default Parameter Values and Named Arguments</strong>: Noting that Rust does not support them and discussing workarounds using <code>Option&lt;T&gt;</code> and the builder pattern.</li>
<li><strong>Nested Functions and Scope</strong>: Defining functions within functions.</li>
<li><strong>Slices</strong>: Passing and returning slices with strings, arrays, and vectors.</li>
<li><strong>Tuples</strong>: Using tuples as parameters and return types.</li>
<li><strong>Function Pointers and Higher-Order Functions</strong>: Passing functions as arguments.</li>
<li><strong>Generics</strong>: Writing functions that work with multiple types.</li>
<li><strong>Function Overloading</strong>: Understanding that Rust does not support function overloading based on parameter types.</li>
<li><strong>Type Inference</strong>: Knowing when function return types can be omitted.</li>
<li><strong>Tail Call Optimization and Recursion</strong>: Understanding limitations in Rust.</li>
<li><strong>Inlining Functions</strong>: Using attributes to suggest inlining.</li>
<li><strong>Method Syntax</strong>: Defining methods and associated functions for structs.</li>
<li><strong>Variadic Functions and Macros</strong>: Simulating variadic functions using macros.</li>
<li><strong>Introduction to Closures</strong>: Noted that closures will be discussed in a later chapter.</li>
</ul>
<p>Understanding functions in Rust is crucial for writing modular, reusable, and efficient code. By leveraging Rust's features, you can write functions that are safe, expressive, and performant.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="817-exercises"><a class="header" href="#817-exercises">8.17 Exercises</a></h2>
<details>
  <summary>Click to see the list of suggested exercises</summary>
<ol>
<li>
<p><strong>Maximum Function Variants</strong></p>
<ul>
<li>
<p><strong>Variant 1</strong>: Write a function <code>max_i32</code> that takes two <code>i32</code> parameters and returns the maximum value.</p>
<pre><pre class="playground"><code class="language-rust editable">fn max_i32(a: i32, b: i32) -&gt; i32 {
    if a &gt; b { a } else { b }
}
fn main() {
    let result = max_i32(3, 7);
    println!("The maximum is {}", result);
}</code></pre></pre>
</li>
<li>
<p><strong>Variant 2</strong>: Write a function <code>max_ref</code> that takes references to <code>i32</code> values and returns a reference to the maximum value.</p>
<pre><pre class="playground"><code class="language-rust editable">fn max_ref&lt;'a&gt;(a: &amp;'a i32, b: &amp;'a i32) -&gt; &amp;'a i32 {
    if a &gt; b { a } else { b }
}
fn main() {
    let x = 5;
    let y = 10;
    let result = max_ref(&amp;x, &amp;y);
    println!("The maximum is {}", result);
}</code></pre></pre>
</li>
<li>
<p><strong>Variant 3</strong>: Write a generic function <code>max_generic</code> that works with any type that implements the <code>PartialOrd</code> and <code>Copy</code> traits.</p>
<pre><pre class="playground"><code class="language-rust editable">fn max_generic&lt;T: PartialOrd + Copy&gt;(a: T, b: T) -&gt; T {
    if a &gt; b { a } else { b }
}
fn main() {
    let int_max = max_generic(3, 7);
    let float_max = max_generic(2.5, 1.8);
    println!("The maximum integer is {}", int_max);
    println!("The maximum float is {}", float_max);
}</code></pre></pre>
</li>
</ul>
</li>
<li>
<p><strong>String Concatenation</strong>: Write a function <code>concat</code> that takes two string slices and returns a new <code>String</code> containing both.</p>
<pre><pre class="playground"><code class="language-rust editable">fn concat(s1: &amp;str, s2: &amp;str) -&gt; String {
    let mut result = String::from(s1);
    result.push_str(s2);
    result
}
fn main() {
    let result = concat("Hello, ", "world!");
    println!("{}", result);
}</code></pre></pre>
</li>
<li>
<p><strong>Distance Calculation</strong>: Define a function that calculates the Euclidean distance between two points in 2D space, using tuples as parameters.</p>
<pre><pre class="playground"><code class="language-rust editable">fn distance(p1: (f64, f64), p2: (f64, f64)) -&gt; f64 {
    let dx = p2.0 - p1.0;
    let dy = p2.1 - p1.1;
    (dx * dx + dy * dy).sqrt()
}
fn main() {
    let point1 = (0.0, 0.0);
    let point2 = (3.0, 4.0);
    println!("Distance: {}", distance(point1, point2));
}</code></pre></pre>
</li>
<li>
<p><strong>Array Reversal</strong>: Write a function that takes a mutable slice of <code>i32</code> and reverses its elements in place.</p>
<pre><pre class="playground"><code class="language-rust editable">fn reverse(slice: &amp;mut [i32]) {
    let len = slice.len();
    for i in 0..len / 2 {
        slice.swap(i, len - 1 - i);
    }
}
fn main() {
    let mut data = [1, 2, 3, 4, 5];
    reverse(&amp;mut data);
    println!("Reversed: {:?}", data);
}</code></pre></pre>
</li>
<li>
<p><strong>Implementing <code>find</code> Function</strong>: Write a function that searches for an element in a slice and returns its index using <code>Option&lt;usize&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">fn find(slice: &amp;[i32], target: i32) -&gt; Option&lt;usize&gt; {
    for (index, &amp;value) in slice.iter().enumerate() {
        if value == target {
            return Some(index);
        }
    }
    None
}
fn main() {
    let numbers = [10, 20, 30, 40, 50];
    match find(&amp;numbers, 30) {
        Some(index) =&gt; println!("Found at index {}", index),
        None =&gt; println!("Not found"),
    }
}</code></pre></pre>
</li>
</ol>
</details>
<div style="break-before: page; page-break-before: always;"></div><h2 id="818-closing-thoughts"><a class="header" href="#818-closing-thoughts">8.18 Closing Thoughts</a></h2>
<p>Functions are at the heart of Rust programming. They allow you to:</p>
<ul>
<li>Encapsulate logic</li>
<li>Reuse code</li>
<li>Improve readability</li>
<li>Ensure safety through Rust's ownership and borrowing rules</li>
</ul>
<p>As you continue your journey in Rust, you'll encounter more advanced features like closures, iterators, and asynchronous functions. The foundational knowledge of functions provided in this chapter will serve you well as you explore these topics.</p>
<p>Remember to:</p>
<ul>
<li>Experiment with your own functions to solidify your understanding.</li>
<li>Leverage Rust's strong type system and ownership rules to write safe and efficient code.</li>
<li>Refer back to this chapter as needed.</li>
</ul>
<p>Happy coding!</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-9-structs-in-rust"><a class="header" href="#chapter-9-structs-in-rust">Chapter 9: Structs in Rust</a></h1>
<p>Structs are a fundamental part of Rust's type system, allowing you to create complex data types that group together related values. They are similar to structs in C but offer additional features and safety guarantees. Structs are commonly used to model real-world entities and represent data with multiple related components (structures).</p>
<p>In this chapter, we'll explore:</p>
<ul>
<li>Defining structs</li>
<li>Instantiating and using structs</li>
<li>Field initialization and access</li>
<li>Struct update syntax</li>
<li>Tuple structs</li>
<li>Unit-like structs</li>
<li>Methods and associated functions</li>
<li>The <code>impl</code> block</li>
<li>The <code>self</code> parameter</li>
<li>Getters and setters</li>
<li>Structs and ownership</li>
<li>Structs with references and lifetimes</li>
<li>Generic structs</li>
<li>Comparing Rust structs with OOP concepts</li>
<li>Derived traits</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="91-defining-structs"><a class="header" href="#91-defining-structs">9.1 Defining Structs</a></h2>
<h3 id="911-basic-struct-definition"><a class="header" href="#911-basic-struct-definition">9.1.1 Basic Struct Definition</a></h3>
<p>In Rust, a <code>struct</code> is defined using the <code>struct</code> keyword, followed by the struct's name and its fields enclosed in curly braces <code>{}</code>. Each field in the struct consists of a field name, a colon <code>:</code>, and the field's type. Fields are separated by commas.</p>
<pre><code class="language-rust ignore">struct StructName {
    field1: Type1,
    field2: Type2,
    // ...
}</code></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Person {
    name: String,
    age: u8,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li><strong>Fields</strong>: Each field has a name and a type, separated by a colon <code>:</code>.</li>
<li><strong>Field List</strong>: Enclosed in curly braces <code>{}</code>, with fields separated by commas.</li>
<li><strong>Naming Conventions</strong>: Struct names typically use CamelCase, while field names are written in snake_case.</li>
<li><strong>Declaration</strong>: Struct types are usually declared at the module scope, though they can also be declared within functions.</li>
</ul>
<p>Structs group related data together, enabling you to model more complex data types in your programs.</p>
<h4 id="comparison-with-c-12"><a class="header" href="#comparison-with-c-12">Comparison with C</a></h4>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">struct Person {
    char* name;
    uint8_t age;
};
</code></pre>
<ul>
<li>In C, structs can be anonymous or named. In Rust, structs are always named.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="92-instantiating-and-using-structs"><a class="header" href="#92-instantiating-and-using-structs">9.2 Instantiating and Using Structs</a></h2>
<h3 id="921-creating-instances"><a class="header" href="#921-creating-instances">9.2.1 Creating Instances</a></h3>
<p>You can create an instance of a struct by specifying the struct's name and providing values for its fields.</p>
<pre><code class="language-rust ignore">let variable_name = StructName {
    field1: value1,
    field2: value2,
    // ...
};</code></pre>
<ul>
<li><strong>Field Order</strong>: Fields can be specified in any order when creating an instance.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span>fn main() {
    let person = Person {
        age: 30,
        name: String::from("Alice"),
    };
}</code></pre></pre>
<ul>
<li>The fields <code>age</code> and <code>name</code> are specified in a different order than in the struct definition, which is allowed.</li>
</ul>
<h3 id="922-field-initialization-and-access"><a class="header" href="#922-field-initialization-and-access">9.2.2 Field Initialization and Access</a></h3>
<h4 id="initializing-fields"><a class="header" href="#initializing-fields">Initializing Fields</a></h4>
<p>All fields must be initialized when creating an instance, unless the struct update syntax (discussed later) is used.</p>
<h4 id="accessing-fields"><a class="header" href="#accessing-fields">Accessing Fields</a></h4>
<p>You can access fields using dot notation.</p>
<pre><code class="language-rust ignore">println!("Name: {}", person.name);
println!("Age: {}", person.age);</code></pre>
<h3 id="923-mutability"><a class="header" href="#923-mutability">9.2.3 Mutability</a></h3>
<p>In Rust, the mutability of a struct instance applies to the entire instance, not to individual fields. You cannot have a struct instance where some fields are mutable and others are immutable. To modify any field within a struct, the entire instance must be declared as mutable using the <code>mut</code> keyword.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span>fn main() {
    let mut person = Person {
        name: String::from("Bob"),
        age: 25,
    };
    person.age += 1;
    println!("{} is now {} years old.", person.name, person.age);
}</code></pre></pre>
<ul>
<li><strong>Note</strong>: The <code>mut</code> keyword makes the entire <code>person</code> instance mutable, allowing modification of any of its fields.</li>
</ul>
<p>If you need to have some data that is mutable and some that is not, you may need to redesign your code, possibly by splitting the data into different structs or by using interior mutability patterns (which we will discuss in a later chapter).</p>
<h4 id="comparison-with-c-13"><a class="header" href="#comparison-with-c-13">Comparison with C</a></h4>
<p>In C, you can modify struct fields if the variable is not declared <code>const</code>.</p>
<p><strong>C Code:</strong></p>
<pre><code class="language-c">struct Person person = { "Bob", 25 };
person.age += 1;
printf("%s is now %d years old.\n", person.name, person.age);
</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="93-updating-struct-instances"><a class="header" href="#93-updating-struct-instances">9.3 Updating Struct Instances</a></h2>
<h3 id="931-struct-update-syntax"><a class="header" href="#931-struct-update-syntax">9.3.1 Struct Update Syntax</a></h3>
<p>Rust provides a convenient way to create a new struct instance by copying most of the values from another instance. This is called <strong>struct update syntax</strong>.</p>
<pre><code class="language-rust ignore">let new_instance = StructName {
    field1: new_value1,
    ..old_instance
};</code></pre>
<ul>
<li>The <code>..</code> syntax copies the remaining fields from <code>old_instance</code>.</li>
<li><strong>Field Order</strong>: The <code>..old_instance</code> must be specified last.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span>fn main() {
    let person1 = Person {
        name: String::from("Carol"),
        age: 22,
    };
    let person2 = Person {
        name: String::from("Dave"),
        ..person1
    };
    println!("{} is {} years old.", person2.name, person2.age);
}</code></pre></pre>
<ul>
<li><strong>Note</strong>: <code>person2</code> will have <code>name</code> set to <code>"Dave"</code> and <code>age</code> set to <code>22</code>, copied from <code>person1</code>.</li>
</ul>
<h4 id="ownership-considerations"><a class="header" href="#ownership-considerations">Ownership Considerations</a></h4>
<p>Using <code>..person1</code> in struct update syntax <strong>moves</strong> the values from <code>person1</code> to <code>person2</code>. After this operation, <code>person1</code> cannot be used if it contains types that do not implement the <code>Copy</code> trait (such as <code>String</code>).</p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span>fn main() {
    let person1 = Person {
        name: String::from("Carol"),
        age: 22,
    };
    let person2 = Person {
        name: String::from("Dave"),
        ..person1
    };
    // println!("Person1's name: {}", person1.name); // Error: borrow of moved value
}</code></pre></pre>
<ul>
<li>Since <code>String</code> does not implement <code>Copy</code>, <code>person1.name</code> has been moved to <code>person2.name</code>, and <code>person1</code> can no longer be used.</li>
</ul>
<h3 id="932-field-init-shorthand"><a class="header" href="#932-field-init-shorthand">9.3.2 Field Init Shorthand</a></h3>
<p>When the field name and the variable name are the same, you can use shorthand initialization.</p>
<pre><code class="language-rust ignore">let name = String::from("Eve");
let age = 28;

let person = Person { name, age };</code></pre>
<ul>
<li>This is equivalent to:</li>
</ul>
<pre><code class="language-rust ignore">let person = Person {
    name: name,
    age: age,
};</code></pre>
<h3 id="933-using-default-values"><a class="header" href="#933-using-default-values">9.3.3 Using Default Values</a></h3>
<p>If a struct implements the <code>Default</code> trait, you can create a default instance and then override specific fields.</p>
<p>First, derive the <code>Default</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Default)]
struct Person {
    name: String,
    age: u8,
}
<span class="boring">}</span></code></pre></pre>
<p>You can create a default instance in two ways:</p>
<ol>
<li>
<p>Using <code>Person::default()</code>:</p>
<pre><code class="language-rust ignore">let person = Person::default();</code></pre>
</li>
<li>
<p>Using <code>Default::default()</code>:</p>
<pre><code class="language-rust ignore">let person: Person = Default::default();</code></pre>
</li>
</ol>
<ul>
<li><strong>Note</strong>: Both methods are equivalent; <code>Person::default()</code> explicitly calls the <code>default</code> function for the <code>Person</code> type, while <code>Default::default()</code> relies on type inference to determine which <code>default</code> function to call.</li>
</ul>
<p><strong>Creating an Instance with All Default Values</strong></p>
<p>You can create an instance with all fields set to their default values:</p>
<pre><code class="language-rust ignore">let mut anna = Person::default();</code></pre>
<ul>
<li>This creates a <code>Person</code> instance where <code>name</code> is an empty <code>String</code>, and <code>age</code> is <code>0</code> (the default value for <code>u8</code>).</li>
</ul>
<p><strong>Using Default Values in Struct Update Syntax</strong></p>
<p>You can create a new instance by overriding some fields and filling in the rest with default values:</p>
<pre><code class="language-rust ignore">let person = Person {
    name: String::from("Eve"),
    ..Person::default()
};</code></pre>
<ul>
<li>Here, we explicitly call <code>Person::default()</code> to provide the default values for the remaining fields.</li>
</ul>
<p><strong>When to Use Which</strong></p>
<ul>
<li>Use <code>Person::default()</code> when you want to be explicit about the type.</li>
<li>Use <code>Default::default()</code> when the type can be inferred, or when you prefer the more general approach.</li>
</ul>
<h3 id="934-implementing-the-default-trait-manually"><a class="header" href="#934-implementing-the-default-trait-manually">9.3.4 Implementing the <code>Default</code> Trait Manually</a></h3>
<p>If you need custom default values or cannot derive <code>Default</code>, you can implement the <code>Default</code> trait manually:</p>
<pre><code class="language-rust ignore">impl Default for Person {
    fn default() -&gt; Self {
        Person {
            name: String::from("Unknown"),
            age: 0,
        }
    }
}</code></pre>
<p>You can then use <code>Person::default()</code> or <code>Default::default()</code> as before.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="94-tuple-structs"><a class="header" href="#94-tuple-structs">9.4 Tuple Structs</a></h2>
<p>Tuple structs are a hybrid between structs and tuples. They have a name but their fields are unnamed.</p>
<h3 id="941-defining-tuple-structs"><a class="header" href="#941-defining-tuple-structs">9.4.1 Defining Tuple Structs</a></h3>
<pre><code class="language-rust ignore">struct StructName(Type1, Type2, /* ... */);</code></pre>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(u8, u8, u8);
<span class="boring">}</span></code></pre></pre>
<h3 id="942-instantiating-tuple-structs"><a class="header" href="#942-instantiating-tuple-structs">9.4.2 Instantiating Tuple Structs</a></h3>
<pre><code class="language-rust ignore">let red = Color(255, 0, 0);</code></pre>
<h3 id="943-accessing-fields"><a class="header" href="#943-accessing-fields">9.4.3 Accessing Fields</a></h3>
<p>Fields in tuple structs are accessed using dot notation with indices.</p>
<pre><code class="language-rust ignore">println!("Red component: {}", red.0);</code></pre>
<h3 id="944-use-cases-for-tuple-structs"><a class="header" href="#944-use-cases-for-tuple-structs">9.4.4 Use Cases for Tuple Structs</a></h3>
<ul>
<li>
<p><strong>Distinct Types</strong>: Tuple structs create new types, even if their fields have the same types as other tuple structs.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Inches(i32);
struct Centimeters(i32);
let length_in = Inches(10);
let length_cm = Centimeters(25);
// Inches and Centimeters are different types, even though both contain an i32.
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>This helps with type safety, preventing errors caused by mixing different units or concepts.</p>
</li>
</ul>
<h3 id="945-comparison-with-tuples"><a class="header" href="#945-comparison-with-tuples">9.4.5 Comparison with Tuples</a></h3>
<ul>
<li>
<p>Regular tuples with the same types are considered the same type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point1 = (1, 2);
let point2 = (3, 4);
// point1 and point2 are of the same type: (i32, i32)
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Tuple structs, even with the same fields, are different types.</p>
</li>
</ul>
<h3 id="946-comparison-with-c"><a class="header" href="#946-comparison-with-c">9.4.6 Comparison with C</a></h3>
<p>C does not have a direct equivalent of tuple structs. The closest comparison is using structs with anonymous fields, though this is not commonly used.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="95-unit-like-structs"><a class="header" href="#95-unit-like-structs">9.5 Unit-Like Structs</a></h2>
<p>Unit-like structs are structs with no fields. They are primarily used to implement traits or act as markers.</p>
<h3 id="951-defining-unit-like-structs"><a class="header" href="#951-defining-unit-like-structs">9.5.1 Defining Unit-Like Structs</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UnitStruct;
<span class="boring">}</span></code></pre></pre>
<h3 id="952-using-unit-like-structs"><a class="header" href="#952-using-unit-like-structs">9.5.2 Using Unit-Like Structs</a></h3>
<p>Although they carry no data, unit-like structs can still be instantiated.</p>
<pre><code class="language-rust ignore">let unit = UnitStruct;</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="96-methods-and-associated-functions"><a class="header" href="#96-methods-and-associated-functions">9.6 Methods and Associated Functions</a></h2>
<p>Methods are functions associated with a struct, allowing you to define behavior specific to your types and encapsulate functionality.</p>
<h3 id="961-the-impl-block"><a class="header" href="#961-the-impl-block">9.6.1 The <code>impl</code> Block</a></h3>
<p>Methods and associated functions are defined within an <code>impl</code> (implementation) block for a struct.</p>
<pre><code class="language-rust ignore">impl StructName {
    // Methods and associated functions go here
}</code></pre>
<h3 id="962-associated-functions"><a class="header" href="#962-associated-functions">9.6.2 Associated Functions</a></h3>
<p>Associated functions are functions that are tied to a struct but do not require an instance. These functions do not take <code>self</code> as a parameter.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">impl Person {
    fn new(name: String, age: u8) -&gt; Person {
        Person { name, age }
    }
}</code></pre>
<ul>
<li>You call associated functions using the <code>StructName::function_name()</code> syntax.</li>
</ul>
<pre><code class="language-rust ignore">fn main() {
    let person = Person::new(String::from("Frank"), 40);
}</code></pre>
<h3 id="963-methods"><a class="header" href="#963-methods">9.6.3 Methods</a></h3>
<p>Methods are functions that operate on an instance of a struct. They take <code>self</code> as the first parameter.</p>
<h4 id="defining-methods"><a class="header" href="#defining-methods">Defining Methods</a></h4>
<pre><code class="language-rust ignore">impl StructName {
    fn method_name(&amp;self) {
        // Method body
    }
}</code></pre>
<ul>
<li><code>&amp;self</code> is shorthand for <code>self: &amp;Self</code>, where <code>Self</code> refers to the struct type.</li>
</ul>
<h4 id="benefits-of-methods"><a class="header" href="#benefits-of-methods">Benefits of Methods</a></h4>
<ul>
<li><strong>Encapsulation</strong>: Methods encapsulate behavior related to a type.</li>
<li><strong>Namespace</strong>: Methods are namespaced by the struct, preventing name collisions.</li>
<li><strong>Method Syntax</strong>: Using methods enables a more object-oriented style of programming.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">struct Person {
</span><span class="boring">    name: String,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span>impl Person {
    fn new(name: String, age: u8) -&gt; Person {
        Person { name, age }
    }
    fn greet(&amp;self) {
        println!("Hello, my name is {}.", self.name);
    }
}
fn main() {
    let person = Person::new(String::from("Grace"), 35);
    person.greet();
}</code></pre></pre>
<ul>
<li>In this example, <code>greet</code> is a method that operates on a <code>Person</code> instance.</li>
</ul>
<h4 id="mutable-methods"><a class="header" href="#mutable-methods">Mutable Methods</a></h4>
<p>If a method needs to modify the instance, it must take <code>&amp;mut self</code>.</p>
<pre><code class="language-rust ignore">fn update_age(&amp;mut self, new_age: u8) {
    self.age = new_age;
}</code></pre>
<h4 id="consuming-methods"><a class="header" href="#consuming-methods">Consuming Methods</a></h4>
<p>Methods can take ownership of the instance by using <code>self</code> without a reference.</p>
<pre><code class="language-rust ignore">fn into_name(self) -&gt; String {
    self.name
}</code></pre>
<h4 id="calling-methods"><a class="header" href="#calling-methods">Calling Methods</a></h4>
<p>Methods are called using dot notation.</p>
<pre><code class="language-rust ignore">fn main() {
    let mut person = Person::new(String::from("Grace"), 35);
    person.update_age(36);
    println!("{} is now {} years old.", person.name, person.age);
}</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="97-the-self-parameter"><a class="header" href="#97-the-self-parameter">9.7 The <code>self</code> Parameter</a></h2>
<h3 id="971-different-forms-of-self"><a class="header" href="#971-different-forms-of-self">9.7.1 Different Forms of <code>self</code></a></h3>
<ul>
<li><code>self</code>: Takes ownership of the instance.</li>
<li><code>&amp;self</code>: Borrows the instance immutably.</li>
<li><code>&amp;mut self</code>: Borrows the instance mutably.</li>
</ul>
<h3 id="972-choosing-the-right-form"><a class="header" href="#972-choosing-the-right-form">9.7.2 Choosing the Right Form</a></h3>
<ul>
<li>Use <code>&amp;self</code> when you only need to read data.</li>
<li>Use <code>&amp;mut self</code> when you need to modify data.</li>
<li>Use <code>self</code> when you need to consume the instance.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="98-getters-and-setters"><a class="header" href="#98-getters-and-setters">9.8 Getters and Setters</a></h2>
<p>Getters and setters are methods used to access and modify struct fields, often employed to enforce encapsulation and maintain invariants.</p>
<h3 id="981-getters"><a class="header" href="#981-getters">9.8.1 Getters</a></h3>
<p>A getter method returns a reference to a field.</p>
<pre><code class="language-rust ignore">impl Person {
    fn name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}</code></pre>
<h3 id="982-setters"><a class="header" href="#982-setters">9.8.2 Setters</a></h3>
<p>A setter method modifies a field.</p>
<pre><code class="language-rust ignore">impl Person {
    fn set_age(&amp;mut self, age: u8) {
        self.age = age;
    }
}</code></pre>
<ul>
<li>Setters can include validation logic to ensure the field is set to a valid value.</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-rust ignore">impl Person {
    fn set_age(&amp;mut self, age: u8) {
        if age &gt;= self.age {
            self.age = age;
        } else {
            println!("Cannot decrease age.");
        }
    }
}</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="99-structs-and-ownership"><a class="header" href="#99-structs-and-ownership">9.9 Structs and Ownership</a></h2>
<h3 id="991-ownership-of-fields"><a class="header" href="#991-ownership-of-fields">9.9.1 Ownership of Fields</a></h3>
<p>Structs can own data. When a struct instance goes out of scope, its owned data is dropped.</p>
<pre><pre class="playground"><code class="language-rust editable">struct DataHolder {
    data: String,
}

fn main() {
    let holder = DataHolder {
        data: String::from("Some data"),
    };
    // `holder` owns the `String` data
}</code></pre></pre>
<h3 id="992-borrowing-in-structs"><a class="header" href="#992-borrowing-in-structs">9.9.2 Borrowing in Structs</a></h3>
<p>Structs can hold references, but you need to specify lifetimes.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RefHolder&lt;'a&gt; {
    data: &amp;'a str,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>Lifetimes ensure that the referenced data outlives the struct instance.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="910-structs-with-references-and-lifetimes"><a class="header" href="#910-structs-with-references-and-lifetimes">9.10 Structs with References and Lifetimes</a></h2>
<h3 id="9101-defining-structs-with-references"><a class="header" href="#9101-defining-structs-with-references">9.10.1 Defining Structs with References</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct PersonRef&lt;'a&gt; {
    name: &amp;'a str,
    age: u8,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The lifetime <code>'a</code> specifies that the <code>name</code> reference must live at least as long as the <code>PersonRef</code> instance.</li>
</ul>
<h3 id="9102-using-structs-with-references"><a class="header" href="#9102-using-structs-with-references">9.10.2 Using Structs with References</a></h3>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">struct PersonRef&lt;'a&gt; {
</span><span class="boring">    name: &amp;'a str,
</span><span class="boring">    age: u8,
</span><span class="boring">}
</span>fn main() {
    let name = String::from("Henry");
    let person = PersonRef {
        name: &amp;name,
        age: 50,
    };
    println!("Name: {}, Age: {}", person.name, person.age);
}</code></pre></pre>
<ul>
<li>The referenced data must outlive the struct instance.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="911-generic-structs"><a class="header" href="#911-generic-structs">9.11 Generic Structs</a></h2>
<h3 id="9111-defining-generic-structs"><a class="header" href="#9111-defining-generic-structs">9.11.1 Defining Generic Structs</a></h3>
<p>You can define structs that are generic over types.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T&gt; {
    x: T,
    y: T,
}
<span class="boring">}</span></code></pre></pre>
<h3 id="9112-using-generic-structs"><a class="header" href="#9112-using-generic-structs">9.11.2 Using Generic Structs</a></h3>
<pre><pre class="playground"><code class="language-rust editable"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span>fn main() {
    let integer_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };
}</code></pre></pre>
<ul>
<li>The type <code>T</code> is determined when the struct is instantiated.</li>
</ul>
<h3 id="9113-methods-on-generic-structs"><a class="header" href="#9113-methods-on-generic-structs">9.11.3 Methods on Generic Structs</a></h3>
<pre><code class="language-rust ignore">impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}</code></pre>
<ul>
<li>You can implement methods for generic structs.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="912-comparing-rust-structs-with-oop-concepts"><a class="header" href="#912-comparing-rust-structs-with-oop-concepts">9.12 Comparing Rust Structs with OOP Concepts</a></h2>
<p>For readers familiar with object-oriented programming languages like C++ or Java, it's helpful to understand how Rust's structs relate to objects and classes.</p>
<ul>
<li><strong>Classes vs. Structs</strong>: In Rust, structs combined with <code>impl</code> blocks provide functionality similar to classes in OOP languages.
<ul>
<li><strong>Structs</strong> hold data (fields).</li>
<li><strong>Methods</strong> and <strong>associated functions</strong> provide behavior.</li>
</ul>
</li>
<li><strong>Inheritance</strong>: Rust does not support inheritance as in OOP languages. Instead, Rust uses traits to define shared behavior.</li>
<li><strong>Encapsulation</strong>: Rust allows you to control visibility using the <code>pub</code> keyword.</li>
<li><strong>Ownership and Borrowing</strong>: Rust's ownership model replaces some OOP features, focusing on safety and concurrency.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="913-derived-traits"><a class="header" href="#913-derived-traits">9.13 Derived Traits</a></h2>
<p>Rust allows you to automatically implement certain traits for your structs using the <code>#[derive]</code> attribute.</p>
<h3 id="9131-common-traits"><a class="header" href="#9131-common-traits">9.13.1 Common Traits</a></h3>
<ul>
<li><code>Debug</code>: Allows formatting using <code>{:?}</code>.</li>
<li><code>Clone</code>: Allows cloning of instances.</li>
<li><code>Copy</code>: Allows bitwise copying (requires all fields to implement <code>Copy</code>).</li>
<li><code>PartialEq</code>: Enables equality comparisons using <code>==</code> and <code>!=</code>.</li>
<li><code>Default</code>: Provides a default value for the type.</li>
</ul>
<h3 id="9132-example-deriving-debug"><a class="header" href="#9132-example-deriving-debug">9.13.2 Example: Deriving <code>Debug</code></a></h3>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}
fn main() {
    let p = Point { x: 1, y: 2 };
    println!("{:?}", p);    // Prints: Point { x: 1, y: 2 }
    println!("{:#?}", p);   // Pretty-prints the struct
}</code></pre></pre>
<ul>
<li>Using <code>{:?}</code> formats the struct in a compact way.</li>
<li>Using <code>{:#?}</code> pretty-prints the struct with indentation.</li>
</ul>
<p><strong>Output:</strong></p>
<pre><code>Point { x: 1, y: 2 }
Point {
    x: 1,
    y: 2,
}
</code></pre>
<h3 id="9133-implementing-traits-manually"><a class="header" href="#9133-implementing-traits-manually">9.13.3 Implementing Traits Manually</a></h3>
<p>You can also implement traits manually to customize behavior.</p>
<p><strong>Implementing <code>Default</code> Manually:</strong></p>
<pre><code class="language-rust ignore">impl Default for Point {
    fn default() -&gt; Self {
        Point { x: 0, y: 0 }
    }
}</code></pre>
<p><strong>Implementing <code>Display</code> Manually:</strong></p>
<pre><code class="language-rust ignore">impl std::fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter) -&gt; std::fmt::Result {
        write!(f, "Point({}, {})", self.x, self.y)
    }
}</code></pre>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="914-additional-topics"><a class="header" href="#914-additional-topics">9.14 Additional Topics</a></h2>
<h3 id="9141-struct-visibility"><a class="header" href="#9141-struct-visibility">9.14.1 Struct Visibility</a></h3>
<p>By default, structs and their fields are private to the module. You can make them public using the <code>pub</code> keyword.</p>
<pre><code class="language-rust ignore">pub struct PublicStruct {
    pub field: Type,
}</code></pre>
<ul>
<li><strong>Modules and Crates</strong>: We'll discuss visibility and modules in a later chapter.</li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h2 id="915-exercises"><a class="header" href="#915-exercises">9.15 Exercises</a></h2>
<ol>
<li>
<p><strong>Defining and Using a Struct</strong></p>
<p>Define a <code>Rectangle</code> struct with <code>width</code> and <code>height</code> fields. Implement methods to calculate the area and perimeter.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn perimeter(&amp;self) -&gt; u32 {
        2 * (self.width + self.height)
    }
}

fn main() {
    let rect = Rectangle { width: 10, height: 20 };
    println!("Area: {}", rect.area());
    println!("Perimeter: {}", rect.perimeter());
}</code></pre></pre>
</li>
<li>
<p><strong>Generic Struct</strong></p>
<p>Create a generic <code>Pair</code> struct that holds two values of any type. Implement a method to return a reference to the first value.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Pair&lt;T, U&gt; {
    first: T,
    second: U,
}

impl&lt;T, U&gt; Pair&lt;T, U&gt; {
    fn first(&amp;self) -&gt; &amp;T {
        &amp;self.first
    }
}

fn main() {
    let pair = Pair { first: "Hello", second: 42 };
    println!("First: {}", pair.first());
}</code></pre></pre>
</li>
<li>
<p><strong>Struct with References and Lifetimes</strong></p>
<p>Define a <code>Book</code> struct that holds references to <code>title</code> and <code>author</code>. Ensure that lifetimes are handled correctly.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Book&lt;'a&gt; {
    title: &amp;'a str,
    author: &amp;'a str,
}

fn main() {
    let title = String::from("Rust Programming");
    let author = String::from("John Doe");

    let book = Book {
        title: &amp;title,
        author: &amp;author,
    };

    println!("{} by {}", book.title, book.author);
}</code></pre></pre>
</li>
<li>
<p><strong>Implementing Traits</strong></p>
<p>Derive the <code>Debug</code> and <code>PartialEq</code> traits for a <code>Point</code> struct. Create instances and compare them.</p>
<pre><pre class="playground"><code class="language-rust editable">#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p1 = Point { x: 1, y: 2 };
    let p2 = Point { x: 1, y: 2 };

    println!("{:?}", p1);
    println!("Points are equal: {}", p1 == p2);
}</code></pre></pre>
</li>
<li>
<p><strong>Method Consuming Self</strong></p>
<p>Implement a method for <code>Person</code> that consumes the instance and returns the <code>name</code>.</p>
<pre><pre class="playground"><code class="language-rust editable">struct Person {
    name: String,
    age: u8,
}

impl Person {
    fn into_name(self) -&gt; String {
        self.name
    }
}

fn main() {
    let person = Person { name: String::from("Ivy"), age: 29 };
    let name = person.into_name();
    println!("Name: {}", name);
    // person can no longer be used here
}</code></pre></pre>
</li>
</ol>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="summary-2"><a class="header" href="#summary-2">Summary</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="917-closing-thoughts"><a class="header" href="#917-closing-thoughts">9.17 Closing Thoughts</a></h2>
<p>Structs in Rust, combined with methods and traits, provide a powerful way to create robust and expressive code. Mastering structs is key to writing effective Rust programs.</p>
<p>As you continue your Rust journey, remember to:</p>
<ul>
<li>Practice defining and using structs in various contexts.</li>
<li>Explore how structs interact with ownership, borrowing, and lifetimes.</li>
<li>Experiment with methods and associated functions to encapsulate functionality.</li>
<li>Use derived traits to simplify your code and leverage Rust's standard library.</li>
</ul>
<p>In the next chapter, we'll dive into enums and pattern matching, expanding your Rust toolkit further.</p>
<p>Happy coding!</p>
<hr />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
